[
    {
        "id": "european_football_2",
        "question": "Please list all team names which the speed class is fast.",
        "original_query": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "llm_output": "SELECT DISTINCT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast';",
        "pred_query": "SELECT DISTINCT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast';",
        "pred_time": 0.002432107925415039,
        "orig_time": 0.0015454292297363281,
        "time_ratio": 0.6354278992255661,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many circuits are there in Melbourne, Australia?",
        "original_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia'",
        "llm_output": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';",
        "pred_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';",
        "pred_time": 0.0008544921875,
        "orig_time": 0.0005071163177490234,
        "time_ratio": 0.5934709821428571,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many Formula_1 races took place on the circuits in Italy?",
        "original_query": "SELECT COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Italy'",
        "llm_output": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';",
        "pred_query": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';",
        "pred_time": 0.0011942386627197266,
        "orig_time": 0.0007717609405517578,
        "time_ratio": 0.6462367738071472,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "original_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "llm_output": "-- Reasoning\nTo find the proportion, we need to count cards that are textless AND have a normal layout, then divide by the total number of cards.\nThe `cards` table contains `isTextless` (1 for textless) and `layout` columns.\nWe will filter for `isTextless = 1` and `layout = 'normal'`, count these, and divide by the total count of cards in the `cards` table, casting to REAL for accurate division.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_time": 0.06461691856384277,
        "orig_time": 0.05651235580444336,
        "time_ratio": 0.8745752205532372,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What's the magic card market name for the set which was released on 2017/6/9?",
        "original_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "llm_output": "-- Reasoning\nThe question asks for the 'magic card market name' (`mcmName`) of a set.\nThe condition to identify the set is its 'release date'.\nBoth `mcmName` and `releaseDate` columns are available in the `sets` table.\nI will query the `sets` table, filtering by `releaseDate` to find the corresponding `mcmName`.\n\n-- SQL Query\nSELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';",
        "pred_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';",
        "pred_time": 0.01000213623046875,
        "orig_time": 0.0034246444702148438,
        "time_ratio": 0.3423913043478261,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the percentage of molecules that are carcinogenic?",
        "original_query": "SELECT CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id) FROM molecule t",
        "llm_output": "-- Reasoning\nTo find the percentage of carcinogenic molecules, we need to count molecules with a label '+' and divide by the total number of molecules.\nThe `molecule` table contains the `label` column which indicates carcinogenicity.\nWe will use a CAST to FLOAT for accurate percentage calculation and multiply by 100.0.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(molecule_id) FROM molecule;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(molecule_id) FROM molecule;",
        "pred_time": 0.0007603168487548828,
        "orig_time": 0.00046324729919433594,
        "time_ratio": 0.6092819065537786,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What is the percentage of borderless cards?",
        "original_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "llm_output": "-- Reasoning\nTo find the percentage of borderless cards, we need to count all cards and count the cards specifically marked as 'borderless' in the `borderColor` column.\nThen, we will divide the count of borderless cards by the total count of cards and multiply by 100.0 to get the percentage.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(*) FROM cards;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(*) FROM cards;",
        "pred_time": 0.06210780143737793,
        "orig_time": 0.053601741790771484,
        "time_ratio": 0.86304362012906,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "original_query": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the `budget_id` from the `budget` table.\nThe budget should be for categories related to 'water', 'chips', or 'cookies'.\nAmong these, I need to select the one with the maximum `amount`.\n\n-- SQL Query\nSELECT budget_id\nFROM budget\nWHERE category LIKE '%water%' OR category LIKE '%chips%' OR category LIKE '%cookies%'\nORDER BY amount DESC\nLIMIT 1;",
        "pred_query": "SELECT budget_id\nFROM budget\nWHERE category LIKE '%water%' OR category LIKE '%chips%' OR category LIKE '%cookies%'\nORDER BY amount DESC\nLIMIT 1;",
        "pred_time": 0.0011105537414550781,
        "orig_time": 0.0005156993865966797,
        "time_ratio": 0.4643623872906827,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "original_query": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "llm_output": "-- Reasoning\nThe query needs to retrieve information for female patients whose Total Protein (TP) levels are outside the normal range.\nAssuming a common normal range for TP is 6.0 to 8.0, \"beyond the normal index\" means TP < 6.0 or TP > 8.0.\nThe deviation is calculated as `6.0 - TP` for values below the lower limit and `TP - 8.0` for values above the upper limit.\nWe join `Patient` and `Laboratory` tables on `ID` to filter by sex and TP values, then apply a conditional calculation for the deviation.\n\n-- SQL Query\nSELECT\n  T1.ID,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0 THEN 6.0 - T2.TP\n    WHEN T2.TP > 8.0 THEN T2.TP - 8.0\n    ELSE 0.0 -- Should not be reached due to WHERE clause\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'Female' AND (T2.TP < 6.0 OR T2.TP > 8.0);",
        "pred_query": "SELECT\n  T1.ID,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0 THEN 6.0 - T2.TP\n    WHEN T2.TP > 8.0 THEN T2.TP - 8.0\n    ELSE 0.0 -- Should not be reached due to WHERE clause\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'Female' AND (T2.TP < 6.0 OR T2.TP > 8.0);",
        "pred_time": 0.0008862018585205078,
        "orig_time": 0.0044345855712890625,
        "time_ratio": 5.004035512510089,
        "check": false
    },
    {
        "id": "card_games",
        "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
        "original_query": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "llm_output": "-- Reasoning\nTo find the release date of the set containing \"Ancestor's Chosen\", I first need to find the `setCode` of the card from the `cards` table.\nThen, using this `setCode`, I can query the `sets` table to retrieve the `releaseDate`.\n\n-- SQL Query\nSELECT T1.releaseDate FROM sets AS T1 INNER JOIN cards AS T2 ON T1.code = T2.setCode WHERE T2.name = 'Ancestor''s Chosen'",
        "pred_query": "SELECT T1.releaseDate FROM sets AS T1 INNER JOIN cards AS T2 ON T1.code = T2.setCode WHERE T2.name = 'Ancestor''s Chosen'",
        "pred_time": 0.06765413284301758,
        "orig_time": 0.0604097843170166,
        "time_ratio": 0.8929208280178459,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "original_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "llm_output": "-- Reasoning\nI need to retrieve the 'q1' column from the 'qualifying' table.\nTo identify the correct record, I will join 'qualifying' with 'drivers' to filter by the driver's name ('Bruno Senna').\nI will also filter by the specific 'raceId' (354).\n\n-- SQL Query\nSELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Bruno' AND T2.surname = 'Senna' AND T1.raceId = 354;",
        "pred_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Bruno' AND T2.surname = 'Senna' AND T1.raceId = 354;",
        "pred_time": 0.0018913745880126953,
        "orig_time": 0.001461029052734375,
        "time_ratio": 0.772469431488718,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "original_query": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "llm_output": "-- Reasoning\nTo find the free rate, we need to join the `schools` table with the `frpm` table using `CDSCode`.\nWe will filter the `schools` table to find the school administered by 'Kacey Gibson' using the `AdmFName` and `AdmLName` columns.\nThen, we will select the `Free Meal Count (Ages 5-17)` and `Enrollment (Ages 5-17)` from the `frpm` table and calculate their ratio.\n\n-- SQL Query\nSELECT T1.`Free Meal Count (Ages 5-17)` * 1.0 / T1.`Enrollment (Ages 5-17)`\nFROM frpm AS T1\nINNER JOIN schools AS T2\n  ON T1.CDSCode = T2.CDSCode\nWHERE\n  (\n    T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson'\n  ) OR (\n    T2.AdmFName2 = 'Kacey' AND T2.AdmLName2 = 'Gibson'\n  ) OR (\n    T2.AdmFName3 = 'Kacey' AND T2.AdmLName3 = 'Gibson'\n  );",
        "pred_query": "SELECT T1.`Free Meal Count (Ages 5-17)` * 1.0 / T1.`Enrollment (Ages 5-17)`\nFROM frpm AS T1\nINNER JOIN schools AS T2\n  ON T1.CDSCode = T2.CDSCode\nWHERE\n  (\n    T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson'\n  ) OR (\n    T2.AdmFName2 = 'Kacey' AND T2.AdmLName2 = 'Gibson'\n  ) OR (\n    T2.AdmFName3 = 'Kacey' AND T2.AdmLName3 = 'Gibson'\n  );",
        "pred_time": 0.014900445938110352,
        "orig_time": 0.009860038757324219,
        "time_ratio": 0.6617277629326208,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "original_query": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "llm_output": "\nSELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0\n",
        "pred_query": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "pred_time": 0.009846925735473633,
        "orig_time": 0.008391857147216797,
        "time_ratio": 0.8522311808430788,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What's Angela Sanders's major?",
        "original_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "llm_output": "-- Reasoning\nTo find Angela Sanders's major, I need to look up her record in the 'member' table using her first and last name.\nThen, I will use the 'link_to_major' column from the 'member' table to join with the 'major' table.\nFinally, I will select the 'major_name' from the 'major' table.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_time": 0.0009379386901855469,
        "orig_time": 0.00047850608825683594,
        "time_ratio": 0.5101677681748856,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "llm_output": "-- Reasoning\nI need to count distinct patients.\nA patient has a normal anti-ribonuclear protein (RNP) level if `RNP` is 'normal' in the `Laboratory` table.\nA patient has been admitted to the hospital if `Admission` is 'Yes' in the `Patient` table.\nI will join `Patient` and `Laboratory` tables on `ID` and apply these two conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'normal' AND T1.Admission = 'Yes';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'normal' AND T1.Admission = 'Yes';",
        "pred_time": 0.0010781288146972656,
        "orig_time": 0.0057027339935302734,
        "time_ratio": 5.2894736842105265,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "original_query": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' THEN 1 ELSE NULL END) FROM cards",
        "llm_output": "-- Reasoning\nI need to count the number of distinct artists.\nThe artists must have designed cards that meet two criteria:\n1. The card's `borderColor` is 'black'.\n2. The card's `availability` includes both 'arena' and 'mtgo'. The `availability` column appears to be a string that might contain multiple types, so I should use `LIKE` for matching.\n\n-- SQL Query\nSELECT COUNT(DISTINCT artist)\nFROM cards\nWHERE borderColor = 'black'\n  AND availability LIKE '%arena%'\n  AND availability LIKE '%mtgo%';",
        "pred_query": "SELECT COUNT(DISTINCT artist)\nFROM cards\nWHERE borderColor = 'black'\n  AND availability LIKE '%arena%'\n  AND availability LIKE '%mtgo%';",
        "pred_time": 0.06450414657592773,
        "orig_time": 0.056229352951049805,
        "time_ratio": 0.8717168730364073,
        "check": false
    },
    {
        "id": "superhero",
        "question": "What is the name of the superhero that has the most powers?",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the superhero with the most powers, I need to count the powers for each superhero.\nI will join the `superhero` table with the `hero_power` table.\nThen, I will group the results by superhero name and count the powers.\nFinally, I will order by the count in descending order and take the top one.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_time": 0.002415180206298828,
        "orig_time": 0.002042531967163086,
        "time_ratio": 0.8457058242843041,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "llm_output": "-- Reasoning\nTo find patients with normal anti-SSB and symptoms, we need to join the Laboratory and Examination tables on Patient ID.\nFilter Laboratory records where SSB is 'negative' or '0' (interpreting 'normal').\nFilter Examination records where Symptoms are present (not NULL and not an empty string).\nFinally, count the distinct patient IDs that satisfy both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID)\nFROM Laboratory AS T1\nINNER JOIN Examination AS T2\n  ON T1.ID = T2.ID\nWHERE\n  (\n    T1.SSB = 'negative' OR T1.SSB = '0'\n  )\n  AND (\n    T2.Symptoms IS NOT NULL AND T2.Symptoms != ''\n  );",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID)\nFROM Laboratory AS T1\nINNER JOIN Examination AS T2\n  ON T1.ID = T2.ID\nWHERE\n  (\n    T1.SSB = 'negative' OR T1.SSB = '0'\n  )\n  AND (\n    T2.Symptoms IS NOT NULL AND T2.Symptoms != ''\n  );",
        "pred_time": 0.006569862365722656,
        "orig_time": 0.0015311241149902344,
        "time_ratio": 0.23305269269850487,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "original_query": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "llm_output": "-- Reasoning\nThe question asks to compare the number of male and female patients who have at least one creatinine (CRE) reading not within the normal range.\nBased on the provided few-shot example, `CRE >= 1.5` is considered \"out of the normal range\". I will use this condition.\nFirst, identify all distinct patient IDs from the `Laboratory` table where `CRE >= 1.5`.\nThen, join these IDs with the `Patient` table to get their sex.\nFinally, count the number of distinct male patients and distinct female patients from this filtered set and compare them.\n\n-- SQL Query\nSELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN (SELECT DISTINCT ID FROM Laboratory WHERE CRE >= 1.5) AS T2 ON T1.ID = T2.ID;",
        "pred_query": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN (SELECT DISTINCT ID FROM Laboratory WHERE CRE >= 1.5) AS T2 ON T1.ID = T2.ID;",
        "pred_time": 0.004767179489135742,
        "orig_time": 0.0031719207763671875,
        "time_ratio": 0.6653663415853963,
        "check": false
    },
    {
        "id": "student_club",
        "question": "List the name of students that have attended more than 7 events.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "llm_output": "-- Reasoning\nI need to join the `member` table with the `attendance` table to link members to their attended events.\nThen, I will group the results by member to count how many events each member attended.\nFinally, I will filter for members who attended more than 7 events and select their names.\n\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_query": "select their names.\n\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_time": null,
        "orig_time": 0.0007627010345458984,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many female customers have a junior credit card?",
        "original_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "llm_output": "\nSELECT\n  COUNT(DISTINCT T1.client_id)\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nINNER JOIN card AS T3\n  ON T2.disp_id = T3.disp_id\nWHERE\n  T1.gender = 'F' AND T3.type = 'junior';\n",
        "pred_query": "SELECT\n  COUNT(DISTINCT T1.client_id)\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nINNER JOIN card AS T3\n  ON T2.disp_id = T3.disp_id\nWHERE\n  T1.gender = 'F' AND T3.type = 'junior';",
        "pred_time": 0.0014801025390625,
        "orig_time": 0.0007600784301757812,
        "time_ratio": 0.5135309278350515,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "original_query": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "llm_output": "-- Reasoning\nI need to check if the `bond_id` 'TR001_1_8' connects two atoms, one being 'chlorine' and the other 'carbon'.\nI will join the `connected` table with the `atom` table twice, once for `atom_id` and once for `atom_id2`, to retrieve the elements of the connected atoms.\nThen, I will filter for the specific bond_id and check if the pair of elements is ('chlorine', 'carbon') or ('carbon', 'chlorine').\nFinally, I'll use a `CASE` statement with `EXISTS` to return 1 if such a bond exists, and 0 otherwise.\n\n-- SQL Query\nSELECT CASE WHEN EXISTS (\n  SELECT 1\n  FROM connected AS T1\n  INNER JOIN atom AS T2\n    ON T1.atom_id = T2.atom_id\n  INNER JOIN atom AS T3\n    ON T1.atom_id2 = T3.atom_id\n  WHERE\n    T1.bond_id = 'TR001_1_8' AND (\n      (T2.element = 'chlorine' AND T3.element = 'carbon') OR\n      (T2.element = 'carbon' AND T3.element = 'chlorine')\n    )\n) THEN 1 ELSE 0 END;",
        "pred_query": "SELECT CASE WHEN EXISTS (\n  SELECT 1\n  FROM connected AS T1\n  INNER JOIN atom AS T2\n    ON T1.atom_id = T2.atom_id\n  INNER JOIN atom AS T3\n    ON T1.atom_id2 = T3.atom_id\n  WHERE\n    T1.bond_id = 'TR001_1_8' AND (\n      (T2.element = 'chlorine' AND T3.element = 'carbon') OR\n      (T2.element = 'carbon' AND T3.element = 'chlorine')\n    )\n) THEN 1 ELSE 0 END;",
        "pred_time": 0.0032236576080322266,
        "orig_time": 0.0024061203002929688,
        "time_ratio": 0.7463944974484136,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "llm_output": "-- Reasoning\nThe question asks to count distinct patients who have both a \"normal Ig G level\" and \"symptoms\".\nSince no specific range is provided for \"normal Ig G level\" in the question or schema, we interpret \"normal\" as simply having a recorded Ig G value, i.e., `Laboratory.IGG IS NOT NULL`.\n\"Have symptoms\" implies that the `Examination.Symptoms` field contains actual information, not NULL or an empty string.\nWe join `Patient`, `Laboratory`, and `Examination` tables on `ID` to link the conditions to individual patients and count distinct `Patient.ID`s.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.IGG IS NOT NULL AND T3.Symptoms IS NOT NULL AND T3.Symptoms != '';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.IGG IS NOT NULL AND T3.Symptoms IS NOT NULL AND T3.Symptoms != '';",
        "pred_time": 0.009040594100952148,
        "orig_time": 0.0010688304901123047,
        "time_ratio": 0.11822569160579129,
        "check": false
    },
    {
        "id": "financial",
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "original_query": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.district_id = ( SELECT district_id FROM client ORDER BY birth_date DESC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the youngest client, we need to order by `birth_date` in descending order.\nTo find the highest average salary, we need to consider the `A11` column in the `district` table and order it in descending order.\nWe need to join `client`, `district`, `disp`, and `account` tables to link client birth date and district salary to account IDs.\n\n-- SQL Query\nSELECT\n  T3.account_id\nFROM client AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nINNER JOIN disp AS T4\n  ON T1.client_id = T4.client_id\nINNER JOIN account AS T3\n  ON T4.account_id = T3.account_id\nORDER BY\n  T1.birth_date DESC,\n  T2.A11 DESC\nLIMIT 1;",
        "pred_query": "SELECT\n  T3.account_id\nFROM client AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nINNER JOIN disp AS T4\n  ON T1.client_id = T4.client_id\nINNER JOIN account AS T3\n  ON T4.account_id = T3.account_id\nORDER BY\n  T1.birth_date DESC,\n  T2.A11 DESC\nLIMIT 1;",
        "pred_time": 0.0029180049896240234,
        "orig_time": 0.0010025501251220703,
        "time_ratio": 0.34357382139063647,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
        "original_query": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
        "llm_output": "-- Reasoning\nI need to count the number of races for each circuit within the specified year range (1990-2000).\nI will filter the `races` table by year and then group by `circuitId`.\nFinally, I will use a `HAVING` clause to select only those circuits that have a count of 4 races and join with the `circuits` table to get the circuit name.\n\nSELECT T1.name\nFROM circuits AS T1\nINNER JOIN races AS T2\n  ON T1.circuitId = T2.circuitId\nWHERE\n  T2.year BETWEEN 1990 AND 2000\nGROUP BY\n  T1.circuitId\nHAVING\n  COUNT(T2.raceId) = 4;",
        "pred_query": "select only those circuits that have a count of 4 races and join with the `circuits` table to get the circuit name.\n\nSELECT T1.name\nFROM circuits AS T1\nINNER JOIN races AS T2\n  ON T1.circuitId = T2.circuitId\nWHERE\n  T2.year BETWEEN 1990 AND 2000\nGROUP BY\n  T1.circuitId\nHAVING\n  COUNT(T2.raceId) = 4;",
        "pred_time": null,
        "orig_time": 0.0009484291076660156,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to count the number of superheroes for 'DC Comics' and 'Marvel Comics' separately.\nThen, I will compare these two counts to find which one is larger and calculate the absolute difference between them.\nThis can be achieved by using subqueries to get the counts for each publisher and then performing the subtraction.\n\n-- SQL Query\nSELECT\n  ABS(\n    (\n      SELECT\n        COUNT(T1.id)\n      FROM superhero AS T1\n      INNER JOIN publisher AS T2\n        ON T1.publisher_id = T2.id\n      WHERE\n        T2.publisher_name = 'DC Comics'\n    ) - (\n      SELECT\n        COUNT(T1.id)\n      FROM superhero AS T1\n      INNER JOIN publisher AS T2\n        ON T1.publisher_id = T2.id\n      WHERE\n        T2.publisher_name = 'Marvel Comics'\n    )\n  );",
        "pred_query": "SELECT\n  ABS(\n    (\n      SELECT\n        COUNT(T1.id)\n      FROM superhero AS T1\n      INNER JOIN publisher AS T2\n        ON T1.publisher_id = T2.id\n      WHERE\n        T2.publisher_name = 'DC Comics'\n    ) - (\n      SELECT\n        COUNT(T1.id)\n      FROM superhero AS T1\n      INNER JOIN publisher AS T2\n        ON T1.publisher_id = T2.id\n      WHERE\n        T2.publisher_name = 'Marvel Comics'\n    )\n  );",
        "pred_time": 0.0011937618255615234,
        "orig_time": 0.0006067752838134766,
        "time_ratio": 0.5082883962452567,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Please list the names of the badges obtained by csgillespie.",
        "original_query": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "llm_output": "-- Reasoning\nTo find the names of badges obtained by 'csgillespie', I need to join the 'badges' table with the 'users' table.\nI will filter the 'users' table by the `DisplayName` 'csgillespie'.\nThen, I will select the `Name` column from the 'badges' table for the matching records.\n\nSELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_query": "select the `Name` column from the 'badges' table for the matching records.\n\nSELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_time": null,
        "orig_time": 0.0644221305847168,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "original_query": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "llm_output": "\nSELECT T3.team_long_name FROM Match AS T1 INNER JOIN League AS T2 ON T1.league_id = T2.id INNER JOIN Team AS T3 ON T1.away_team_api_id = T3.team_api_id WHERE T2.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T3.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1\n",
        "pred_query": "SELECT T3.team_long_name FROM Match AS T1 INNER JOIN League AS T2 ON T1.league_id = T2.id INNER JOIN Team AS T3 ON T1.away_team_api_id = T3.team_api_id WHERE T2.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T3.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1",
        "pred_time": 0.05476689338684082,
        "orig_time": 0.05181384086608887,
        "time_ratio": 0.9460796050655395,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the bond type for atoms with element Tin?",
        "original_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "llm_output": "-- Reasoning\nI need to find the `bond_type` from the `bond` table.\nTo link bonds to atoms, I will use the `connected` table, joining `bond.bond_id` with `connected.bond_id`.\nThen, to identify atoms with element 'Tin', I will join `connected.atom_id` with `atom.atom_id` and filter for `atom.element = 'Tin'`.\nFinally, I will select distinct `bond_type` values.\n\n-- SQL Query\nSELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Tin';",
        "pred_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Tin';",
        "pred_time": 0.017424583435058594,
        "orig_time": 0.013860225677490234,
        "time_ratio": 0.7954408625690985,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "original_query": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "llm_output": "\nSELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'\n",
        "pred_query": "SELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "pred_time": 0.35198402404785156,
        "orig_time": 0.34131622314453125,
        "time_ratio": 0.9696923718848386,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "llm_output": "-- Reasoning\nTo answer the question, we need to count unique examinations that satisfy two conditions:\n1. The examination date is after '1997-01-01'.\n2. The examination has an associated `APTT` (inactivated partial prothrombin time) result, meaning `APTT` is not NULL.\n\nWe will join the `Examination` table with the `Laboratory` table on their common `ID` column.\nThen, we apply the date filter on `Examination.Examination Date` and the `APTT` filter on `Laboratory.APTT`.\nFinally, to count unique examinations, we use `COUNT(DISTINCT T1.ID, T1.\"Examination Date\")`, as an examination is uniquely identified by the patient's ID and the examination date.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID, T1.`Examination Date`)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE T1.`Examination Date` > '1997-01-01'\n  AND T2.APTT IS NOT NULL;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID, T1.`Examination Date`)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE T1.`Examination Date` > '1997-01-01'\n  AND T2.APTT IS NOT NULL;",
        "pred_time": null,
        "orig_time": 0.004502296447753906,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'Owner' AND T1.frequency = 'POPLATEK TYDNE'",
        "llm_output": "-- Reasoning\nI need to count distinct clients.\nClients are linked to accounts via the 'disp' table.\nThe 'disp' table also indicates if the client is an 'Owner'.\nThe 'account' table contains the 'frequency' of statements.\nI will join 'account' with 'disp' and filter by `account.frequency = 'WEEKLY'` and `disp.type = 'OWNER'`.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.client_id)\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nINNER JOIN account AS T3\n  ON T2.account_id = T3.account_id\nWHERE\n  T3.frequency = 'WEEKLY' AND T2.type = 'OWNER';",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id)\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nINNER JOIN account AS T3\n  ON T2.account_id = T3.account_id\nWHERE\n  T3.frequency = 'WEEKLY' AND T2.type = 'OWNER';",
        "pred_time": 0.0025353431701660156,
        "orig_time": 0.0008313655853271484,
        "time_ratio": 0.3279104758322362,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users received commentator badges in 2014?",
        "original_query": "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'",
        "llm_output": "-- Reasoning\nI need to count the distinct user IDs from the 'badges' table.\nThe badges must have the 'Name' 'Commentator'.\nThe 'Date' of the badge must fall within the year 2014.\n\n-- SQL Query\nSELECT COUNT(DISTINCT UserId)\nFROM badges\nWHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014';",
        "pred_query": "SELECT COUNT(DISTINCT UserId)\nFROM badges\nWHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014';",
        "pred_time": 0.0105133056640625,
        "orig_time": 0.009321212768554688,
        "time_ratio": 0.886611030478955,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users are awarded with more than 5 badges?",
        "original_query": "SELECT UserId FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "llm_output": "-- Reasoning\nI need to count badges per user and then filter for users with more than 5 badges.\nFirst, I will group the `badges` table by `UserId`.\nThen, I will count the `Id` for each group and filter groups where the count is greater than 5.\nFinally, I will count the number of distinct UserIds that satisfy this condition.\n\n-- SQL Query\nSELECT COUNT(T1.UserId) FROM badges AS T1 GROUP BY T1.UserId HAVING COUNT(T1.Id) > 5;",
        "pred_query": "SELECT COUNT(T1.UserId) FROM badges AS T1 GROUP BY T1.UserId HAVING COUNT(T1.Id) > 5;",
        "pred_time": 0.0309445858001709,
        "orig_time": 0.032202959060668945,
        "time_ratio": 1.0406653774144585,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "original_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "llm_output": "-- Reasoning\nTo find the titles of posts edited by a specific user, I need to join the `posts` table with the `users` table.\nThe `posts.LastEditorUserId` column links to `users.Id`.\nI will filter the results based on the `users.DisplayName` being 'Vebjorn Ljosa' and select the `Title` from the `posts` table.\n\n-- SQL Query\nSELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_time": 0.15333247184753418,
        "orig_time": 0.1884777545928955,
        "time_ratio": 1.2292096535188448,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What percentage of cards without power are in French?",
        "original_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power LIKE '%*%'",
        "llm_output": "-- Reasoning\n-- The question asks for the percentage of unique cards that meet two criteria:\n-- 1. They do not have a 'power' value (i.e., power is NULL or an empty string).\n-- 2. They have at least one foreign data entry whose language is 'French'.\n-- The denominator will be the total count of unique cards without power.\n-- The numerator will be the count of unique cards without power that also have a French translation.\n-- A LEFT JOIN with foreign_data is used to include cards that might not have any foreign data, ensuring the denominator is accurate for all cards without power.\n-- COUNT(DISTINCT T1.uuid) in the denominator correctly counts unique cards without power.\n-- COUNT(DISTINCT CASE WHEN T2.language = 'French' THEN T1.uuid ELSE NULL END) correctly counts unique cards without power that have a French translation.\n-- CAST to REAL is necessary for floating-point division, and multiplying by 100 converts the result to a percentage.\n\n-- SQL Query\nSELECT\n  CAST(COUNT(DISTINCT CASE WHEN T2.language = 'French' THEN T1.uuid ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.uuid)\nFROM\n  cards AS T1\nLEFT JOIN\n  foreign_data AS T2\nON\n  T1.uuid = T2.uuid\nWHERE\n  (T1.power IS NULL OR T1.power = '');",
        "pred_query": "SELECT\n  CAST(COUNT(DISTINCT CASE WHEN T2.language = 'French' THEN T1.uuid ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.uuid)\nFROM\n  cards AS T1\nLEFT JOIN\n  foreign_data AS T2\nON\n  T1.uuid = T2.uuid\nWHERE\n  (T1.power IS NULL OR T1.power = '');",
        "pred_time": 0.9934251308441162,
        "orig_time": 0.291823148727417,
        "time_ratio": 0.29375454643416765,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "original_query": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "llm_output": "\nSELECT DISTINCT\n  T1.player_name\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE\n  T2.attacking_work_rate = 'high' OR T2.attacking_work_rate = 'H';\n",
        "pred_query": "SELECT DISTINCT\n  T1.player_name\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE\n  T2.attacking_work_rate = 'high' OR T2.attacking_work_rate = 'H';",
        "pred_time": 0.08457088470458984,
        "orig_time": 0.08730554580688477,
        "time_ratio": 1.0323357277371192,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "llm_output": "-- Reasoning\nI need to find members who attended a specific event.\nI will join the `member` table with the `attendance` table on `member_id` and `link_to_member`.\nThen I will join the result with the `event` table on `link_to_event` and `event_id`.\nFinally, I will filter for `event_name` = 'Laugh Out Loud' and select the `first_name` and `last_name` of the members.\n\n-- SQL Query\nSELECT\n  T1.first_name,\n  T1.last_name\nFROM member AS T1\nINNER JOIN attendance AS T2\n  ON T1.member_id = T2.link_to_member\nINNER JOIN event AS T3\n  ON T2.link_to_event = T3.event_id\nWHERE\n  T3.event_name = 'Laugh Out Loud';",
        "pred_query": "SELECT\n  T1.first_name,\n  T1.last_name\nFROM member AS T1\nINNER JOIN attendance AS T2\n  ON T1.member_id = T2.link_to_member\nINNER JOIN event AS T3\n  ON T2.link_to_event = T3.event_id\nWHERE\n  T3.event_name = 'Laugh Out Loud';",
        "pred_time": 0.0009005069732666016,
        "orig_time": 0.0006284713745117188,
        "time_ratio": 0.6979083929044215,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "llm_output": "-- Reasoning\nTo find the expansion type for the set containing \"Samite Pilgrim\", I need to join the `cards` table with the `sets` table.\nFirst, I will find the `setCode` for \"Samite Pilgrim\" in the `cards` table.\nThen, I will use this `setCode` to look up the `type` in the `sets` table.\n\n-- SQL Query\nSELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'",
        "pred_query": "SELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'",
        "pred_time": 0.06743764877319336,
        "orig_time": 0.059827566146850586,
        "time_ratio": 0.8871537966583467,
        "check": true
    },
    {
        "id": "card_games",
        "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
        "llm_output": "\nSELECT\n  COUNT(id)\nFROM cards\nWHERE\n  colors IS NOT NULL AND colors != '' AND borderColor IS NULL AND edhrecRank > 12000;\n",
        "pred_query": "SELECT\n  COUNT(id)\nFROM cards\nWHERE\n  colors IS NOT NULL AND colors != '' AND borderColor IS NULL AND edhrecRank > 12000;",
        "pred_time": 0.06043243408203125,
        "orig_time": 0.05390334129333496,
        "time_ratio": 0.8919604532256028,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Calculate the average height of all neutral superheroes.",
        "original_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `alignment` table to filter by alignment type.\nThen, I will filter for rows where the alignment is 'Neutral'.\nFinally, I will calculate the average of the `height_cm` column for the filtered superheroes.\n\n-- SQL Query\nSELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_time": 0.0010733604431152344,
        "orig_time": 0.0005614757537841797,
        "time_ratio": 0.5231008440693026,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the date when the youngest user made his or her first post?",
        "original_query": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "llm_output": "-- Reasoning\nFirst, find the minimum age from the `users` table to identify the youngest user(s).\nThen, join `users` with `posts` on `Id` and `OwnerUserId`, filtering for users with that minimum age.\nFinally, select the minimum `CreaionDate` from these filtered posts to get the date of the first post by the youngest user.\n\n-- SQL Query\nSELECT MIN(T2.CreaionDate)\nFROM users AS T1\nINNER JOIN posts AS T2\n  ON T1.Id = T2.OwnerUserId\nWHERE\n  T1.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );",
        "pred_query": "SELECT MIN(T2.CreaionDate)\nFROM users AS T1\nINNER JOIN posts AS T2\n  ON T1.Id = T2.OwnerUserId\nWHERE\n  T1.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );",
        "pred_time": 0.19858026504516602,
        "orig_time": 0.18781208992004395,
        "time_ratio": 0.9457741930061736,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
        "original_query": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "llm_output": "\nSELECT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL\n",
        "pred_query": "SELECT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "pred_time": 0.06316089630126953,
        "orig_time": 0.05484271049499512,
        "time_ratio": 0.8683016503344456,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
        "llm_output": "-- Reasoning\nI need to retrieve patient details (ID, SEX, Diagnosis) from the `Patient` table.\nThe condition on albumin level (ALB < 3.5) is found in the `Laboratory` table.\nTherefore, I must join `Patient` and `Laboratory` tables using their common `ID` column.\nThen, I will filter the joined results based on the `ALB` column.\n\n\nSELECT\n  T1.ID,\n  T1.SEX,\n  T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.ALB < 3.5;\n",
        "pred_query": "SELECT\n  T1.ID,\n  T1.SEX,\n  T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.ALB < 3.5;",
        "pred_time": 0.0042417049407958984,
        "orig_time": 0.003567218780517578,
        "time_ratio": 0.8409870159069193,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Which foot is preferred by Abdou Diallo?",
        "original_query": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "llm_output": "-- Reasoning\nTo find the preferred foot of Abdou Diallo, I need to first locate the player's `player_api_id` in the `Player` table using their `player_name`.\nThen, I will use this `player_api_id` to join with the `Player_Attributes` table and retrieve the `preferred_foot`.\n\n-- SQL Query\nSELECT\n  T2.preferred_foot\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE\n  T1.player_name = 'Abdou Diallo';",
        "pred_query": "SELECT\n  T2.preferred_foot\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE\n  T1.player_name = 'Abdou Diallo';",
        "pred_time": 0.09808063507080078,
        "orig_time": 0.09513735771179199,
        "time_ratio": 0.9699912489668919,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "original_query": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "llm_output": "-- Reasoning\nI need to count the number of 'Discount' gas stations in the Czech Republic (CZE) and Slovakia (SVK) separately from the `gasstations` table.\nThen, I will calculate the difference between these two counts (CZE - SVK) to answer the question.\nThis involves filtering by Segment and Country and then performing aggregation and subtraction.\n\n-- SQL Query\nSELECT\n  SUM(CASE WHEN Country = 'CZE' THEN 1 ELSE 0 END) - SUM(CASE WHEN Country = 'SVK' THEN 1 ELSE 0 END)\nFROM gasstations\nWHERE\n  Segment = 'Discount';",
        "pred_query": "SELECT\n  SUM(CASE WHEN Country = 'CZE' THEN 1 ELSE 0 END) - SUM(CASE WHEN Country = 'SVK' THEN 1 ELSE 0 END)\nFROM gasstations\nWHERE\n  Segment = 'Discount';",
        "pred_time": 0.0013687610626220703,
        "orig_time": 0.0008578300476074219,
        "time_ratio": 0.6267200836091273,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "original_query": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "\nSELECT T2.nationality FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 933 ORDER BY T1.fastestLapSpeed DESC LIMIT 1\n",
        "pred_query": "SELECT T2.nationality FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 933 ORDER BY T1.fastestLapSpeed DESC LIMIT 1",
        "pred_time": 0.003320932388305664,
        "orig_time": 0.002126455307006836,
        "time_ratio": 0.640318759422787,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "llm_output": "-- Reasoning\nI need to select `superhero_name` from the `superhero` table.\nI will join `superhero` with the `colour` table twice: once for `eye_colour_id` and once for `hair_colour_id`.\nThen I will filter the results where the eye colour is 'Blue' and the hair colour is 'Blond'.\n\n-- SQL Query\nSELECT\n  T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2\n  ON T1.eye_colour_id = T2.id\nINNER JOIN colour AS T3\n  ON T1.hair_colour_id = T3.id\nWHERE\n  T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_query": "SELECT\n  T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2\n  ON T1.eye_colour_id = T2.id\nINNER JOIN colour AS T3\n  ON T1.hair_colour_id = T3.id\nWHERE\n  T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_time": 0.0011622905731201172,
        "orig_time": 0.0006914138793945312,
        "time_ratio": 0.5948717948717949,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What is the highest amount of budget spend for an event?",
        "original_query": "SELECT MAX(spent) FROM budget",
        "llm_output": "-- Reasoning\nThe question asks for the highest amount of budget spend for an event.\nThis information is directly available in the 'budget' table under the 'amount' column.\nI need to find the maximum value of the 'amount' column in the 'budget' table.\n\n-- SQL Query\nSELECT MAX(amount) FROM budget;",
        "pred_query": "SELECT MAX(amount) FROM budget;",
        "pred_time": 0.0007724761962890625,
        "orig_time": 0.00048613548278808594,
        "time_ratio": 0.629320987654321,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the owner's display name of the most popular post?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "llm_output": "-- Reasoning\nTo find the owner's display name of the most popular post, we need to identify which column in the `posts` table best represents \"popularity\". `FavoriteCount` is a strong indicator of a post's popularity. We will order the posts by `FavoriteCount` in descending order and select the `OwnerDisplayName` of the top post.\n\n-- SQL Query\nSELECT OwnerDisplayName FROM posts ORDER BY FavoriteCount DESC LIMIT 1;",
        "pred_query": "SELECT OwnerDisplayName FROM posts ORDER BY FavoriteCount DESC LIMIT 1;",
        "pred_time": 0.10611534118652344,
        "orig_time": 0.11034131050109863,
        "time_ratio": 1.0398243012492137,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "original_query": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to first identify patients who had lab work done within the specified date range from the `Laboratory` table.\nThen, I will join these patient IDs with the `Examination` table to get their diagnoses.\nFinally, I will count the occurrences of each diagnosis and find the one with the highest count.\n\nite\nSELECT T2.Diagnosis\nFROM Laboratory AS T1\nINNER JOIN Examination AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.Date BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY\n  T2.Diagnosis\nORDER BY\n  COUNT(T2.Diagnosis) DESC\nLIMIT 1;\n",
        "pred_query": "SELECT T2.Diagnosis\nFROM Laboratory AS T1\nINNER JOIN Examination AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.Date BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY\n  T2.Diagnosis\nORDER BY\n  COUNT(T2.Diagnosis) DESC\nLIMIT 1;",
        "pred_time": 0.0014300346374511719,
        "orig_time": 0.0006949901580810547,
        "time_ratio": 0.48599533177725907,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "original_query": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find posts created in the year 2010.\nFrom these posts, I will identify the one with the highest 'Score' to determine the \"most valuable\" post.\nFinally, I will retrieve its 'Id' from the `posts` table and the `DisplayName` of its owner from the `users` table by joining `posts` and `users` on `OwnerUserId`.\n\n-- SQL Query\nSELECT\n  T1.Id,\n  T2.DisplayName\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  STRFTIME('%Y', T1.CreaionDate) = '2010'\nORDER BY\n  T1.Score DESC\nLIMIT 1;",
        "pred_query": "SELECT\n  T1.Id,\n  T2.DisplayName\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  STRFTIME('%Y', T1.CreaionDate) = '2010'\nORDER BY\n  T1.Score DESC\nLIMIT 1;",
        "pred_time": 0.12791991233825684,
        "orig_time": 0.2660074234008789,
        "time_ratio": 2.079484097030017,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "llm_output": "-- Reasoning\nTo find the names of cards in the set \"Hauptset Zehnte Edition\", I need to first identify the `setCode` for this translated set name.\nThis requires joining the `set_translations` table with the `sets` table to link the translation to the actual set code.\nOnce the `setCode` is identified, I can query the `cards` table, filtering by this `setCode`, and select the `name` of each card.\n\n\nSELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'\n",
        "pred_query": "select the `name` of each card.\n\n\nSELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "pred_time": null,
        "orig_time": 0.0946810245513916,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What is the carcinogenic label for bond TR001_2_4?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
        "llm_output": "-- Reasoning\nThe question asks for the \"carcinogenic label\" of a specific bond.\nThe `molecule` table contains a `label` column which likely represents the carcinogenic label for a molecule.\nThe `bond` table links bonds to molecules via `molecule_id`.\nTherefore, to find the label for a bond, we need to join `bond` with `molecule` on `molecule_id` and filter by the given `bond_id`.\n\n-- SQL Query\nSELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_query": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_time": 0.0010018348693847656,
        "orig_time": 0.0014884471893310547,
        "time_ratio": 1.4857210851975249,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "original_query": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "llm_output": "\nSELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.`date`, 1, 10) = '2015-09-10';\n",
        "pred_query": "SELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.`date`, 1, 10) = '2015-09-10';",
        "pred_time": 0.0019485950469970703,
        "orig_time": 0.001508474349975586,
        "time_ratio": 0.7741343447938334,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many positive comments are there on the list?",
        "original_query": "SELECT COUNT(id) FROM comments WHERE score > 60",
        "llm_output": "-- Reasoning\nTo find the number of \"positive comments\", we need to count comments that have a positive score.\nThe `comments` table contains a `Score` column.\nWe will filter the `comments` table for rows where `Score` is greater than 0 and then count these rows.\n\n-- SQL Query\nSELECT COUNT(Id) FROM comments WHERE Score > 0;",
        "pred_query": "SELECT COUNT(Id) FROM comments WHERE Score > 0;",
        "pred_time": 0.04604077339172363,
        "orig_time": 0.04219675064086914,
        "time_ratio": 0.9165082932437121,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 10?",
        "original_query": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 10 AND T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nI need to find sets that have an Italian translation. This requires joining `sets` with `set_translations` on `code` and `setCode`.\nThen, I will filter these results to include only those sets where the `language` is 'Italian'.\nFinally, from this filtered set of Italian-translated sets, I will count how many have a `baseSetSize` less than 10.\n\nSELECT COUNT(T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_query": "SELECT COUNT(T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_time": 0.0018515586853027344,
        "orig_time": 0.0010256767272949219,
        "time_ratio": 0.5539531290239506,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were adult?",
        "original_query": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "llm_output": "-- Reasoning\nThe question asks for the count of users who are adults.\nThe `users` table contains an `Age` column.\nAn adult is generally defined as someone with an age of 18 or greater.\nI need to count the distinct users where their age is 18 or above.\n\n-- SQL Query\nSELECT COUNT(Id) FROM users WHERE Age >= 18;",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Age >= 18;",
        "pred_time": 0.010665416717529297,
        "orig_time": 0.009167909622192383,
        "time_ratio": 0.8595922564492332,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "original_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the card names, I need to join the `cards` and `sets` tables.\nFilter by `sets.name` for 'Coldsnap'.\nThen, order the results by `cards.convertedManaCost` in descending order.\nFinally, limit to 1 to get the card with the highest converted mana cost.\n\nSELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1;",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1;",
        "pred_time": 0.06745362281799316,
        "orig_time": 0.0661003589630127,
        "time_ratio": 0.979937862512857,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "original_query": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "llm_output": "\nSELECT FirstName, District\nFROM (\n    SELECT AdmFName1 AS FirstName, District FROM schools WHERE AdmFName1 IS NOT NULL\n    UNION ALL\n    SELECT AdmFName2 AS FirstName, District FROM schools WHERE AdmFName2 IS NOT NULL\n    UNION ALL\n    SELECT AdmFName3 AS FirstName, District FROM schools WHERE AdmFName3 IS NOT NULL\n) AS AllAdministrators\nGROUP BY FirstName, District\nORDER BY COUNT(*) DESC\nLIMIT 2;\n",
        "pred_query": "SELECT FirstName, District\nFROM (\n    SELECT AdmFName1 AS FirstName, District FROM schools WHERE AdmFName1 IS NOT NULL\n    UNION ALL\n    SELECT AdmFName2 AS FirstName, District FROM schools WHERE AdmFName2 IS NOT NULL\n    UNION ALL\n    SELECT AdmFName3 AS FirstName, District FROM schools WHERE AdmFName3 IS NOT NULL\n) AS AllAdministrators\nGROUP BY FirstName, District\nORDER BY COUNT(*) DESC\nLIMIT 2;",
        "pred_time": 0.03159475326538086,
        "orig_time": 0.028929948806762695,
        "time_ratio": 0.9156567409710379,
        "check": false
    },
    {
        "id": "financial",
        "question": "List the top ten districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "original_query": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 10",
        "llm_output": "-- Reasoning\nTo find the number of female account holders per district, we need to join `client`, `disp`, and `account` tables.\nWe filter for female clients, then group by `district_id` from the `account` table, counting the distinct `client_id`s.\nFinally, order the results in descending order of the count and limit to the top 10.\n\n-- SQL Query\nSELECT T3.district_id\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nINNER JOIN account AS T3\n  ON T2.account_id = T3.account_id\nWHERE\n  T1.gender = 'F'\nGROUP BY\n  T3.district_id\nORDER BY\n  COUNT(DISTINCT T1.client_id) DESC\nLIMIT 10;",
        "pred_query": "SELECT T3.district_id\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nINNER JOIN account AS T3\n  ON T2.account_id = T3.account_id\nWHERE\n  T1.gender = 'F'\nGROUP BY\n  T3.district_id\nORDER BY\n  COUNT(DISTINCT T1.client_id) DESC\nLIMIT 10;",
        "pred_time": 0.003568410873413086,
        "orig_time": 0.0025451183319091797,
        "time_ratio": 0.7132357853945347,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01'",
        "llm_output": "-- Reasoning\nI need to count distinct patients who satisfy two conditions: their IGA level is within the normal range (80 to 500, based on the few-shot example) and their 'First Date' in the Patient table is after '1990-01-01'.\nI will join the `Patient` and `Laboratory` tables on `ID`.\nThen I will apply the filters and count the distinct `ID`s.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01';",
        "pred_time": 0.004899263381958008,
        "orig_time": 0.004214286804199219,
        "time_ratio": 0.8601878436906906,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "original_query": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "llm_output": "\nSELECT\n  COUNT(T1.raceId)\nFROM races AS T1\nINNER JOIN circuits AS T2\n  ON T1.circuitId = T2.circuitId\nWHERE\n  T1.year = 2010 AND T2.country NOT IN (\n    'Austria',\n    'Azerbaijan',\n    'Belgium',\n    'France',\n    'Germany',\n    'Hungary',\n    'Italy',\n    'Monaco',\n    'Netherlands',\n    'Portugal',\n    'Russia',\n    'Spain',\n    'Turkey',\n    'United Kingdom',\n    'Bahrain',\n    'China',\n    'Japan',\n    'Malaysia',\n    'Qatar',\n    'Saudi Arabia',\n    'Singapore',\n    'United Arab Emirates'\n  );\n",
        "pred_query": "SELECT\n  COUNT(T1.raceId)\nFROM races AS T1\nINNER JOIN circuits AS T2\n  ON T1.circuitId = T2.circuitId\nWHERE\n  T1.year = 2010 AND T2.country NOT IN (\n    'Austria',\n    'Azerbaijan',\n    'Belgium',\n    'France',\n    'Germany',\n    'Hungary',\n    'Italy',\n    'Monaco',\n    'Netherlands',\n    'Portugal',\n    'Russia',\n    'Spain',\n    'Turkey',\n    'United Kingdom',\n    'Bahrain',\n    'China',\n    'Japan',\n    'Malaysia',\n    'Qatar',\n    'Saudi Arabia',\n    'Singapore',\n    'United Arab Emirates'\n  );",
        "pred_time": 0.0014209747314453125,
        "orig_time": 0.0006868839263916016,
        "time_ratio": 0.48338926174496644,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "original_query": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "llm_output": "-- Reasoning\nI need to join the `drivers` table with the `lapTimes` table to link drivers to their lap times.\nThen, I will filter drivers by 'Spanish' nationality and a birth year before 1982.\nFor each qualifying driver, I will find their latest (maximum) lap time using the `milliseconds` column.\nFinally, I will order the results by this latest lap time in descending order and limit to the top 10 drivers.\n\n-- SQL Query\nSELECT\n  T1.driverId\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'Spanish' AND STRFTIME('%Y', T1.dob) < '1982'\nGROUP BY\n  T1.driverId\nORDER BY\n  MAX(T2.milliseconds) DESC\nLIMIT 10;",
        "pred_query": "SELECT\n  T1.driverId\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'Spanish' AND STRFTIME('%Y', T1.dob) < '1982'\nGROUP BY\n  T1.driverId\nORDER BY\n  MAX(T2.milliseconds) DESC\nLIMIT 10;",
        "pred_time": 0.05048847198486328,
        "orig_time": 0.001605987548828125,
        "time_ratio": 0.03180899491887195,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "llm_output": "-- Reasoning\nTo find the description of the ruling for a card, I need to join the `cards` table with the `rulings` table.\nThe common column for joining these tables is `uuid`.\nI will filter the `cards` table by the `name` 'Condemn' and then select the `text` column from the `rulings` table.\n\n-- SQL Query\nSELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn';",
        "pred_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn';",
        "pred_time": 0.16635608673095703,
        "orig_time": 0.1646437644958496,
        "time_ratio": 0.9897068855804675,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Which customer paid the most in 2012/8/25?",
        "original_query": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the customer with the highest total `Price` from the `transactions_1k` table.\nI will filter transactions for the specific date '2012-08-25'.\nThen, I will sum the `Price` for each `CustomerID` and order the results to find the customer who paid the most.\n\n-- SQL Query\nSELECT CustomerID\nFROM transactions_1k\nWHERE Date = '2012-08-25'\nGROUP BY CustomerID\nORDER BY SUM(Price) DESC\nLIMIT 1;",
        "pred_query": "SELECT CustomerID\nFROM transactions_1k\nWHERE Date = '2012-08-25'\nGROUP BY CustomerID\nORDER BY SUM(Price) DESC\nLIMIT 1;",
        "pred_time": 0.0011234283447265625,
        "orig_time": 0.0007240772247314453,
        "time_ratio": 0.6445246179966044,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with severe thrombosis have a normal prothrombin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.PT < 14 AND T3.Thrombosis < 3 AND T3.Thrombosis > 0",
        "llm_output": "-- Reasoning\nThe question requires counting distinct patients who satisfy two conditions: having \"severe thrombosis\" and a \"normal prothrombin time\".\n1.  \"Severe thrombosis\" is found in the `Examination` table under the `Thrombosis` column. Assuming an integer scale where higher numbers indicate more severity and given \"mild thrombosis = 3\" in the example, \"severe thrombosis\" is assumed to be `Thrombosis = 4`.\n2.  \"Normal prothrombin time\" is found in the `Laboratory` table under the `PT` column. As `PT` is a REAL type and no specific range for \"normal\" is provided, we assume a common clinical normal range for PT, which is `PT BETWEEN 10 AND 14`.\n3.  We need to join `Patient`, `Examination`, and `Laboratory` tables using their common `ID` column to link patient information across these tables and apply the filters.\n4.  Finally, we count the distinct `ID`s from the `Patient` table that meet both criteria.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T3.Thrombosis = 4 AND T2.PT BETWEEN 10 AND 14;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T3.Thrombosis = 4 AND T2.PT BETWEEN 10 AND 14;",
        "pred_time": 0.001344442367553711,
        "orig_time": 0.0009105205535888672,
        "time_ratio": 0.6772477389608087,
        "check": false
    },
    {
        "id": "student_club",
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "original_query": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "llm_output": "-- Reasoning\nI need to retrieve the `last_name` from the `member` table.\nThe major information is in the `major` table, linked by `link_to_major` in `member` and `major_id` in `major`.\nI will join `member` and `major` tables and filter by `major_name` = 'Law and Constitutional Studies'.\n\n-- SQL Query\nSELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';",
        "pred_query": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';",
        "pred_time": 0.0010204315185546875,
        "orig_time": 0.0005021095275878906,
        "time_ratio": 0.49205607476635516,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the average loan amount by male borrowers?",
        "original_query": "SELECT AVG(T3.amount) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M'",
        "llm_output": "-- Reasoning\nTo find the average loan amount for male borrowers, I need to join `loan` with `disp` (to link loans to client dispositions) and `client` (to filter by gender).\nThe `loan` table contains the `amount` of the loan.\nThe `client` table contains the `gender` of the client.\nThe `disp` table links `account_id` to `client_id`.\nI will filter for 'M' gender and then calculate the average of the loan amount.\n\n-- SQL Query\nSELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.gender = 'M';",
        "pred_query": "SELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.gender = 'M';",
        "pred_time": 0.002238750457763672,
        "orig_time": 0.0049037933349609375,
        "time_ratio": 2.1904153354632587,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "List out of players whose preferred foot is left.",
        "original_query": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "llm_output": "-- Reasoning\nTo find players whose preferred foot is left, I will query the `Player_Attributes` table.\nI need to filter the `preferred_foot` column for the value 'left'.\nI will select the `player_api_id` to identify the players.\nSince a player can have multiple attribute records, I will use `DISTINCT` to get unique player IDs.\n\n-- SQL Query\nSELECT DISTINCT player_api_id FROM Player_Attributes WHERE preferred_foot = 'left';",
        "pred_query": "SELECT DISTINCT player_api_id FROM Player_Attributes WHERE preferred_foot = 'left';",
        "pred_time": 0.08329296112060547,
        "orig_time": 0.09297895431518555,
        "time_ratio": 1.1162882561055198,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many white bordered cards are powerful?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "llm_output": "-- Reasoning\nThe question asks for the count of \"white bordered cards\" that are \"powerful\".\nI need to filter the `cards` table for `borderColor = 'white'`.\nFor \"powerful\", I will consider cards that have a specific power value, meaning `power` is not NULL and does not contain the '*' character, which typically denotes variable or unknown power.\n\n-- SQL Query\nSELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND power IS NOT NULL AND power NOT LIKE '%*%';",
        "pred_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND power IS NOT NULL AND power NOT LIKE '%*%';",
        "pred_time": 0.062166452407836914,
        "orig_time": 0.05416607856750488,
        "time_ratio": 0.8713072158622409,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
        "original_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
        "llm_output": "-- Reasoning\nI need to find members based on their zip code, city, and state.\nI will join the `member` table with the `zip_code` table using the `zip` and `zip_code` columns, respectively.\nThen, I will filter the results by `city = 'Lincolnton'`, `short_state = 'NC'`, and `zip_code = 28092`.\nFinally, I will select the `first_name`, `last_name`, and `position` from the `member` table.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.short_state = 'NC' AND T2.zip_code = 28092;",
        "pred_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.short_state = 'NC' AND T2.zip_code = 28092;",
        "pred_time": 0.00101470947265625,
        "orig_time": 0.0004909038543701172,
        "time_ratio": 0.4837875939849624,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Give the eye colour of Blackwulf.",
        "original_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf'",
        "llm_output": "-- Reasoning\nTo find the eye colour of 'Blackwulf', I need to select the `colour` from the `colour` table.\nI will join the `superhero` table with the `colour` table using the `eye_colour_id`.\nFinally, I will filter the results where the `superhero_name` is 'Blackwulf'.\n\n-- SQL Query\nSELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_time": 0.0010864734649658203,
        "orig_time": 0.0005190372467041016,
        "time_ratio": 0.47772657450076805,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal anti-SSA came to the hospital before 1990?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '1990'",
        "llm_output": "-- Reasoning\nI need to count distinct patients.\nThe conditions are: anti-SSA is 'normal' (from the Laboratory table) AND the patient's first visit (`First Date`) is before 1990 (from the Patient table).\nI will join Patient and Laboratory tables on ID.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA = 'normal' AND T1.`First Date` < '1990-01-01';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA = 'normal' AND T1.`First Date` < '1990-01-01';",
        "pred_time": 0.005513668060302734,
        "orig_time": 0.004738569259643555,
        "time_ratio": 0.8594222952520972,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "State the racing year which has the fastest lap time?",
        "original_query": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "llm_output": "\nSELECT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1\n",
        "pred_query": "SELECT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "pred_time": 0.004797697067260742,
        "orig_time": 0.006081819534301758,
        "time_ratio": 1.2676539283407047,
        "check": false
    },
    {
        "id": "superhero",
        "question": "How many green-skinned villains are there in the superhero universe?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "llm_output": "-- Reasoning\nI need to join `superhero` with `colour` to filter by skin colour 'Green'.\nI also need to join `superhero` with `alignment` to filter by alignment 'Bad'.\nFinally, I will count the distinct `superhero.id` that satisfy both conditions.\n\n-- SQL Query\nSELECT\n  COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN colour AS T2\n  ON T1.skin_colour_id = T2.id\nINNER JOIN alignment AS T3\n  ON T1.alignment_id = T3.id\nWHERE\n  T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_query": "SELECT\n  COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN colour AS T2\n  ON T1.skin_colour_id = T2.id\nINNER JOIN alignment AS T3\n  ON T1.alignment_id = T3.id\nWHERE\n  T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_time": 0.0012784004211425781,
        "orig_time": 0.0005853176116943359,
        "time_ratio": 0.4578515479298769,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "original_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
        "llm_output": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "pred_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "pred_time": 0.06505060195922852,
        "orig_time": 0.061849355697631836,
        "time_ratio": 0.95078836835971,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "original_query": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "llm_output": "SELECT event_name FROM event WHERE status = 'closed' AND event_name = 'game' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_query": "SELECT event_name FROM event WHERE status = 'closed' AND event_name = 'game' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_time": 0.0007338523864746094,
        "orig_time": 0.0004687309265136719,
        "time_ratio": 0.6387264457439896,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List down top 5 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "original_query": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 5",
        "llm_output": "-- Reasoning\nI need to join the `drivers` table with the `pitStops` table.\nFilter drivers by `nationality` as 'German' and their birth year (`dob`) between 1980 and 1985.\nCalculate the average `milliseconds` from the `pitStops` table for each driver.\nOrder the results by this average duration in ascending order and limit to the top 5.\n\n-- SQL Query\nSELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds)\nLIMIT 5;",
        "pred_query": "SELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds)\nLIMIT 5;",
        "pred_time": 0.001981019973754883,
        "orig_time": 0.0017189979553222656,
        "time_ratio": 0.8677337826453243,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "original_query": "SELECT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "llm_output": "-- Reasoning\nThe question asks for the currency used by a customer based on a specific date and time of a transaction.\nI need to join the `transactions_1k` table with the `customers` table using `CustomerID`.\nThen, I will filter the `transactions_1k` table by the given `Date` ('2012-08-24') and `Time` ('16:25:00').\nFinally, I will select the `Currency` from the `customers` table.\n\n-- SQL Query\nSELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00';",
        "pred_query": "SELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00';",
        "pred_time": 0.0012235641479492188,
        "orig_time": 0.0006430149078369141,
        "time_ratio": 0.5255261106780982,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Count the fastest superheroes.",
        "original_query": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' ORDER BY T1.attribute_value DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the fastest superheroes, we first need to identify the attribute corresponding to 'Speed' and its maximum value among all heroes.\nThen, we count all superheroes who possess this maximum 'Speed' attribute value.\nThis involves joining `hero_attribute` with `attribute` to filter by attribute name and find the maximum value, then using a subquery to count heroes matching that maximum.\n\n-- SQL Query\nSELECT COUNT(T1.hero_id)\nFROM hero_attribute AS T1\nINNER JOIN attribute AS T2\n  ON T1.attribute_id = T2.id\nWHERE T2.attribute_name = 'Speed' AND T1.attribute_value = (\n  SELECT MAX(T3.attribute_value)\n  FROM hero_attribute AS T3\n  INNER JOIN attribute AS T4\n    ON T3.attribute_id = T4.id\n  WHERE T4.attribute_name = 'Speed'\n);",
        "pred_query": "SELECT COUNT(T1.hero_id)\nFROM hero_attribute AS T1\nINNER JOIN attribute AS T2\n  ON T1.attribute_id = T2.id\nWHERE T2.attribute_name = 'Speed' AND T1.attribute_value = (\n  SELECT MAX(T3.attribute_value)\n  FROM hero_attribute AS T3\n  INNER JOIN attribute AS T4\n    ON T3.attribute_id = T4.id\n  WHERE T4.attribute_name = 'Speed'\n);",
        "pred_time": 0.0027570724487304688,
        "orig_time": 0.0008680820465087891,
        "time_ratio": 0.31485645105499827,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "original_query": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "llm_output": "-- Reasoning\nThe query needs to retrieve cards worked on by 'Allen Williams' from the `cards` table, specifically their `frameVersion` and `name`.\nTo identify if any of these cards are banned, we need to check the `legalities` table where `status` is 'Banned'.\nA `CASE` statement combined with an `EXISTS` subquery is used to efficiently determine the ban status for each card, joining `cards` and `legalities` on `uuid`.\n\n-- SQL Query\nSELECT\n  T1.frameVersion,\n  T1.name,\n  CASE\n    WHEN EXISTS (\n      SELECT\n        1\n      FROM legalities AS T2\n      WHERE\n        T2.uuid = T1.uuid AND T2.status = 'Banned'\n    )\n    THEN 'Banned'\n    ELSE NULL\n  END AS banned_status\nFROM cards AS T1\nWHERE\n  T1.artist = 'Allen Williams';",
        "pred_query": "SELECT\n  T1.frameVersion,\n  T1.name,\n  CASE\n    WHEN EXISTS (\n      SELECT\n        1\n      FROM legalities AS T2\n      WHERE\n        T2.uuid = T1.uuid AND T2.status = 'Banned'\n    )\n    THEN 'Banned'\n    ELSE NULL\n  END AS banned_status\nFROM cards AS T1\nWHERE\n  T1.artist = 'Allen Williams';",
        "pred_time": 5.563481569290161,
        "orig_time": 0.318096399307251,
        "time_ratio": 0.05717578019186942,
        "check": false
    },
    {
        "id": "student_club",
        "question": "State the name of major that Phillip Cullen has joined.",
        "original_query": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "llm_output": "-- Reasoning\nTo find the major name of 'Phillip Cullen', I need to join the `member` table with the `major` table.\nThe `member` table contains the `first_name`, `last_name`, and `link_to_major`.\nThe `major` table contains the `major_id` and `major_name`.\nI will join `member.link_to_major` with `major.major_id` and filter by the member's name.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_time": 0.0010297298431396484,
        "orig_time": 0.00057220458984375,
        "time_ratio": 0.5556841861542023,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
        "original_query": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
        "llm_output": "-- Reasoning\nThe question asks for the number of committed crimes in 1995 for a specific district.\nFirst, I need to find the district_id associated with account_id 532 from the 'account' table.\nThen, I will use this district_id to query the 'district' table and retrieve the value from the 'A16' column, which represents the number of committed crimes in 1995.\n\n-- SQL Query\nSELECT T1.A16 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532;",
        "pred_query": "SELECT T1.A16 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532;",
        "pred_time": 0.0010395050048828125,
        "orig_time": 0.0004868507385253906,
        "time_ratio": 0.468348623853211,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "llm_output": "-- Reasoning\nThe question asks for patient ID, sex, and birthday for patients with LDH values \"beyond normal range\".\nThe `Patient` table contains `ID`, `SEX`, and `Birthday`.\nThe `Laboratory` table contains `ID` and `LDH` values.\nA join between `Patient` and `Laboratory` on `ID` is necessary to combine this information.\nThe specific \"normal range\" for LDH is not provided in the schema or question. However, the few-shot example uses `LDH > 600 AND LDH < 800` to identify values that are \"100-300 index above the normal range\". This implies that values greater than 600 are considered significantly elevated or \"beyond normal range\". Therefore, a reasonable interpretation for \"beyond normal range\" in this context is to filter for `LDH > 600`. Using `DISTINCT` is appropriate in case a patient has multiple laboratory records.\n\n-- SQL Query\n\nSELECT DISTINCT\n  T1.ID,\n  T1.SEX,\n  T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.LDH > 600;\n",
        "pred_query": "SELECT DISTINCT\n  T1.ID,\n  T1.SEX,\n  T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.LDH > 600;",
        "pred_time": 0.005209207534790039,
        "orig_time": 0.0038237571716308594,
        "time_ratio": 0.7340381710833448,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "original_query": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "llm_output": "-- Reasoning\nTo find bond IDs that share the same 'atom_id2' as 'TR000_2', I first need to determine the 'atom_id2' associated with 'TR000_2' from the 'connected' table. Then, I will select all 'bond_id's from the 'connected' table where their 'atom_id2' matches the one found in the first step.\n\n-- SQL Query\nSELECT T1.bond_id FROM connected AS T1 WHERE T1.atom_id2 = (SELECT T2.atom_id2 FROM connected AS T2 WHERE T2.bond_id = 'TR000_2');",
        "pred_query": "SELECT T1.bond_id FROM connected AS T1 WHERE T1.atom_id2 = (SELECT T2.atom_id2 FROM connected AS T2 WHERE T2.bond_id = 'TR000_2');",
        "pred_time": 0.004584789276123047,
        "orig_time": 0.0023682117462158203,
        "time_ratio": 0.5165366614664587,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "original_query": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the `frpm` table with the `schools` table using their common `CDSCode`.\nThen, I will filter the results from the `schools` table to find entries where any of the administrator's first names (`AdmFName1`, `AdmFName2`, `AdmFName3`) is 'Alusine'.\nFinally, I will select the `Percent (%) Eligible Free (K-12)` and `District Code` from the `frpm` table for the matching schools.\n\n-- SQL Query\nSELECT T1.`Percent (%) Eligible Free (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine' OR T2.AdmFName2 = 'Alusine' OR T2.AdmFName3 = 'Alusine';",
        "pred_query": "SELECT T1.`Percent (%) Eligible Free (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine' OR T2.AdmFName2 = 'Alusine' OR T2.AdmFName3 = 'Alusine';",
        "pred_time": 0.015909671783447266,
        "orig_time": 0.007871866226196289,
        "time_ratio": 0.49478495429342123,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "original_query": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "llm_output": "-- Reasoning\nTo find information about races at Silverstone Circuit, I need to join the `races` table with the `circuits` table.\nThe join condition will be `races.circuitId = circuits.circuitId`.\nThen, I will filter the results where `circuits.name` is 'Silverstone Circuit'.\nFinally, I will select all columns from the `races` table to provide \"more information\".\n\n-- SQL Query\nSELECT T1.* FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Silverstone Circuit';",
        "pred_query": "SELECT T1.* FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Silverstone Circuit';",
        "pred_time": 0.0012276172637939453,
        "orig_time": 0.0008244514465332031,
        "time_ratio": 0.6715867158671587,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Give the only one comment text of the post with parent id 107829.",
        "original_query": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "llm_output": "-- Reasoning\nI need to find the `PostId` from the `posts` table where the `ParentId` is 107829.\nThen, I will use this `PostId` to query the `comments` table and retrieve the `Text` column.\n\n-- SQL Query\nSELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ParentId = 107829;",
        "pred_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ParentId = 107829;",
        "pred_time": 0.21713829040527344,
        "orig_time": 0.22257232666015625,
        "time_ratio": 1.025025693279341,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
        "original_query": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
        "llm_output": "-- Reasoning\nTo find the Italian name of the set, I need to:\n1. Find the `setCode` from the `cards` table for the card named 'Ancestor''s Chosen'.\n2. Use this `setCode` to join with the `set_translations` table.\n3. Filter `set_translations` for `language` = 'Italian' and select the `translation`.\n\n-- SQL Query\nSELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';",
        "pred_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';",
        "pred_time": 0.06547307968139648,
        "orig_time": 0.06006622314453125,
        "time_ratio": 0.9174186312423984,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many translations of the name of the set \"Salvat 2011\"?",
        "original_query": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Salvat 2011' AND T2.translation IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to find the `code` for the set named 'Salvat 2011' from the `sets` table.\nThen, I will use this `setCode` to query the `set_translations` table.\nFinally, I will count the distinct `translation` entries associated with that `setCode`.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.translation) FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Salvat 2011';",
        "pred_query": "SELECT COUNT(DISTINCT T1.translation) FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Salvat 2011';",
        "pred_time": 0.011723518371582031,
        "orig_time": 0.0040514469146728516,
        "time_ratio": 0.34558285202961037,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "original_query": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
        "llm_output": "\nSELECT COUNT(T1.member_id)\nFROM member AS T1\nINNER JOIN attendance AS T2\n  ON T1.member_id = T2.link_to_member\nINNER JOIN event AS T3\n  ON T2.link_to_event = T3.event_id\nWHERE\n  T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';\n",
        "pred_query": "SELECT COUNT(T1.member_id)\nFROM member AS T1\nINNER JOIN attendance AS T2\n  ON T1.member_id = T2.link_to_member\nINNER JOIN event AS T3\n  ON T2.link_to_event = T3.event_id\nWHERE\n  T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';",
        "pred_time": 0.0012331008911132812,
        "orig_time": 0.0005979537963867188,
        "time_ratio": 0.48491879350348027,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "original_query": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "llm_output": "-- Reasoning\nThe query needs to find the average number of crimes (`A16` in the `district` table) for districts that meet two conditions:\n1. The number of crimes in that district (`A16`) exceeds 4000.\n2. The district has accounts that were opened in the year 1997 or later.\n\nFirst, identify districts where `A16 > 4000`.\nSecond, identify districts from the `account` table where the `date` of opening is '1997' or later using `strftime('%Y', account.date) >= '1997'`.\nFinally, join these two conditions to select the relevant districts and calculate the average of their `A16` values.\n\n-- SQL Query\nSELECT AVG(T1.A16)\nFROM district AS T1\nWHERE T1.A16 > 4000\n  AND T1.district_id IN (\n    SELECT T2.district_id\n    FROM account AS T2\n    WHERE strftime('%Y', T2.date) >= '1997'\n  );",
        "pred_query": "SELECT AVG(T1.A16)\nFROM district AS T1\nWHERE T1.A16 > 4000\n  AND T1.district_id IN (\n    SELECT T2.district_id\n    FROM account AS T2\n    WHERE strftime('%Y', T2.date) >= '1997'\n  );",
        "pred_time": 0.0024924278259277344,
        "orig_time": 0.0018050670623779297,
        "time_ratio": 0.7242203941075187,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "original_query": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "llm_output": "-- Reasoning\nI need to retrieve the 'NCESSchool' from the `schools` table and 'Enrollment (Ages 5-17)' from the `frpm` table.\nThese two tables can be joined using the `CDSCode` column.\nI will order the results by 'Enrollment (Ages 5-17)' in descending order to find the highest enrollments.\nFinally, I will limit the output to the top 5 schools.\n\n-- SQL Query\nSELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_query": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_time": 0.016928911209106445,
        "orig_time": 0.012912988662719727,
        "time_ratio": 0.7627772692063939,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level?",
        "original_query": "SELECT T2.ANA FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 ORDER BY T2.ANA DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe question asks for the highest `ANA` (anti-nucleus antibody concentration) from the `Examination` table.\nThe condition is that the patient must have a \"normal creatinine level\".\nCreatinine level (`CRE`) is found in the `Laboratory` table.\nSince no specific numerical range for \"normal creatinine level\" is provided in the schema or question, and `CRE` is a `REAL` type, the most reasonable interpretation is to consider records where `CRE` is not null.\nJoin `Examination` and `Laboratory` tables on `ID` to link patient data.\nFilter the joined results where `Laboratory.CRE` is not null and then find the maximum `ANA`.\n\n-- SQL Query\nSELECT\n  MAX(T1.ANA)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.CRE IS NOT NULL;",
        "pred_query": "SELECT\n  MAX(T1.ANA)\nFROM Examination AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.CRE IS NOT NULL;",
        "pred_time": 0.0019752979278564453,
        "orig_time": 0.0015358924865722656,
        "time_ratio": 0.7775497887748943,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many male patients have elevated total bilirubin count?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "llm_output": "-- Reasoning\nI need to count patients who are male and have a 'T-BIL' value considered 'elevated'.\nBased on the few-shot example, 'T-BIL >= 2.0' implies an elevated or abnormal range.\nI will join Patient and Laboratory tables on ID, filter for male patients, filter for T-BIL >= 2.0, and then count distinct patient IDs.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` >= 2.0;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` >= 2.0;",
        "pred_time": 0.002583742141723633,
        "orig_time": 0.0015494823455810547,
        "time_ratio": 0.59970471532712,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "original_query": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "llm_output": "\nSELECT COUNT(DISTINCT player_api_id)\nFROM Player_Attributes\nWHERE preferred_foot = 'left' AND attacking_work_rate = 'ormal';\n",
        "pred_query": "SELECT COUNT(DISTINCT player_api_id)\nFROM Player_Attributes\nWHERE preferred_foot = 'left' AND attacking_work_rate = 'ormal';",
        "pred_time": 0.0651400089263916,
        "orig_time": 0.061789512634277344,
        "time_ratio": 0.9485646939978113,
        "check": false
    },
    {
        "id": "card_games",
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "original_query": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "llm_output": "\nSELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy';\n",
        "pred_query": "SELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy';",
        "pred_time": 0.06651115417480469,
        "orig_time": 0.058785200119018555,
        "time_ratio": 0.8838397235525222,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which SME customer consumed the least in June 2012?",
        "original_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `customers` table with the `yearmonth` table.\nFilter `customers` for Segment = 'SME' and `yearmonth` for dates in June 2012 ('2012-06').\nOrder the results by consumption in ascending order to find the least.\nLimit the result to 1 to get the single customer ID.\n\n-- SQL Query\nSELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date = '2012-06' ORDER BY T2.Consumption ASC LIMIT 1;",
        "pred_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date = '2012-06' ORDER BY T2.Consumption ASC LIMIT 1;",
        "pred_time": 0.00805211067199707,
        "orig_time": 0.021637916564941406,
        "time_ratio": 2.687235365528677,
        "check": false
    },
    {
        "id": "financial",
        "question": "What is the region of the client with the id 3541 from?",
        "original_query": "SELECT T2.district_id, T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
        "llm_output": "-- Reasoning\nTo find the region of the client with id 3541, I need to join the `client` table with the `district` table.\nThe `client` table has `client_id` and `district_id`.\nThe `district` table has `district_id` and the region information in the `A3` column.\nI will join these two tables on `district_id` and filter by `client_id` = 3541 to retrieve the `A3` column.\n\n-- SQL Query\nSELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541;",
        "pred_query": "SELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541;",
        "pred_time": 0.000946044921875,
        "orig_time": 0.0006864070892333984,
        "time_ratio": 0.725554435483871,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the score and the link type ID for post ID 395?",
        "original_query": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395",
        "llm_output": "\nSELECT\n  T1.Score,\n  T2.LinkTypeId\nFROM posts AS T1\nINNER JOIN postLinks AS T2\n  ON T1.Id = T2.PostId\nWHERE\n  T1.Id = 395;\n",
        "pred_query": "SELECT\n  T1.Score,\n  T2.LinkTypeId\nFROM posts AS T1\nINNER JOIN postLinks AS T2\n  ON T1.Id = T2.PostId\nWHERE\n  T1.Id = 395;",
        "pred_time": 0.0021820068359375,
        "orig_time": 0.0012233257293701172,
        "time_ratio": 0.5606424825174825,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many French constructors have a lap number of over 50?",
        "original_query": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "llm_output": "-- Reasoning\nI need to find constructors with 'French' nationality.\nThen, I need to link these constructors to races where a lap number (from `lapTimes`) is greater than 50.\nThe `lapTimes` table has `raceId` and `driverId`. The `results` table links `raceId`, `driverId`, and `constructorId`.\nI will join `constructors`, `results`, and `lapTimes` and then filter for French nationality and lap numbers greater than 50, finally counting distinct constructor names.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.name)\nFROM constructors AS T1\nINNER JOIN results AS T2\n  ON T1.constructorId = T2.constructorId\nINNER JOIN lapTimes AS T3\n  ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId\nWHERE\n  T1.nationality = 'French' AND T3.lap > 50;",
        "pred_query": "SELECT COUNT(DISTINCT T1.name)\nFROM constructors AS T1\nINNER JOIN results AS T2\n  ON T1.constructorId = T2.constructorId\nINNER JOIN lapTimes AS T3\n  ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId\nWHERE\n  T1.nationality = 'French' AND T3.lap > 50;",
        "pred_time": 0.009650230407714844,
        "orig_time": 0.004552602767944336,
        "time_ratio": 0.47176104358138155,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "original_query": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA > 6.5 AND T1.SEX = 'F') OR (T2.UA > 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "llm_output": "-- Reasoning\nI need to first find the latest laboratory examination date for each patient.\nThen, I will join this information back to the Laboratory table to retrieve the full latest record for each patient.\nFrom these latest records, I will filter for patients whose UA index is within the normal range (assuming UA <= 6.5 based on the example).\nFinally, I will calculate the average UA index for these filtered patients.\n\n-- SQL Query\nSELECT AVG(T1.UA)\nFROM Laboratory AS T1\nINNER JOIN (\n    SELECT ID, MAX(Date) AS LatestDate\n    FROM Laboratory\n    GROUP BY ID\n) AS T2\nON T1.ID = T2.ID AND T1.Date = T2.LatestDate\nWHERE T1.UA <= 6.5;",
        "pred_query": "SELECT AVG(T1.UA)\nFROM Laboratory AS T1\nINNER JOIN (\n    SELECT ID, MAX(Date) AS LatestDate\n    FROM Laboratory\n    GROUP BY ID\n) AS T2\nON T1.ID = T2.ID AND T1.Date = T2.LatestDate\nWHERE T1.UA <= 6.5;",
        "pred_time": 0.0047223567962646484,
        "orig_time": 0.004691123962402344,
        "time_ratio": 0.9933861766042308,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "original_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "llm_output": "\nSELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';\n",
        "pred_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_time": 0.0013935565948486328,
        "orig_time": 0.000682830810546875,
        "time_ratio": 0.4899914456800684,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the molecule id of bond id TR001_1_7?",
        "original_query": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "llm_output": "-- Reasoning\nThe question asks for the `molecule_id` given a specific `bond_id`.\nThe `bond` table contains both `bond_id` and `molecule_id`.\nTherefore, I need to query the `bond` table and filter by the given `bond_id`.\n\n-- SQL Query\nSELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';",
        "pred_query": "SELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';",
        "pred_time": 0.000949859619140625,
        "orig_time": 0.0024666786193847656,
        "time_ratio": 2.5968875502008033,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "original_query": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "llm_output": "-- Reasoning\nI need to find the overall rating for 'Landon Donovan' and 'Jordan Bowery' from the Player_Attributes table, joined with the Player table to get player names.\nI will filter the results by the specified date '2013-07-12'.\nThen, I will calculate the percentage difference between Landon Donovan's rating and Jordan Bowery's rating using the formula: ((Donovan_rating - Bowery_rating) / Bowery_rating) * 100.\n\n-- SQL Query\nSELECT\n  CAST((\n    (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Landon Donovan' AND T2.date = '2013-07-12') -\n    (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Jordan Bowery' AND T2.date = '2013-07-12')\n  ) AS REAL) * 100 /\n  (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Jordan Bowery' AND T2.date = '2013-07-12');",
        "pred_query": "SELECT\n  CAST((\n    (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Landon Donovan' AND T2.date = '2013-07-12') -\n    (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Jordan Bowery' AND T2.date = '2013-07-12')\n  ) AS REAL) * 100 /\n  (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Jordan Bowery' AND T2.date = '2013-07-12');",
        "pred_time": 0.18236732482910156,
        "orig_time": 0.06719493865966797,
        "time_ratio": 0.3684593099264744,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "original_query": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe query needs to find the patient with the highest hemoglobin count (HGB) from the `Laboratory` table.\nThen, it calculates the patient's age *at the time of that specific examination* using the `Laboratory.Date` and `Patient.Birthday`.\nFinally, it retrieves the doctor's diagnosis for that event. The `Examination` table contains a `Diagnosis` field and `Examination Date`. We'll link `Laboratory` to `Examination` using both `ID` and the respective date fields. A `LEFT JOIN` is used for `Examination` in case there isn't an exact examination record matching the lab date. `LIMIT 1` ensures a single result even if multiple patients or dates share the maximum HGB.\n\n-- SQL Query\nSELECT\n  STRFTIME('%Y', T1.Date) - STRFTIME('%Y', T2.Birthday),\n  T3.Diagnosis\nFROM Laboratory AS T1\nINNER JOIN Patient AS T2\n  ON T1.ID = T2.ID\nLEFT JOIN Examination AS T3\n  ON T1.ID = T3.ID AND T1.Date = T3.`Examination Date`\nWHERE\n  T1.HGB = (\n    SELECT\n      MAX(HGB)\n    FROM Laboratory\n  )\nORDER BY\n  T1.Date DESC,\n  T1.ID DESC\nLIMIT 1;",
        "pred_query": "SELECT\n  STRFTIME('%Y', T1.Date) - STRFTIME('%Y', T2.Birthday),\n  T3.Diagnosis\nFROM Laboratory AS T1\nINNER JOIN Patient AS T2\n  ON T1.ID = T2.ID\nLEFT JOIN Examination AS T3\n  ON T1.ID = T3.ID AND T1.Date = T3.`Examination Date`\nWHERE\n  T1.HGB = (\n    SELECT\n      MAX(HGB)\n    FROM Laboratory\n  )\nORDER BY\n  T1.Date DESC,\n  T1.ID DESC\nLIMIT 1;",
        "pred_time": 0.007365226745605469,
        "orig_time": 0.004537105560302734,
        "time_ratio": 0.6160170918037032,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "original_query": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to first identify the `raceId` for the '2011 Australian Grand Prix' from the `races` table.\nThen, I will join this `raceId` with the `pitStops` table to get all pit stops for that specific race.\nFinally, I will join with the `drivers` table to get the driver's name and sum the `milliseconds` column for each driver from the `pitStops` table.\n\nite\nSELECT\n  T3.forename,\n  T3.surname,\n  SUM(T1.milliseconds)\nFROM pitStops AS T1\nINNER JOIN races AS T2\n  ON T1.raceId = T2.raceId\nINNER JOIN drivers AS T3\n  ON T1.driverId = T3.driverId\nWHERE\n  T2.name = 'Australian Grand Prix' AND T2.year = 2011\nGROUP BY\n  T3.driverId;\n",
        "pred_query": "SELECT\n  T3.forename,\n  T3.surname,\n  SUM(T1.milliseconds)\nFROM pitStops AS T1\nINNER JOIN races AS T2\n  ON T1.raceId = T2.raceId\nINNER JOIN drivers AS T3\n  ON T1.driverId = T3.driverId\nWHERE\n  T2.name = 'Australian Grand Prix' AND T2.year = 2011\nGROUP BY\n  T3.driverId;",
        "pred_time": 0.0022764205932617188,
        "orig_time": 0.0009057521820068359,
        "time_ratio": 0.3978843736908253,
        "check": false
    },
    {
        "id": "financial",
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "original_query": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "llm_output": "-- Reasoning\nTo calculate the percentage, we need two counts: the number of accounts from 'Decin' opened in 1993, and the total number of accounts opened in 1993.\nWe will join the `account` and `district` tables on `district_id`.\nThen, we filter for accounts opened in the year 1993 using `STRFTIME('%Y', date)`.\nFinally, we use conditional aggregation to count accounts from 'Decin' and divide it by the total count of accounts from 1993, multiplied by 100 for the percentage.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993';",
        "pred_query": "SELECT CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993';",
        "pred_time": 0.002566099166870117,
        "orig_time": 0.0020999908447265625,
        "time_ratio": 0.8183591935334015,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Please list the product description of the products consumed in September, 2013.",
        "original_query": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "llm_output": "-- Reasoning\nThe question asks for product descriptions based on consumption in a specific month and year.\nI need to query the `transactions_1k` table to filter by date (September 2013) and then join with the `products` table on `ProductID` to retrieve the `Description`.\nFinally, I should select distinct product descriptions to avoid duplicates.\n\n-- SQL Query\nSELECT DISTINCT\n  T2.Description\nFROM transactions_1k AS T1\nINNER JOIN products AS T2\n  ON T1.ProductID = T2.ProductID\nWHERE\n  STRFTIME('%Y-%m', T1.Date) = '2013-09';",
        "pred_query": "SELECT DISTINCT\n  T2.Description\nFROM transactions_1k AS T1\nINNER JOIN products AS T2\n  ON T1.ProductID = T2.ProductID\nWHERE\n  STRFTIME('%Y-%m', T1.Date) = '2013-09';",
        "pred_time": 0.001544952392578125,
        "orig_time": 0.002315998077392578,
        "time_ratio": 1.499074074074074,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the elements for bond id TR001_10_11?",
        "original_query": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
        "llm_output": "-- Reasoning\nThe question asks for the elements of the atoms connected by a specific bond.\nFirst, I need to find the atoms (`atom_id` and `atom_id2`) linked by the given `bond_id` in the `connected` table.\nThen, I will join with the `atom` table twice to retrieve the `element` for both `atom_id` and `atom_id2`.\nFinally, I will use `UNION` to combine the elements and `DISTINCT` to ensure uniqueness.\n\n-- SQL Query\nSELECT T3.element FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T1.atom_id = T3.atom_id WHERE T1.bond_id = 'TR001_10_11' UNION SELECT T3.element FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T1.atom_id2 = T3.atom_id WHERE T1.bond_id = 'TR001_10_11';",
        "pred_query": "SELECT T3.element FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T1.atom_id = T3.atom_id WHERE T1.bond_id = 'TR001_10_11' UNION SELECT T3.element FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T1.atom_id2 = T3.atom_id WHERE T1.bond_id = 'TR001_10_11';",
        "pred_time": 0.004557371139526367,
        "orig_time": 0.0025610923767089844,
        "time_ratio": 0.561967041590374,
        "check": true
    },
    {
        "id": "card_games",
        "question": "List the edhrecRank for cards with frame version 2015.",
        "original_query": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "llm_output": "-- Reasoning\nThe question asks for the `edhrecRank` of cards with a specific `frameVersion`.\nBoth `edhrecRank` and `frameVersion` columns are available in the `cards` table.\nTherefore, I will query the `cards` table, select `edhrecRank`, and filter by `frameVersion = '2015'`.\n\n-- SQL Query\nSELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_query": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "original_query": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "llm_output": "-- Reasoning\nI need to count players from the `Player` table.\nThe conditions are that their birth year must be after 1990, extracted from the `birthday` column.\nAdditionally, their `player_name` must start with 'Aaron '.\n\nSELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990' AND player_name LIKE 'Aaron %';",
        "pred_query": "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990' AND player_name LIKE 'Aaron %';",
        "pred_time": 0.007421970367431641,
        "orig_time": 0.003753662109375,
        "time_ratio": 0.5057500803083842,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "original_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
        "llm_output": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;",
        "pred_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;",
        "pred_time": 0.0035791397094726562,
        "orig_time": 0.0025424957275390625,
        "time_ratio": 0.7103650413002931,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which college do most of the members go to?",
        "original_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to count members for each college.\nFirst, join the `member` table with the `major` table on `link_to_major` and `major_id`.\nThen, group the results by the `college` column and count the members in each group.\nFinally, order the results by the count in descending order and take the top one.\n\n-- SQL Query\nSELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_time": 0.000751495361328125,
        "orig_time": 0.0004885196685791016,
        "time_ratio": 0.6500634517766497,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were from New York?",
        "original_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "llm_output": "-- Reasoning\nThe question asks for the count of users from a specific location.\nThe `users` table contains both the user `Id` and their `Location`.\nI can filter the `users` table by `Location = 'New York'` and then count the resulting rows.\n\n-- SQL Query\nSELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_time": 0.01240396499633789,
        "orig_time": 0.012187957763671875,
        "time_ratio": 0.9825856302617921,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which country is the Belgium Jupiler League from?",
        "original_query": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "llm_output": "-- Reasoning\nTo find the country of the 'Belgium Jupiler League', I need to query the `League` table for the given league name.\nThen, I will join the `League` table with the `Country` table on `country_id` to retrieve the country name.\nThe result should be the `name` column from the `Country` table.\n\n-- SQL Query\nSELECT T2.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League';",
        "pred_query": "SELECT T2.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League';",
        "pred_time": 0.0009217262268066406,
        "orig_time": 0.0005974769592285156,
        "time_ratio": 0.6482152095188826,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "original_query": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "llm_output": "-- Reasoning\nThe query needs to identify patients born in 1982 from the `Patient` table.\nThen, it needs to retrieve their albumin levels (`ALB`) from the `Laboratory` table.\nFinally, for each relevant albumin measurement, it determines if the value falls within the normal range (3.5 to 5.5) and states the outcome.\n\n-- SQL Query\nSELECT\n  T1.ID,\n  CASE WHEN T2.ALB BETWEEN 3.5 AND 5.5 THEN 'Normal' ELSE 'Not Normal' END AS Albumin_Status\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  strftime('%Y', T1.Birthday) = '1982';",
        "pred_query": "SELECT\n  T1.ID,\n  CASE WHEN T2.ALB BETWEEN 3.5 AND 5.5 THEN 'Normal' ELSE 'Not Normal' END AS Albumin_Status\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  strftime('%Y', T1.Birthday) = '1982';",
        "pred_time": 0.0074596405029296875,
        "orig_time": 0.007053852081298828,
        "time_ratio": 0.9456021477882894,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "original_query": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nI need to find sets with Italian translations from `set_translations`.\nThen, I will join with the `sets` table to get the set name.\nFinally, I will join with the `cards` table to count the number of cards for each of these sets and group by set name.\n\nSELECT\n  T1.name,\n  COUNT(T2.id)\nFROM sets AS T1\nINNER JOIN cards AS T2\n  ON T1.code = T2.setCode\nINNER JOIN set_translations AS T3\n  ON T1.code = T3.setCode\nWHERE\n  T3.language = 'Italian'\nGROUP BY\n  T1.name;",
        "pred_query": "SELECT\n  T1.name,\n  COUNT(T2.id)\nFROM sets AS T1\nINNER JOIN cards AS T2\n  ON T1.code = T2.setCode\nINNER JOIN set_translations AS T3\n  ON T1.code = T3.setCode\nWHERE\n  T3.language = 'Italian'\nGROUP BY\n  T1.name;",
        "pred_time": 0.07723307609558105,
        "orig_time": 0.0039060115814208984,
        "time_ratio": 0.05057433652632131,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many clients who choose statement of weekly issuance are User?",
        "original_query": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'USER'",
        "llm_output": "\nSELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'WEEKLY' AND T2.type = 'OWNER';\n",
        "pred_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'WEEKLY' AND T2.type = 'OWNER';",
        "pred_time": 0.0021250247955322266,
        "orig_time": 0.0008585453033447266,
        "time_ratio": 0.40401660495904856,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "original_query": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "llm_output": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre';",
        "pred_query": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre';",
        "pred_time": 0.06956672668457031,
        "orig_time": 0.0676429271697998,
        "time_ratio": 0.9723459819592576,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients whose C-reactive protein level is abnormal, how many of them aren't 18 yet?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP != '-' AND T2.CRP != '+-') AND T2.CRP >= 1.0 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < '18'",
        "llm_output": "-- Reasoning\nThe query needs to count unique patients who satisfy two conditions: their C-reactive protein (CRP) level is abnormal, and they are not yet 18 years old.\n1.  **Abnormal CRP**: Based on the provided example `(T2.CRP = '-' OR T2.CRP = '+-' OR T2.CRP < 1.0)` representing a normal CRP, an abnormal CRP would be the negation: `NOT (T2.CRP = '-' OR T2.CRP = '+-' OR CAST(T2.CRP AS REAL) < 1.0)`. `CAST(T2.CRP AS REAL)` is used to handle potential numeric comparisons for the `TEXT` CRP column.\n2.  **Not yet 18 years old**: This implies checking the patient's age as of the current date (`'now'`) against their `Birthday`. The age calculation `STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday) - (STRFTIME('%m%d', 'now') < STRFTIME('%m%d', T1.Birthday))` accurately determines age in full years. We filter for `age < 18`.\n3.  **Joining and Counting**: Join `Patient` and `Laboratory` tables on `ID`. Apply both conditions in the `WHERE` clause. Since a patient can have multiple laboratory records, `COUNT(DISTINCT T1.ID)` is used to count each patient only once.\n\n-- SQL Query\nSELECT\n  COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  NOT (T2.CRP = '-' OR T2.CRP = '+-' OR CAST(T2.CRP AS REAL) < 1.0) AND (\n    STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday) - (STRFTIME('%m%d', 'now') < STRFTIME('%m%d', T1.Birthday))\n  ) < 18;",
        "pred_query": "SELECT\n  COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  NOT (T2.CRP = '-' OR T2.CRP = '+-' OR CAST(T2.CRP AS REAL) < 1.0) AND (\n    STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday) - (STRFTIME('%m%d', 'now') < STRFTIME('%m%d', T1.Birthday))\n  ) < 18;",
        "pred_time": 0.0015170574188232422,
        "orig_time": 0.010842323303222656,
        "time_ratio": 7.146943265755147,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "original_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the `cards` table with the `set_translations` table.\nFirst, I will find the `setCode` for the set \"Hauptset Zehnte Edition\" from `set_translations`.\nThen, I will filter the `cards` table by this `setCode` and by the `artist` \"Adam Rex\".\nFinally, I will count the number of matching cards.\n\nSELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_time": 0.06406617164611816,
        "orig_time": 0.05658292770385742,
        "time_ratio": 0.8831950817414863,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patient who first came to the hospital on 1991/6/13 who was diagnosed with SJS, what is the total number of his/her Laboratory tests in 1995?",
        "original_query": "SELECT COUNT(*) FROM Laboratory WHERE ID = ( SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS' ) AND STRFTIME('%Y', Date) = '1995'",
        "llm_output": "-- Reasoning\nThe query needs to identify a patient based on two conditions: their `First Date` and `Diagnosis`.\nOnce the patient's ID is found, it will be used to filter the `Laboratory` table.\nFinally, we count the number of laboratory tests for that patient that occurred in the year 1995.\nThe `STRFTIME` function will be used to extract the year from the `Date` column in the `Laboratory` table.\n\n-- SQL Query\nSELECT COUNT(T1.ID)\nFROM Laboratory AS T1\nINNER JOIN Patient AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.`First Date` = '1991-06-13' AND T2.Diagnosis = 'SJS' AND STRFTIME('%Y', T1.Date) = '1995';",
        "pred_query": "SELECT COUNT(T1.ID)\nFROM Laboratory AS T1\nINNER JOIN Patient AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.`First Date` = '1991-06-13' AND T2.Diagnosis = 'SJS' AND STRFTIME('%Y', T1.Date) = '1995';",
        "pred_time": 0.0013339519500732422,
        "orig_time": 0.0006823539733886719,
        "time_ratio": 0.5115281501340483,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "original_query": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the user who acquired the first 'Autobiographer' badge, I need to filter the 'badges' table for badges named 'Autobiographer'.\nThen, I will order these badges by their 'Date' in ascending order to identify the earliest one.\nFinally, I will join with the 'users' table using 'UserId' to retrieve the 'DisplayName' of that specific user.\n\n-- SQL Query\nSELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Autobiographer' ORDER BY T2.Date ASC LIMIT 1;",
        "pred_query": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Autobiographer' ORDER BY T2.Date ASC LIMIT 1;",
        "pred_time": 0.01747918128967285,
        "orig_time": 0.015407562255859375,
        "time_ratio": 0.8814807742146686,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Identify the total number of posts with views above average.",
        "original_query": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "llm_output": "-- Reasoning\nFirst, calculate the average ViewCount across all posts in the 'posts' table.\nThen, count the number of posts whose ViewCount is greater than this calculated average.\nThis involves a subquery to compute the average.\n\n-- SQL Query\nSELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_query": "SELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_time": 0.215118408203125,
        "orig_time": 0.2159116268157959,
        "time_ratio": 1.0036873581359058,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "llm_output": "-- Reasoning\nThe query needs to find cards that are of type 'Artifact', have 'Black' in their color identity, and also have a corresponding entry in the 'foreign_data' table, indicating a foreign language translation.\nWe will join the 'cards' table with the 'foreign_data' table using the 'uuid' column.\nThen, we'll filter the results based on the 'type' and 'colors' columns in the 'cards' table.\nWe will select distinct card names to avoid duplicates if a card has multiple foreign translations.\n\n-- SQL Query\nSELECT DISTINCT T1.name\nFROM cards AS T1\nINNER JOIN foreign_data AS T2\n  ON T1.uuid = T2.uuid\nWHERE\n  T1.type LIKE '%Artifact%' AND T1.colors LIKE '%Black%';",
        "pred_query": "SELECT DISTINCT T1.name\nFROM cards AS T1\nINNER JOIN foreign_data AS T2\n  ON T1.uuid = T2.uuid\nWHERE\n  T1.type LIKE '%Artifact%' AND T1.colors LIKE '%Black%';",
        "pred_time": 0.3085973262786865,
        "orig_time": 0.287243127822876,
        "time_ratio": 0.9308023866787294,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "original_query": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "llm_output": "-- Reasoning\nI need to join the `Patient`, `Examination`, and `Laboratory` tables on their common `ID` column.\nThen, I will apply the date range filter on `Examination.Examination Date`.\nAdditionally, I will filter the results based on `Laboratory.GPT` and `Laboratory.ALB` levels.\nFinally, I will select the distinct patient IDs that satisfy all conditions.\n\n-- SQL Query\nSELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T2.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T3.GPT > 30 AND T3.ALB < 4;",
        "pred_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T2.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T3.GPT > 30 AND T3.ALB < 4;",
        "pred_time": 0.008924007415771484,
        "orig_time": 0.006652355194091797,
        "time_ratio": 0.7454448303499867,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the labels for TR000, TR001 and TR002?",
        "original_query": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
        "llm_output": "-- Reasoning\nThe question asks for the labels of specific molecules.\nThe `molecule` table contains `molecule_id` and `label`.\nWe need to select the `label` column from the `molecule` table and filter by the given `molecule_id` values.\n\n-- SQL Query\nSELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_query": "SELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_time": 0.0008378028869628906,
        "orig_time": 0.0004642009735107422,
        "time_ratio": 0.5540694365395561,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin?",
        "original_query": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "llm_output": "-- Reasoning\nI need to query the `schools` table to find schools that meet the specified criteria.\nThe conditions are: `MailState` is 'CA', `County` is 'San Joaquin', and `StatusType` is 'Active'.\nI will count the distinct `CDSCode` to get the number of schools.\n\n-- SQL Query\nSELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin' AND StatusType = 'Active';",
        "pred_query": "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin' AND StatusType = 'Active';",
        "pred_time": 0.009881973266601562,
        "orig_time": 0.008355855941772461,
        "time_ratio": 0.8455655278903687,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "original_query": "SELECT CAST(SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTRING(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "llm_output": "-- Reasoning\nFirst, find the CustomerID from `transactions_1k` based on the given date and price.\nThen, calculate the total consumption for this customer for the year 2012 and 2013 from the `yearmonth` table.\nFinally, compute the decrease rate using the formula: ((Consumption_2012 - Consumption_2013) / Consumption_2012).\n\n-- SQL Query\nSELECT\n  (T2.Consumption_2012 - T3.Consumption_2013) * 1.0 / T2.Consumption_2012\nFROM transactions_1k AS T1\nJOIN (\n  SELECT\n    CustomerID,\n    SUM(Consumption) AS Consumption_2012\n  FROM yearmonth\n  WHERE\n    STRFTIME('%Y', Date) = '2012'\n  GROUP BY\n    CustomerID\n) AS T2\n  ON T1.CustomerID = T2.CustomerID\nJOIN (\n  SELECT\n    CustomerID,\n    SUM(Consumption) AS Consumption_2013\n  FROM yearmonth\n  WHERE\n    STRFTIME('%Y', Date) = '2013'\n  GROUP BY\n    CustomerID\n) AS T3\n  ON T1.CustomerID = T3.CustomerID\nWHERE\n  T1.Date = '2012-08-25' AND T1.Price = 634.8;",
        "pred_query": "SELECT\n  (T2.Consumption_2012 - T3.Consumption_2013) * 1.0 / T2.Consumption_2012\nFROM transactions_1k AS T1\nJOIN (\n  SELECT\n    CustomerID,\n    SUM(Consumption) AS Consumption_2012\n  FROM yearmonth\n  WHERE\n    STRFTIME('%Y', Date) = '2012'\n  GROUP BY\n    CustomerID\n) AS T2\n  ON T1.CustomerID = T2.CustomerID\nJOIN (\n  SELECT\n    CustomerID,\n    SUM(Consumption) AS Consumption_2013\n  FROM yearmonth\n  WHERE\n    STRFTIME('%Y', Date) = '2013'\n  GROUP BY\n    CustomerID\n) AS T3\n  ON T1.CustomerID = T3.CustomerID\nWHERE\n  T1.Date = '2012-08-25' AND T1.Price = 634.8;",
        "pred_time": 0.10260510444641113,
        "orig_time": 0.021874427795410156,
        "time_ratio": 0.2131904442125956,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Identify the heaviest superhero in DC Comics.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the 'superhero' table with the 'publisher' table to filter for 'DC Comics'.\nThen, I will order the results by 'weight_kg' in descending order to find the heaviest superhero.\nFinally, I will select the 'superhero_name' and limit the result to 1.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1;",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1;",
        "pred_time": 0.0010254383087158203,
        "orig_time": 0.0008306503295898438,
        "time_ratio": 0.8100441757730761,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Please list the diseases of the patients born after 1995-1-1 and have a normal Rhuematoid Factor.",
        "original_query": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > 1995-01-01",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the `Patient` table with the `Laboratory` table using the `ID` column.\nI will filter the patients based on their `Birthday` being after '1995-01-01'.\nI will also filter the `Laboratory` records where `RA` (Rhuematoid Factor) is normal, which is typically represented by '-'.\nFinally, I will select the distinct `Diagnosis` from the `Patient` table.\n\n-- SQL Query\nSELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday > '1995-01-01' AND T2.RA = '-';",
        "pred_query": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday > '1995-01-01' AND T2.RA = '-';",
        "pred_time": 0.004812717437744141,
        "orig_time": 0.005418062210083008,
        "time_ratio": 1.1257802437332805,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the name of user with the ID of 30?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = 30",
        "llm_output": "-- Reasoning\nTo find the name of the user with ID 30, I need to query the `users` table.\nI will select the `DisplayName` column and filter the results using a `WHERE` clause where `Id` is equal to 30.\n\n-- SQL Query\nSELECT DisplayName FROM users WHERE Id = 30;",
        "pred_query": "SELECT DisplayName FROM users WHERE Id = 30;",
        "pred_time": 0.0008592605590820312,
        "orig_time": 0.0005695819854736328,
        "time_ratio": 0.6628745837957825,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "original_query": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "llm_output": "\nSELECT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Sepang International Circuit'\n",
        "pred_query": "SELECT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the names of the races held on the circuits in Spain.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "llm_output": "-- Reasoning\nTo find the names of races held in Spain, I need to join the `races` table with the `circuits` table.\nThen, I will filter the results where the `country` in the `circuits` table is 'Spain'.\nFinally, I will select the `name` from the `races` table.\n\n-- SQL Query\nSELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain';",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain';",
        "pred_time": 0.0013267993927001953,
        "orig_time": 0.0008080005645751953,
        "time_ratio": 0.6089847259658581,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
        "original_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
        "llm_output": "-- Reasoning\nI need to find atoms that belong to molecules labeled as carcinogenic ('+').\nAdditionally, these atoms must be oxygen atoms ('O').\nI will join the `molecule` table with the `atom` table, filter by molecule label and atom element, and then select the atom IDs.\n\n-- SQL Query\nSELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'O';",
        "pred_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'O';",
        "pred_time": 0.001856088638305664,
        "orig_time": 0.0015716552734375,
        "time_ratio": 0.8467565831727681,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "llm_output": "\nSELECT\n  COUNT(DISTINCT T1.account_id)\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3\n  ON T1.account_id = T3.account_id\nWHERE\n  T2.A3 = 'Prague';\n",
        "pred_query": "SELECT\n  COUNT(DISTINCT T1.account_id)\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3\n  ON T1.account_id = T3.account_id\nWHERE\n  T2.A3 = 'Prague';",
        "pred_time": 0.0011281967163085938,
        "orig_time": 0.0008001327514648438,
        "time_ratio": 0.7092138630600169,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Is molecule TR124 carcinogenic?",
        "original_query": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
        "llm_output": "-- Reasoning\nThe question asks for the carcinogenic status of a specific molecule.\nThe `molecule` table contains `molecule_id` and a `label` column, which likely indicates this status.\nI need to select the `label` from the `molecule` table where the `molecule_id` is 'TR124'.\n\n-- SQL Query\nSELECT label FROM molecule WHERE molecule_id = 'TR124';",
        "pred_query": "SELECT label FROM molecule WHERE molecule_id = 'TR124';",
        "pred_time": 0.0007252693176269531,
        "orig_time": 0.0004761219024658203,
        "time_ratio": 0.6564760026298487,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the anti Cardiolipin antibody concentration of the female patient with the highest uric acid level in the normal range?",
        "original_query": "SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T1.SEX = 'F' AND T2.UA > 6.5 ORDER BY T2.UA DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe query first identifies female patients (`SEX = 'F'`) whose uric acid (UA) levels are within the normal range (`UA <= 6.5`, inferred from the provided example where `UA > 6.5` is considered beyond normal).\nIt then finds the maximum UA level for each of these female patients using a subquery with `GROUP BY T1.ID`.\nFinally, it selects the patient ID corresponding to the single highest UA level among these filtered patients using `ORDER BY MaxUAForPatient DESC LIMIT 1`.\nThe outer query then retrieves the `aCL IgG` and `aCL IgM` concentrations from the `Examination` table for this specific patient ID.\n\n-- SQL Query\nSELECT T3.\"aCL IgG\", T3.\"aCL IgM\"\nFROM Examination AS T3\nWHERE T3.ID = (\n    SELECT ID\n    FROM (\n        SELECT T1.ID, MAX(T2.UA) AS MaxUAForPatient\n        FROM Patient AS T1\n        INNER JOIN Laboratory AS T2\n            ON T1.ID = T2.ID\n        WHERE T1.SEX = 'F' AND T2.UA <= 6.5\n        GROUP BY T1.ID\n    ) AS MaxUAFilteredPatients\n    ORDER BY MaxUAForPatient DESC\n    LIMIT 1\n);",
        "pred_query": "SELECT T3.\"aCL IgG\", T3.\"aCL IgM\"\nFROM Examination AS T3\nWHERE T3.ID = (\n    SELECT ID\n    FROM (\n        SELECT T1.ID, MAX(T2.UA) AS MaxUAForPatient\n        FROM Patient AS T1\n        INNER JOIN Laboratory AS T2\n            ON T1.ID = T2.ID\n        WHERE T1.SEX = 'F' AND T2.UA <= 6.5\n        GROUP BY T1.ID\n    ) AS MaxUAFilteredPatients\n    ORDER BY MaxUAForPatient DESC\n    LIMIT 1\n);",
        "pred_time": 0.0074727535247802734,
        "orig_time": 0.0017235279083251953,
        "time_ratio": 0.23064161056695276,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Calculate the ratio of votes in 2010 and 2011.",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
        "llm_output": "-- Reasoning\nI need to count the number of votes for the year 2010 and the number of votes for the year 2011 from the 'votes' table.\nThen, I will divide the count of 2010 votes by the count of 2011 votes to get the ratio.\nThe `STRFTIME('%Y', CreationDate)` function will be used to extract the year from the `CreationDate` column.\nCasting to REAL ensures floating-point division.\n\n-- SQL Query\nSELECT\n  CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) /\n  SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END)\nFROM votes;",
        "pred_query": "SELECT\n  CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) /\n  SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END)\nFROM votes;",
        "pred_time": 0.021130800247192383,
        "orig_time": 0.019336462020874023,
        "time_ratio": 0.9150842275101829,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Calculate the difference in view count from post posted by mornington and view count from posts posted by Amos.",
        "original_query": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "llm_output": "-- Reasoning\nI need to find the total view count for posts made by the user 'mornington' and the total view count for posts made by the user 'Amos'.\nI will join the `users` table with the `posts` table on `users.Id = posts.OwnerUserId`.\nThen, I will filter for each user by `DisplayName` and sum their `ViewCount` from the `posts` table.\nFinally, I will subtract the total view count of 'Amos''s posts from 'mornington''s posts.\n\n-- SQL Query\nSELECT\n  (\n    SELECT\n      SUM(T2.ViewCount)\n    FROM users AS T1\n    INNER JOIN posts AS T2\n      ON T1.Id = T2.OwnerUserId\n    WHERE\n      T1.DisplayName = 'mornington'\n  ) - (\n    SELECT\n      SUM(T2.ViewCount)\n    FROM users AS T1\n    INNER JOIN posts AS T2\n      ON T1.Id = T2.OwnerUserId\n    WHERE\n      T1.DisplayName = 'Amos'\n  );",
        "pred_query": "SELECT\n  (\n    SELECT\n      SUM(T2.ViewCount)\n    FROM users AS T1\n    INNER JOIN posts AS T2\n      ON T1.Id = T2.OwnerUserId\n    WHERE\n      T1.DisplayName = 'mornington'\n  ) - (\n    SELECT\n      SUM(T2.ViewCount)\n    FROM users AS T1\n    INNER JOIN posts AS T2\n      ON T1.Id = T2.OwnerUserId\n    WHERE\n      T1.DisplayName = 'Amos'\n  );",
        "pred_time": 0.4326171875,
        "orig_time": 0.5467569828033447,
        "time_ratio": 1.2638355539291761,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "original_query": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to first find the `PostId` from the `posts` table where the `CreaionDate` matches the given timestamp.\nThen, I will use this `PostId` to filter the `comments` table and retrieve the `Score` for those comments.\nThe date format needs to be consistent with SQLite's DATETIME format (YYYY-MM-DD HH:MM:SS).\n\n-- SQL Query\nSELECT T2.Score FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.CreaionDate = '2010-07-19 19:19:56';",
        "pred_query": "SELECT T2.Score FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.CreaionDate = '2010-07-19 19:19:56';",
        "pred_time": 0.20506525039672852,
        "orig_time": 0.05174994468688965,
        "time_ratio": 0.25235843023999366,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "original_query": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "llm_output": "-- Reasoning\nI need to count the distinct values in the 'type' column from the 'cards' table.\nThe results should be filtered to only include cards where the 'artist' is 'Aaron Boyd'.\n\n-- SQL Query\nSELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "pred_query": "SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "pred_time": 0.06652688980102539,
        "orig_time": 0.05588030815124512,
        "time_ratio": 0.8399657389422077,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "original_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find transactions that occurred on '2012-08-25'.\nThen, I need to order these transactions by time to identify the very first one.\nFinally, I will join with the gasstations table to retrieve the country of that gas station.\n\n-- SQL Query\nSELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time LIMIT 1;",
        "pred_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time LIMIT 1;",
        "pred_time": 0.0009903907775878906,
        "orig_time": 0.0006558895111083984,
        "time_ratio": 0.6622532498796341,
        "check": true
    },
    {
        "id": "student_club",
        "question": "When did the member, Casey Mason, received the income?",
        "original_query": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "llm_output": "-- Reasoning\nI need to find the `date_received` from the `income` table.\nThe `income` table is linked to the `member` table via `link_to_member` and `member_id`.\nI will join `income` and `member` tables.\nThen, I will filter by the `first_name` and `last_name` of the member to 'Casey Mason'.\nFinally, I will select the `date_received` column.\n\n-- SQL Query\nSELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_query": "SELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_time": 0.0010762214660644531,
        "orig_time": 0.0005707740783691406,
        "time_ratio": 0.5303500221533008,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "llm_output": "-- Reasoning\nThe query needs to identify patients born in 1937 whose total cholesterol (`T-CHO`) readings fall outside the normal range.\nA common normal range for total cholesterol is between 120 and 200 (mg/dL). Therefore, \"beyond the normal range\" implies `T-CHO < 120` or `T-CHO > 200`.\nWe will join the `Patient` table with the `Laboratory` table on `ID`, filter by birth year, and then by the `T-CHO` values.\n\n-- SQL Query\nSELECT DISTINCT\n  T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  STRFTIME('%Y', T1.Birthday) = '1937' AND (\n    T2.`T-CHO` < 120 OR T2.`T-CHO` > 200\n  );",
        "pred_query": "SELECT DISTINCT\n  T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  STRFTIME('%Y', T1.Birthday) = '1937' AND (\n    T2.`T-CHO` < 120 OR T2.`T-CHO` > 200\n  );",
        "pred_time": 0.001821279525756836,
        "orig_time": 0.0015172958374023438,
        "time_ratio": 0.8330933368241916,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "original_query": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "llm_output": "-- Reasoning\nI need to join the `customers` and `yearmonth` tables on `CustomerID`.\nThen, I will filter for customers with `Segment = 'LAM'`.\nFinally, I will calculate the percentage of these 'LAM' customers whose `Consumption` is greater than 46.73.\n\n-- SQL Query\nSELECT CAST(SUM(IIF(T1.Consumption > 46.73, 1, 0)) AS REAL) * 100 / COUNT(T1.CustomerID) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'LAM';",
        "pred_query": "SELECT CAST(SUM(IIF(T1.Consumption > 46.73, 1, 0)) AS REAL) * 100 / COUNT(T1.CustomerID) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'LAM';",
        "pred_time": 0.06354379653930664,
        "orig_time": 0.05007672309875488,
        "time_ratio": 0.7880662759547055,
        "check": true
    },
    {
        "id": "superhero",
        "question": "What is the gender of Agent 13 hero?",
        "original_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'",
        "llm_output": "-- Reasoning\nTo find the gender of 'Agent 13', I need to join the `superhero` table with the `gender` table.\nFirst, I will filter the `superhero` table for `superhero_name` 'Agent 13'.\nThen, I will join `superhero` with `gender` on `gender_id` to retrieve the `gender` name.\n\n-- SQL Query\nSELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_time": 0.0008382797241210938,
        "orig_time": 0.0006253719329833984,
        "time_ratio": 0.7460182025028441,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please give the full name of the tallest hero published by Marvel Comics.",
        "original_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `publisher` table to filter by 'Marvel Comics'.\nThen, I will order the results by `height_cm` in descending order and limit to 1 to find the tallest hero.\nFinally, I will select the `full_name` of that hero.\n\n-- SQL Query\nSELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_time": 0.0009312629699707031,
        "orig_time": 0.0006945133209228516,
        "time_ratio": 0.7457757296466974,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "original_query": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "llm_output": "-- Reasoning\nI need to find artists from the `cards` table.\nThe condition \"Phyrexian\" refers to a keyword or theme that would likely appear in the card's `flavorText` or `name`.\nI will filter the `cards` table for entries where either the `flavorText` or `name` column contains 'Phyrexian' (case-insensitive).\nFinally, I will select the distinct artist names.\n\n-- SQL Query\nSELECT DISTINCT artist FROM cards WHERE flavorText LIKE '%Phyrexian%' OR name LIKE '%Phyrexian%';",
        "pred_query": "SELECT DISTINCT artist FROM cards WHERE flavorText LIKE '%Phyrexian%' OR name LIKE '%Phyrexian%';",
        "pred_time": 0.07276701927185059,
        "orig_time": 0.07225441932678223,
        "time_ratio": 0.9929556006251495,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "original_query": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "llm_output": "-- Reasoning\nTo find the user, I need to join `votes` with `users` on `UserId`.\nI also need to filter by `BountyAmount` in the `votes` table.\nTo identify the post, I need to join `votes` with `posts` on `PostId`.\nFinally, I will filter the `posts` based on the `Title` containing 'variance'.\n\n-- SQL Query\nSELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_query": "SELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_time": 0.004308938980102539,
        "orig_time": 0.0031414031982421875,
        "time_ratio": 0.729043324295911,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Write down the ruling of Beacon of Immortality.",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "llm_output": "-- Reasoning\nThe question asks for the ruling text of a card named 'Beacon of Immortality'.\nThe 'rulings' table contains the 'text' of rulings and is linked to the 'cards' table via the 'uuid' column.\nI need to join 'cards' and 'rulings' tables on their 'uuid' columns.\nThen filter by the card 'name' being 'Beacon of Immortality' and select the 'text' from the 'rulings' table.\n\n-- SQL Query\nSELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality';",
        "pred_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality';",
        "pred_time": 0.16424894332885742,
        "orig_time": 0.16120553016662598,
        "time_ratio": 0.9814707291228172,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "original_query": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "llm_output": "-- Reasoning\nI need to first find `molecule_id`s that have `bond_type` as '#'.\nThen, for these identified `molecule_id`s, I need to retrieve the `label` from the `molecule` table and all the `element`s from the `atom` table.\nI will join `bond` with `molecule` to filter for triple bonds and get the molecule label, and then join with `atom` to get all elements for those specific molecules.\nA `DISTINCT` clause will ensure unique combinations of molecule label and element.\n\n-- SQL Query\nSELECT DISTINCT\n  T2.label,\n  T3.element\nFROM bond AS T1\nINNER JOIN molecule AS T2\n  ON T1.molecule_id = T2.molecule_id\nINNER JOIN atom AS T3\n  ON T2.molecule_id = T3.molecule_id\nWHERE\n  T1.bond_type = '#';",
        "pred_query": "SELECT DISTINCT\n  T2.label,\n  T3.element\nFROM bond AS T1\nINNER JOIN molecule AS T2\n  ON T1.molecule_id = T2.molecule_id\nINNER JOIN atom AS T3\n  ON T2.molecule_id = T3.molecule_id\nWHERE\n  T1.bond_type = '#';",
        "pred_time": 0.007169485092163086,
        "orig_time": 0.00632166862487793,
        "time_ratio": 0.8817465332047487,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "original_query": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "llm_output": "-- Reasoning\nI need to first identify users who have the 'Organizer' badge by joining `users` and `badges` tables.\nThen, I will filter these users to find how many are teenagers (Age between 13 and 18).\nFinally, I will calculate the percentage of teenage users among all 'Organizer' badge holders.\n\n-- SQL Query\nSELECT\n  CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id)\nFROM users AS T1\nINNER JOIN badges AS T2\n  ON T1.Id = T2.UserId\nWHERE\n  T2.Name = 'Organizer';",
        "pred_query": "SELECT\n  CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id)\nFROM users AS T1\nINNER JOIN badges AS T2\n  ON T1.Id = T2.UserId\nWHERE\n  T2.Name = 'Organizer';",
        "pred_time": 0.01058197021484375,
        "orig_time": 0.008879661560058594,
        "time_ratio": 0.8391312184571017,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to count the number of superheroes for 'DC Comics' and 'Marvel Comics' separately.\nThen, I will subtract the smaller count from the larger count to find the difference.\nThis can be achieved by joining the `superhero` and `publisher` tables, filtering for the specified publishers, and using conditional aggregation to count for each.\n\n-- SQL Query\nSELECT\n  ABS(SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_query": "SELECT\n  ABS(SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_time": 0.0010898113250732422,
        "orig_time": 0.0006361007690429688,
        "time_ratio": 0.5836797199737476,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "original_query": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "llm_output": "-- Reasoning\nTo find the user who made a specific post and their reputation, I need to join the `posts` table with the `users` table.\nThe join condition will be `posts.OwnerUserId = users.Id`.\nThen I will filter the results where the `posts.Title` matches 'Understanding what Dassault iSight is doing?'.\nFinally, I will select the `DisplayName` and `Reputation` from the `users` table.\n\n-- SQL Query\nSELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_query": "SELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_time": 0.10780143737792969,
        "orig_time": 0.10753464698791504,
        "time_ratio": 0.9975251685273979,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "original_query": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "llm_output": "-- Reasoning\nTo find the languages for the specified set, I need to first locate the set using its `mcmName` and `code` in the `sets` table.\nThen, I will join with the `set_translations` table on the `setCode` to retrieve the distinct languages associated with that set.\n\nSELECT DISTINCT T2.language\nFROM sets AS T1\nINNER JOIN set_translations AS T2\n  ON T1.code = T2.setCode\nWHERE\n  T1.mcmName = 'Archenemy' AND T1.code = 'ARC';",
        "pred_query": "SELECT DISTINCT T2.language\nFROM sets AS T1\nINNER JOIN set_translations AS T2\n  ON T1.code = T2.setCode\nWHERE\n  T1.mcmName = 'Archenemy' AND T1.code = 'ARC';",
        "pred_time": 0.0048999786376953125,
        "orig_time": 0.0042493343353271484,
        "time_ratio": 0.8672148695990658,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "llm_output": "-- Reasoning\nThe question asks for the `ID` of patients who have a \"normal proteinuria level\" and are diagnosed with \"SLE\".\nThe `Laboratory` table contains `U-PRO` which represents proteinuria level. Based on the example where `U-PRO >= 30` means \"higher than normal\", \"normal\" can be inferred to mean `U-PRO < 30`. Since `U-PRO` is TEXT, it needs to be cast to REAL for numerical comparison.\nThe `Patient` table contains the `Diagnosis` for each patient. We need to filter for `Diagnosis` = 'SLE'.\nBoth tables can be joined using the `ID` column.\n\n-- SQL Query\nSELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  CAST(T2.`U-PRO` AS REAL) < 30 AND T1.Diagnosis = 'SLE';",
        "pred_query": "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  CAST(T2.`U-PRO` AS REAL) < 30 AND T1.Diagnosis = 'SLE';",
        "pred_time": 0.0034744739532470703,
        "orig_time": 0.0021390914916992188,
        "time_ratio": 0.6156590955877307,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What type of label is not on molecules with atoms with tin?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "llm_output": "-- Reasoning\nI need to find all `label`s from the `molecule` table.\nThen, I need to identify the `molecule_id`s of molecules that contain 'sn' (tin) atoms by joining `atom` and `molecule`.\nFinally, I will select `label`s from the `molecule` table that are *not* associated with any of the `molecule_id`s found in the previous step.\n\n-- SQL Query\nSELECT T1.label FROM molecule AS T1 WHERE T1.molecule_id NOT IN ( SELECT T2.molecule_id FROM atom AS T1 JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'sn' )",
        "pred_query": "SELECT T1.label FROM molecule AS T1 WHERE T1.molecule_id NOT IN ( SELECT T2.molecule_id FROM atom AS T1 JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'sn' )",
        "pred_time": 0.002060413360595703,
        "orig_time": 0.00318145751953125,
        "time_ratio": 1.5440870168942376,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "original_query": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "llm_output": "\nSELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%';\n",
        "pred_query": "SELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%';",
        "pred_time": 0.0017189979553222656,
        "orig_time": 0.0010178089141845703,
        "time_ratio": 0.5920943134535368,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "original_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "llm_output": "\nSELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';\n",
        "pred_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';",
        "pred_time": 0.1953897476196289,
        "orig_time": 0.19025588035583496,
        "time_ratio": 0.9737249915804784,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "original_query": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "llm_output": "\nSELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';\n",
        "pred_query": "SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';",
        "pred_time": 0.0017430782318115234,
        "orig_time": 0.0009729862213134766,
        "time_ratio": 0.5581999726439612,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "original_query": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "llm_output": "\nSELECT T1.driverId, T1.code\nFROM drivers AS T1\nINNER JOIN results AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  strftime('%Y', T1.dob) = '1971' AND T2.fastestLapTime IS NOT NULL AND T2.fastestLapTime = (\n    SELECT\n      MIN(T3.fastestLapTime)\n    FROM drivers AS T4\n    INNER JOIN results AS T3\n      ON T4.driverId = T3.driverId\n    WHERE\n      strftime('%Y', T4.dob) = '1971' AND T3.fastestLapTime IS NOT NULL\n  );\n",
        "pred_query": "SELECT T1.driverId, T1.code\nFROM drivers AS T1\nINNER JOIN results AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  strftime('%Y', T1.dob) = '1971' AND T2.fastestLapTime IS NOT NULL AND T2.fastestLapTime = (\n    SELECT\n      MIN(T3.fastestLapTime)\n    FROM drivers AS T4\n    INNER JOIN results AS T3\n      ON T4.driverId = T3.driverId\n    WHERE\n      strftime('%Y', T4.dob) = '1971' AND T3.fastestLapTime IS NOT NULL\n  );",
        "pred_time": 0.007026195526123047,
        "orig_time": 0.004953861236572266,
        "time_ratio": 0.7050559891414998,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the average age of patients examined in the laboratory for the October of the year 1991?",
        "original_query": "SELECT AVG('1999' - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "llm_output": "-- Reasoning\nTo find the average age of patients examined in the laboratory in October 1991, we need to:\n1.  Identify all unique patients (`ID`) who have an entry in the `Laboratory` table with a `Date` in October 1991.\n2.  For each such unique patient, retrieve their `Birthday` from the `Patient` table.\n3.  Calculate the age of each patient based on their `Birthday` and a reference date within October 1991 (e.g., '1991-10-15').\n4.  Finally, compute the average of these calculated ages.\nUsing a subquery with `DISTINCT ID` ensures each patient's age is counted only once in the average.\n\n-- SQL Query\nSELECT\n  AVG(\n    (CAST(STRFTIME('%Y', '1991-10-15') AS INTEGER) - CAST(STRFTIME('%Y', T1.Birthday) AS INTEGER)) -\n    (STRFTIME('%m%d', '1991-10-15') < STRFTIME('%m%d', T1.Birthday))\n  )\nFROM Patient AS T1\nWHERE\n  T1.ID IN (\n    SELECT DISTINCT\n      T2.ID\n    FROM Laboratory AS T2\n    WHERE\n      STRFTIME('%Y', T2.Date) = '1991' AND STRFTIME('%m', T2.Date) = '10'\n  );",
        "pred_query": "SELECT\n  AVG(\n    (CAST(STRFTIME('%Y', '1991-10-15') AS INTEGER) - CAST(STRFTIME('%Y', T1.Birthday) AS INTEGER)) -\n    (STRFTIME('%m%d', '1991-10-15') < STRFTIME('%m%d', T1.Birthday))\n  )\nFROM Patient AS T1\nWHERE\n  T1.ID IN (\n    SELECT DISTINCT\n      T2.ID\n    FROM Laboratory AS T2\n    WHERE\n      STRFTIME('%Y', T2.Date) = '1991' AND STRFTIME('%m', T2.Date) = '10'\n  );",
        "pred_time": 0.004753828048706055,
        "orig_time": 0.0023889541625976562,
        "time_ratio": 0.5025327248106726,
        "check": false
    },
    {
        "id": "financial",
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "original_query": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "llm_output": "-- Reasoning\nTo find the district ID of the account that placed a specific order, I need to link the `order` table to the `account` table.\nThe `order` table contains `order_id` and `account_id`.\nThe `account` table contains `account_id` and `district_id`.\nI will join these two tables on `account_id` and then filter by the given `order_id` to select the corresponding `district_id`.\n\n-- SQL Query\nSELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_query": "SELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_time": 0.0009958744049072266,
        "orig_time": 0.0004975795745849609,
        "time_ratio": 0.4996408905913335,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "original_query": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "llm_output": "-- Reasoning\nTo calculate the percentage, we need two counts: the number of players who prefer the left foot and were born in the specified period, and the total number of players born in the same period (for whom we have preferred foot information).\n1. Join the `Player` table with `Player_Attributes` on `player_api_id` to link player birthdates with their preferred foot.\n2. Filter the results to include only players born between 1987 and 1992 (inclusive), using `STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992'`.\n3. For the numerator, count distinct `player_api_id` values from the filtered set where `preferred_foot` is 'left'.\n4. For the denominator, count distinct `player_api_id` values from the filtered set (all players born in the range with attribute data).\n5. Divide the numerator by the denominator, cast to `REAL` for floating-point division, and multiply by 100.0 to get the percentage.\n\n-- SQL Query\nSELECT\n  CAST( (\n    SELECT COUNT(DISTINCT T1.player_api_id)\n    FROM Player AS T1\n    INNER JOIN Player_Attributes AS T2\n      ON T1.player_api_id = T2.player_api_id\n    WHERE\n      STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992' AND T2.preferred_foot = 'left'\n  ) AS REAL) * 100.0 / (\n    SELECT COUNT(DISTINCT T1.player_api_id)\n    FROM Player AS T1\n    INNER JOIN Player_Attributes AS T2\n      ON T1.player_api_id = T2.player_api_id\n    WHERE\n      STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992'\n  );",
        "pred_query": "SELECT\n  CAST( (\n    SELECT COUNT(DISTINCT T1.player_api_id)\n    FROM Player AS T1\n    INNER JOIN Player_Attributes AS T2\n      ON T1.player_api_id = T2.player_api_id\n    WHERE\n      STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992' AND T2.preferred_foot = 'left'\n  ) AS REAL) * 100.0 / (\n    SELECT COUNT(DISTINCT T1.player_api_id)\n    FROM Player AS T1\n    INNER JOIN Player_Attributes AS T2\n      ON T1.player_api_id = T2.player_api_id\n    WHERE\n      STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992'\n  );",
        "pred_time": 0.24046802520751953,
        "orig_time": 0.11336445808410645,
        "time_ratio": 0.47143256566553904,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What is the least common element of all carcinogenic molecules?",
        "original_query": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "llm_output": "-- Reasoning\nI need to first identify molecules that are carcinogenic (label = '+').\nThen, I will join with the `atom` table to get all atoms in these molecules.\nNext, I will count the occurrences of each `element` within these atoms.\nFinally, I will order the results by the count in ascending order and take the top one to find the least common element.\n\n-- SQL Query\nSELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T1.element ORDER BY COUNT(T1.element) ASC LIMIT 1;",
        "pred_query": "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T1.element ORDER BY COUNT(T1.element) ASC LIMIT 1;",
        "pred_time": 0.005689144134521484,
        "orig_time": 0.003865957260131836,
        "time_ratio": 0.6795323107870254,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "llm_output": "-- Reasoning\nThe question asks for a percentage of drivers based on three conditions: race year, driver birth year, and lap number.\nThe denominator should count distinct drivers who were born before 1985 (from `drivers` table) and participated in races between 2000 and 2005 (from `races` and `lapTimes` tables).\nThe numerator should count distinct drivers who meet all the denominator's conditions AND had at least one lap with a number over 50 (from `lapTimes` table).\nA single query with conditional aggregation on distinct driver IDs is an efficient way to calculate this percentage.\n\n-- SQL Query\nSELECT\n  CAST(COUNT(DISTINCT CASE WHEN T3.lap > 50 THEN T1.driverId END) AS REAL) * 100.0 / COUNT(DISTINCT T1.driverId)\nFROM drivers AS T1\nJOIN lapTimes AS T3\n  ON T1.driverId = T3.driverId\nJOIN races AS T2\n  ON T3.raceId = T2.raceId\nWHERE\n  STRFTIME('%Y', T1.dob) < '1985' AND T2.year BETWEEN 2000 AND 2005;",
        "pred_query": "SELECT\n  CAST(COUNT(DISTINCT CASE WHEN T3.lap > 50 THEN T1.driverId END) AS REAL) * 100.0 / COUNT(DISTINCT T1.driverId)\nFROM drivers AS T1\nJOIN lapTimes AS T3\n  ON T1.driverId = T3.driverId\nJOIN races AS T2\n  ON T3.raceId = T2.raceId\nWHERE\n  STRFTIME('%Y', T1.dob) < '1985' AND T2.year BETWEEN 2000 AND 2005;",
        "pred_time": 0.15008139610290527,
        "orig_time": 0.004194498062133789,
        "time_ratio": 0.02794815460843512,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "llm_output": "-- Reasoning\nTo find the full names of students from the 'Art and Design' department, I need to join the `member` table with the `major` table using `link_to_major` and `major_id`.\nThen, I will filter the results where the `department` column in the `major` table is 'Art and Design'.\nFinally, I will select the concatenated `first_name` and `last_name` from the `member` table.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_time": 0.0010628700256347656,
        "orig_time": 0.0005064010620117188,
        "time_ratio": 0.47644683714670255,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "original_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to find the `setCode` for the card \"Fellwar Stone\" from the `cards` table.\nThen, I will join with `set_translations` on `setCode` and filter for `language = 'Japanese'` to get the Japanese name of that set.\n\n-- SQL Query\nSELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese';",
        "pred_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese';",
        "pred_time": null,
        "orig_time": 0.06301403045654297,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Provide the name of superhero with superhero ID 294.",
        "original_query": "SELECT superhero_name FROM superhero WHERE id = 294",
        "llm_output": "-- Reasoning\nThe question asks for the name of a superhero given their ID.\nThe `superhero` table contains the `superhero_name` and `id` columns.\nI will select the `superhero_name` from the `superhero` table where the `id` matches the given superhero ID.\n\n-- SQL Query\nSELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_query": "SELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_time": 0.000896453857421875,
        "orig_time": 0.000453948974609375,
        "time_ratio": 0.5063829787234042,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Mention the category of events which were held at MU 215.",
        "original_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "llm_output": "-- Reasoning\nI need to find the category of events. The event category is in the `budget` table, linked by `link_to_event`.\nThe event location is in the `event` table, linked by `event_id`.\nI will join these two tables on their respective ID columns and filter by the location 'MU 215'.\n\n-- SQL Query\nSELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';",
        "pred_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';",
        "pred_time": 0.0007178783416748047,
        "orig_time": 0.0005137920379638672,
        "time_ratio": 0.7157090667552308,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Which group does superhero A-Bomb belong to?",
        "original_query": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'",
        "llm_output": "-- Reasoning\nThe question asks for the \"group\" a superhero belongs to. In this schema, the `publisher` table likely represents the group or organization.\nWe need to find the `publisher_name` for the superhero named 'A-Bomb'.\nThis requires joining the `superhero` table with the `publisher` table on `publisher_id`.\n\n-- SQL Query\nSELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';",
        "pred_query": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';",
        "pred_time": 0.0007963180541992188,
        "orig_time": 0.0005130767822265625,
        "time_ratio": 0.644311377245509,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which year has the most number of races?",
        "original_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to count the number of races for each year.\nI will group the `races` table by the `year` column.\nThen, I will count the occurrences of `raceId` for each year to get the total number of races per year.\nFinally, I will order the results by the count of races in descending order and limit to 1 to get the year with the most races.\n\n-- SQL Query\nSELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_time": 0.001399993896484375,
        "orig_time": 0.0008080005645751953,
        "time_ratio": 0.5771457765667575,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many posts were created by Daniel Vassallo?",
        "original_query": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "llm_output": "-- Reasoning\nTo find the number of posts created by a specific user, I need to join the 'posts' table with the 'users' table.\nThe join condition will be `posts.OwnerUserId = users.Id`.\nThen, I will filter the results using `users.DisplayName = 'Daniel Vassallo'` and count the distinct post IDs.\n\n-- SQL Query\nSELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_query": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_time": 0.23979759216308594,
        "orig_time": 0.34142613410949707,
        "time_ratio": 1.4238096847832138,
        "check": false
    },
    {
        "id": "financial",
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "original_query": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "llm_output": "-- Reasoning\nI need to calculate the percentage of male clients who have at least one account with a 'weekly' statement frequency.\n1. Identify all male clients from the `client` table. This will form the denominator.\n2. Identify male clients who are linked to an account with `frequency = 'weekly'`. This will form the numerator.\n3. Link `client` to `account` using the `disp` table which connects `client_id` and `account_id`.\n4. Use `COUNT(DISTINCT client_id)` to ensure each client is counted only once, even if they have multiple accounts.\n\n-- SQL Query\nSELECT CAST(COUNT(DISTINCT T1.client_id) AS REAL) * 100 / (SELECT COUNT(DISTINCT client_id) FROM client WHERE gender = 'M') FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M' AND T3.frequency = 'weekly';",
        "pred_query": "SELECT CAST(COUNT(DISTINCT T1.client_id) AS REAL) * 100 / (SELECT COUNT(DISTINCT client_id) FROM client WHERE gender = 'M') FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M' AND T3.frequency = 'weekly';",
        "pred_time": 0.0022156238555908203,
        "orig_time": 0.0069124698638916016,
        "time_ratio": 3.1198751748627997,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "original_query": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the maximum value of the `Percent (%) Eligible Free (K-12)` column.\nThe condition is to filter for schools located in 'Alameda County'.\nBoth the `Percent (%) Eligible Free (K-12)` and `County Name` columns are in the `frpm` table.\n\n-- SQL Query\nSELECT MAX(`Percent (%) Eligible Free (K-12)`) FROM frpm WHERE `County Name` = 'Alameda';",
        "pred_query": "SELECT MAX(`Percent (%) Eligible Free (K-12)`) FROM frpm WHERE `County Name` = 'Alameda';",
        "pred_time": 0.004868268966674805,
        "orig_time": 0.0034677982330322266,
        "time_ratio": 0.712326754493364,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "original_query": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "llm_output": "-- Reasoning\nTo find the reputation points of the owner of post No. 65041, I first need to find the `OwnerUserId` from the `posts` table where the `Id` is 65041.\nThen, I will use this `OwnerUserId` to query the `users` table and retrieve their `Reputation`.\n\n-- SQL Query\nSELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041;",
        "pred_query": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041;",
        "pred_time": 0.001116037368774414,
        "orig_time": 0.0005266666412353516,
        "time_ratio": 0.4719077120273446,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "original_query": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the fastest lap speed, I need to query the `results` table for the `fastestLapSpeed`.\nThe question specifies \"2009 Spanish Grand Prix\", which means I need to join `results` with the `races` table to filter by `year` and `name`.\nAfter filtering the results for the specific race, I will find the maximum value of `fastestLapSpeed`.\n\n-- SQL Query\nSELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_query": "SELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_time": 0.0031294822692871094,
        "orig_time": 0.0027120113372802734,
        "time_ratio": 0.8666006399512418,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many high-level credit cards have \"disponent\" type of disposition?",
        "original_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'DISPONENT'",
        "llm_output": "-- Reasoning\nThe question requires counting credit cards that are both \"high-level\" and associated with a \"Disponent\" disposition.\nI need to join the `card` table (for card type) with the `disp` table (for disposition type).\nI will filter `card.type` for 'gold' as a common interpretation of \"high-level\" in banking.\nI will filter `disp.type` for 'Disponent'.\nFinally, I will count the number of rows that satisfy both conditions.\n\n-- SQL Query\nSELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'Disponent';",
        "pred_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'Disponent';",
        "pred_time": 0.0013709068298339844,
        "orig_time": 0.0006561279296875,
        "time_ratio": 0.4786086956521739,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List all of the College of Humanities and Social Sciences' departments.",
        "original_query": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "llm_output": "-- Reasoning\nI need to find the departments within the 'College of Humanities and Social Sciences'.\nThe `major` table contains both `department` and `college` information.\nI will filter the `major` table by `college` = 'College of Humanities and Social Sciences' and select distinct `department` values.\n\n-- SQL Query\nSELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "pred_query": "SELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "pred_time": 0.0010635852813720703,
        "orig_time": 0.0005021095275878906,
        "time_ratio": 0.47209145931405516,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List the expansion type of the set \"Huiti\u00c3\u00a8me \u00c3\u00a9dition\".",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition' )",
        "llm_output": "SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';",
        "pred_query": "SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';",
        "pred_time": 0.010906457901000977,
        "orig_time": 0.003330230712890625,
        "time_ratio": 0.30534484643130394,
        "check": true
    },
    {
        "id": "student_club",
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "original_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
        "llm_output": "-- Reasoning\nTo count members with a specific major, I need to join the `member` table with the `major` table.\nThen, I will filter the results by the `major_name` 'Environmental Engineering'.\nFinally, I will count the `member_id` from the filtered rows.\n\n-- SQL Query\nSELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';",
        "pred_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';",
        "pred_time": 0.0007691383361816406,
        "orig_time": 0.0005719661712646484,
        "time_ratio": 0.7436453812771233,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List down at least five superpowers of male superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
        "llm_output": "-- Reasoning\nI need to join `superhero` with `gender` to filter for 'Male' superheroes.\nThen, I will join with `hero_power` and `superpower` to get the names of their powers.\nFinally, I will select distinct power names and limit the result to 5.\n\n-- SQL Query\nSELECT DISTINCT\n  T3.power_name\nFROM superhero AS T1\nINNER JOIN gender AS T2\n  ON T1.gender_id = T2.id\nINNER JOIN hero_power AS T4\n  ON T1.id = T4.hero_id\nINNER JOIN superpower AS T3\n  ON T4.power_id = T3.id\nWHERE\n  T2.gender = 'Male'\nLIMIT 5;",
        "pred_query": "SELECT DISTINCT\n  T3.power_name\nFROM superhero AS T1\nINNER JOIN gender AS T2\n  ON T1.gender_id = T2.id\nINNER JOIN hero_power AS T4\n  ON T1.id = T4.hero_id\nINNER JOIN superpower AS T3\n  ON T4.power_id = T3.id\nWHERE\n  T2.gender = 'Male'\nLIMIT 5;",
        "pred_time": 0.0011260509490966797,
        "orig_time": 0.0005505084991455078,
        "time_ratio": 0.4888841837814948,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "For the race happened in 2015/11/29, how many drivers finished the game?",
        "original_query": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "llm_output": "-- Reasoning\nTo find the number of drivers who finished the race on '2015-11-29', I need to join the `races` table with the `results` table.\nFirst, I filter the `races` table by the given `date`.\nThen, I filter the `results` table for entries where `time` is not NULL, as this indicates a completed race.\nFinally, I count the distinct `driverId`s to get the number of unique drivers who finished.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;",
        "pred_query": "SELECT COUNT(DISTINCT T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;",
        "pred_time": 0.004140377044677734,
        "orig_time": 0.003182649612426758,
        "time_ratio": 0.768685938039848,
        "check": true
    },
    {
        "id": "superhero",
        "question": "How many superheroes are published by Marvel Comics?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "llm_output": "-- Reasoning\nI need to count the number of superheroes.\nI will join the `superhero` table with the `publisher` table using `publisher_id`.\nThen, I will filter the results to only include publishers named 'Marvel Comics' and count the superheroes.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_time": 0.0011157989501953125,
        "orig_time": 0.0005946159362792969,
        "time_ratio": 0.5329059829059829,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "original_query": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "llm_output": "-- Reasoning\nThe question asks for the fastest lap time among all lap records.\nThe `lapTimes` table contains a `milliseconds` column which represents the time for each lap.\nTo find the fastest lap time, we need to find the minimum value in the `milliseconds` column across all entries.\n\n-- SQL Query\nSELECT MIN(milliseconds) FROM lapTimes;",
        "pred_query": "SELECT MIN(milliseconds) FROM lapTimes;",
        "pred_time": 0.030942201614379883,
        "orig_time": 0.29343557357788086,
        "time_ratio": 9.483345019687011,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Give the publisher ID of Star Trek.",
        "original_query": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
        "llm_output": "-- Reasoning\nThe question asks for the publisher ID of 'Star Trek'.\nThe `superhero` table contains the `superhero_name` and `publisher_id`.\nI need to select the `publisher_id` from the `superhero` table where `superhero_name` is 'Star Trek'.\n\n-- SQL Query\nSELECT T1.publisher_id FROM superhero AS T1 WHERE T1.superhero_name = 'Star Trek';",
        "pred_query": "SELECT T1.publisher_id FROM superhero AS T1 WHERE T1.superhero_name = 'Star Trek';",
        "pred_time": 0.0007035732269287109,
        "orig_time": 0.00040078163146972656,
        "time_ratio": 0.5696374110471026,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the name of the race held on the circuits in Germany.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "llm_output": "\nSELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'\n",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'",
        "pred_time": 0.0011303424835205078,
        "orig_time": 0.0008127689361572266,
        "time_ratio": 0.7190466146382619,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "original_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'",
        "llm_output": "-- Reasoning\nTo find all comments for a specific post title, I first need to locate the `Id` of the post from the `posts` table using the given title.\nThen, I will join the `posts` table with the `comments` table on `Id` and `PostId` respectively.\nFinally, I will filter the results by the post title and select the `Text` of the comments.\n\n-- SQL Query\nSELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_query": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_time": 0.21110200881958008,
        "orig_time": 0.20882821083068848,
        "time_ratio": 0.9892289135399231,
        "check": true
    },
    {
        "id": "financial",
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "original_query": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "llm_output": "-- Reasoning\nTo list account ID, district name (A2), and district region (A3), we need to join the `account` and `district` tables.\nThe conditions are:\n1. Accounts must be from the year 1993, meaning `account.date` falls in 1993.\n2. The account's statement date (`account.date`) must be *after* at least one of its transaction dates (`trans.date`). This requires joining `account` with `trans` and comparing their `date` columns.\nWe will use `DISTINCT` to avoid duplicate rows for accounts that satisfy the conditions through multiple transactions.\n\n-- SQL Query\nSELECT DISTINCT\n  T1.account_id,\n  T2.A2,\n  T2.A3\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3\n  ON T1.account_id = T3.account_id\nWHERE\n  STRFTIME('%Y', T1.date) = '1993' AND T1.date > T3.date;",
        "pred_query": "SELECT DISTINCT\n  T1.account_id,\n  T2.A2,\n  T2.A3\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3\n  ON T1.account_id = T3.account_id\nWHERE\n  STRFTIME('%Y', T1.date) = '1993' AND T1.date > T3.date;",
        "pred_time": 1.7163548469543457,
        "orig_time": 0.0009479522705078125,
        "time_ratio": 0.0005523055283060751,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which website should I go to if I want to know more about Anthony Davidson?",
        "original_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
        "llm_output": "-- Reasoning\nTo find the website for Anthony Davidson, I need to query the 'drivers' table.\nI will filter the rows by matching the 'forename' with 'Anthony' and 'surname' with 'Davidson'.\nFinally, I will select the 'url' column from the matching row.\n\n-- SQL Query\nSELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "pred_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "pred_time": 0.0010867118835449219,
        "orig_time": 0.0006787776947021484,
        "time_ratio": 0.6246160596752962,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
        "original_query": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
        "llm_output": "-- Reasoning\nI need to first filter for molecules that are labeled as 'carcinogenic'.\nThen, for these carcinogenic molecules, I need to count the number of double bonds (where `bond_type` is '=').\nFinally, I will select the label of the molecule with the highest count of double bonds among the carcinogenic ones.\n\n-- SQL Query\nSELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T2.molecule_id, COUNT(T2.bond_type) AS double_bond_count FROM bond AS T2 WHERE T2.bond_type = '=' GROUP BY T2.molecule_id ) AS T3 ON T1.molecule_id = T3.molecule_id WHERE T1.label LIKE '%carcinogenic%' ORDER BY T3.double_bond_count DESC LIMIT 1;",
        "pred_query": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T2.molecule_id, COUNT(T2.bond_type) AS double_bond_count FROM bond AS T2 WHERE T2.bond_type = '=' GROUP BY T2.molecule_id ) AS T3 ON T1.molecule_id = T3.molecule_id WHERE T1.label LIKE '%carcinogenic%' ORDER BY T3.double_bond_count DESC LIMIT 1;",
        "pred_time": 0.0020835399627685547,
        "orig_time": 0.0018944740295410156,
        "time_ratio": 0.9092573520997825,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
        "original_query": "SELECT NCESDist FROM schools WHERE SOC = 31",
        "llm_output": "-- Reasoning\nThe question asks for the `NCESDist` from the `schools` table.\nThe condition specifies that the `SOCType` (School Ownership Code Type) should be 'State Special Schools'.\nTherefore, I need to select the `NCESDist` column from the `schools` table where `SOCType` equals 'State Special Schools'.\n\n-- SQL Query\nSELECT NCESDist FROM schools WHERE SOCType = 'State Special Schools';",
        "pred_query": "SELECT NCESDist FROM schools WHERE SOCType = 'State Special Schools';",
        "pred_time": 0.010267496109008789,
        "orig_time": 0.00962519645690918,
        "time_ratio": 0.937443399512365,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List the power of superheroes with height greater than 80% of the average height of all superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm * 100 > ( SELECT AVG(height_cm) FROM superhero ) * 80",
        "llm_output": "-- Reasoning\nI need to first calculate the average height of all superheroes from the 'superhero' table.\nThen, I will determine the threshold (80% of the average height).\nNext, I will select the 'hero_id' from 'superhero' for all superheroes whose height is greater than this threshold.\nFinally, I will join with 'hero_power' and 'superpower' tables to get the distinct power names associated with these superheroes.\n\n-- SQL Query\nSELECT DISTINCT\n  T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2\n  ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3\n  ON T2.power_id = T3.id\nWHERE\n  T1.height_cm > (\n    SELECT\n      AVG(height_cm) * 0.8\n    FROM superhero\n  );",
        "pred_query": "SELECT DISTINCT\n  T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2\n  ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3\n  ON T2.power_id = T3.id\nWHERE\n  T1.height_cm > (\n    SELECT\n      AVG(height_cm) * 0.8\n    FROM superhero\n  );",
        "pred_time": 0.0019409656524658203,
        "orig_time": 0.0014111995697021484,
        "time_ratio": 0.7270605576710478,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "original_query": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
        "llm_output": "-- Reasoning\nTo find the average number of long shots for 'Ahmed Samir Farag', I need to join the 'Player' table with the 'Player_Attributes' table.\nFirst, I will filter the 'Player' table by the player's name to get their 'player_api_id'.\nThen, I will use this ID to filter the 'Player_Attributes' table and calculate the average of the 'long_shots' column.\n\n-- SQL Query\nSELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';",
        "pred_query": "SELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';",
        "pred_time": 0.09834551811218262,
        "orig_time": 0.09546756744384766,
        "time_ratio": 0.9707363312169235,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What are the card layout of cards with keyword of flying?",
        "original_query": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "llm_output": "SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%'",
        "pred_query": "SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%'",
        "pred_time": 0.07029271125793457,
        "orig_time": 0.0648655891418457,
        "time_ratio": 0.9227925339773224,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "original_query": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "llm_output": "-- Reasoning\nTo find the years Lewis Hamilton participated, I need to link the `drivers` table (for his name) to the `results` table (for race participation), and then to the `races` table (for the year).\nI will filter by his first and last name in the `drivers` table.\nThen, I will join `drivers` with `results` on `driverId` and `results` with `races` on `raceId`.\nFinally, I will select distinct years from the `races` table.\n\n-- SQL Query\nSELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton';",
        "pred_query": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton';",
        "pred_time": 0.0067615509033203125,
        "orig_time": 0.005415201187133789,
        "time_ratio": 0.8008815232722144,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "original_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "llm_output": "-- Reasoning\nThe query needs to retrieve specific user information (Reputation and Views).\nThis information is directly available in the 'users' table.\nThe filtering condition is based on the 'DisplayName' column, which should be 'Jarrod Dixon'.\n\n-- SQL Query\nSELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_time": 0.010080814361572266,
        "orig_time": 0.008865118026733398,
        "time_ratio": 0.8794049477318954,
        "check": true
    }
]