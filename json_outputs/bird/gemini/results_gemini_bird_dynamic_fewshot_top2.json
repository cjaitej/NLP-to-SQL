[
    {
        "id": "european_football_2",
        "question": "Please list all team names which the speed class is fast.",
        "original_query": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "llm_output": "SELECT DISTINCT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast';",
        "pred_query": "SELECT DISTINCT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast';",
        "pred_time": 0.002158641815185547,
        "orig_time": 0.0014848709106445312,
        "time_ratio": 0.6878727634194831,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many circuits are there in Melbourne, Australia?",
        "original_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia'",
        "llm_output": "-- Reasoning\nI need to count the number of circuits.\nThe `circuits` table contains information about circuits including their location and country.\nI will filter the `circuits` table for entries where the `location` is 'Melbourne' and the `country` is 'Australia'.\nFinally, I will use `COUNT(*)` to get the total number of matching circuits.\n\n-- SQL Query\nSELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';",
        "pred_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';",
        "pred_time": 0.0008497238159179688,
        "orig_time": 0.0005056858062744141,
        "time_ratio": 0.5951178451178452,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many Formula_1 races took place on the circuits in Italy?",
        "original_query": "SELECT COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Italy'",
        "llm_output": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';",
        "pred_query": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';",
        "pred_time": 0.0013189315795898438,
        "orig_time": 0.0007796287536621094,
        "time_ratio": 0.5911062906724512,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "original_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "llm_output": "-- Reasoning\nThe question asks for the proportion of cards that satisfy two conditions: \"do not have a text box\" and \"have a normal layout\".\n\"Do not have a text box\" translates to `isTextless = 1` in the `cards` table.\n\"Have a normal layout\" translates to `layout = 'normal'` in the `cards` table.\nThe proportion should be calculated as the count of cards meeting both conditions divided by the total number of cards in the `cards` table.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) / COUNT(id) FROM cards;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) / COUNT(id) FROM cards;",
        "pred_time": 0.06510329246520996,
        "orig_time": 0.05813932418823242,
        "time_ratio": 0.8930320109278811,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What's the magic card market name for the set which was released on 2017/6/9?",
        "original_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "llm_output": "\nSELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'\n",
        "pred_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "pred_time": 0.004195451736450195,
        "orig_time": 0.0034525394439697266,
        "time_ratio": 0.8229243621071773,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the percentage of molecules that are carcinogenic?",
        "original_query": "SELECT CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id) FROM molecule t",
        "llm_output": "-- Reasoning\nTo find the percentage, I need the count of carcinogenic molecules (label = '+') and the total count of all molecules.\nI will divide the count of carcinogenic molecules by the total count of molecules and multiply by 100.0 to get the percentage.\nUsing a CASE statement within an aggregate function will allow counting carcinogenic molecules and total molecules in one pass.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(molecule_id) FROM molecule;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(molecule_id) FROM molecule;",
        "pred_time": 0.0009725093841552734,
        "orig_time": 0.0004661083221435547,
        "time_ratio": 0.47928413826918365,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What is the percentage of borderless cards?",
        "original_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "llm_output": "-- Reasoning\nTo find the percentage of borderless cards, I need to count all cards and then count cards with 'borderless' as their borderColor.\nThe percentage is calculated by dividing the count of borderless cards by the total count of cards and multiplying by 100.\nAll card information is available in the 'cards' table.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_time": 0.06362271308898926,
        "orig_time": 0.053914546966552734,
        "time_ratio": 0.8474103720025632,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "original_query": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "llm_output": "SELECT budget_id FROM budget WHERE category IN ('water', 'chips', 'cookies') ORDER BY amount DESC LIMIT 1;",
        "pred_query": "SELECT budget_id FROM budget WHERE category IN ('water', 'chips', 'cookies') ORDER BY amount DESC LIMIT 1;",
        "pred_time": 0.0006740093231201172,
        "orig_time": 0.0004315376281738281,
        "time_ratio": 0.6402546869472939,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "original_query": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "llm_output": "-- Reasoning\nI need to join the Patient and Laboratory tables to access sex and total protein (TP) values.\nThen, I will filter for female patients whose TP is outside the normal range (TP < 6.0 or TP > 8.5).\nFor these patients, I will calculate the absolute deviation of their TP from the closest normal range boundary.\n\n-- SQL Query\nSELECT\n  T1.ID,\n  T1.SEX,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0\n    THEN T2.TP - 6.0\n    WHEN T2.TP > 8.5\n    THEN T2.TP - 8.5\n    ELSE 0 -- This case should not be reached due to WHERE clause\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5);",
        "pred_query": "SELECT\n  T1.ID,\n  T1.SEX,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0\n    THEN T2.TP - 6.0\n    WHEN T2.TP > 8.5\n    THEN T2.TP - 8.5\n    ELSE 0 -- This case should not be reached due to WHERE clause\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5);",
        "pred_time": 0.006268024444580078,
        "orig_time": 0.0043218135833740234,
        "time_ratio": 0.6895017116774439,
        "check": false
    },
    {
        "id": "card_games",
        "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
        "original_query": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "llm_output": "-- Reasoning\nThe question asks for the release date of the set containing a specific card.\nFirst, I need to find the `setCode` for the card 'Ancestor''s Chosen' from the `cards` table.\nThen, I will use this `setCode` to join with the `sets` table and retrieve the `releaseDate`.\n\n-- SQL Query\nSELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor''s Chosen';",
        "pred_query": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor''s Chosen';",
        "pred_time": 0.06573724746704102,
        "orig_time": 0.05700874328613281,
        "time_ratio": 0.8672213316311357,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "original_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "llm_output": "-- Reasoning\nTo find the Q1 result, I need to query the `qualifying` table.\nThe question specifies the driver by name ('Bruno Senna') and the race by ID (354).\nI will join `qualifying` with the `drivers` table on `driverId` to filter by the driver's name.\nFinally, I will filter by `raceId` and select the `q1` column.\n\n-- SQL Query\nSELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna';",
        "pred_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna';",
        "pred_time": 0.0011730194091796875,
        "orig_time": 0.0009198188781738281,
        "time_ratio": 0.7841463414634147,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "original_query": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "llm_output": "-- Reasoning\nTo find the free rate for students aged 5-17 at the school run by Kacey Gibson, I need to join the `schools` table (to find the school by administrator name) with the `frpm` table (to get the free meal count).\nThe join condition will be `schools.CDSCode = frpm.CDSCode`.\nI will filter the `schools` table for `AdmFName1` = 'Kacey' and `AdmLName1` = 'Gibson'.\nThen, I will select the `Free Meal Count (Ages 5-17)` from the `frpm` table.\n\n-- SQL Query\nSELECT T1.`Free Meal Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson';",
        "pred_query": "SELECT T1.`Free Meal Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson';",
        "pred_time": 0.011169672012329102,
        "orig_time": 0.008627653121948242,
        "time_ratio": 0.7724177677218297,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "original_query": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "llm_output": "-- Reasoning\nI need to find the `District Code` from the `frpm` table.\nI will join `frpm` with the `schools` table using the `CDSCode` column.\nI need to filter schools that do not offer a magnet program, which means `Magnet` column in the `schools` table should be 0.\nI also need to filter for schools located in the city of 'Fresno', using the `City` column in the `schools` table.\n\n-- SQL Query\nSELECT DISTINCT\n  T1.`District Code`\nFROM frpm AS T1\nINNER JOIN schools AS T2\n  ON T1.CDSCode = T2.CDSCode\nWHERE\n  T2.Magnet = 0 AND T2.City = 'Fresno';",
        "pred_query": "SELECT DISTINCT\n  T1.`District Code`\nFROM frpm AS T1\nINNER JOIN schools AS T2\n  ON T1.CDSCode = T2.CDSCode\nWHERE\n  T2.Magnet = 0 AND T2.City = 'Fresno';",
        "pred_time": 0.011336088180541992,
        "orig_time": 0.008103132247924805,
        "time_ratio": 0.7148085052684712,
        "check": false
    },
    {
        "id": "student_club",
        "question": "What's Angela Sanders's major?",
        "original_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "llm_output": "-- Reasoning\nTo find Angela Sanders's major, I need to look up her record in the `member` table.\nThen, I will use the `link_to_major` from the `member` table to join with the `major` table.\nFinally, I will select the `major_name` from the `major` table.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_time": 0.0007474422454833984,
        "orig_time": 0.00047850608825683594,
        "time_ratio": 0.6401913875598086,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "llm_output": "-- Reasoning\nThe query needs to join the Patient and Laboratory tables using the common 'ID' column.\nIt should filter for patients whose RNP level in the Laboratory table is not explicitly marked as abnormal ('-' or '+-').\nAdditionally, it should filter for patients who have an admission record, assuming a non-empty, non-NULL 'Admission' field indicates hospital admission.\nFinally, it counts the distinct patient IDs to get the number of unique patients satisfying both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP NOT IN ('-', '+-') AND T1.Admission IS NOT NULL AND T1.Admission != '';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP NOT IN ('-', '+-') AND T1.Admission IS NOT NULL AND T1.Admission != '';",
        "pred_time": 0.0063934326171875,
        "orig_time": 0.005703926086425781,
        "time_ratio": 0.892153937947494,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "original_query": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' THEN 1 ELSE NULL END) FROM cards",
        "llm_output": "-- Reasoning\nTo answer this question, I need to query the 'cards' table.\nI will filter cards where 'borderColor' is 'black'.\nAdditionally, I will filter cards where the 'availability' column contains both 'arena' and 'mtgo'.\nFinally, I will count the distinct artists from the filtered results.\n\n-- SQL Query\nSELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%';",
        "pred_query": "SELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%';",
        "pred_time": 0.0659332275390625,
        "orig_time": 0.053811073303222656,
        "time_ratio": 0.816144989585744,
        "check": false
    },
    {
        "id": "superhero",
        "question": "What is the name of the superhero that has the most powers?",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to count the powers for each superhero using the `hero_power` table.\nThen, I will join this with the `superhero` table to get the superhero's name.\nFinally, I will order the results by the power count in descending order and take the top one.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.id ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.id ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_time": 0.002618074417114258,
        "orig_time": 0.002064943313598633,
        "time_ratio": 0.7887259812403242,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to count unique patients.\nA patient's anti-SSB level is found in the `Laboratory` table. Based on the few-shot examples, 'normal' typically means 'negative' or '0'.\nSymptoms are recorded in the `Examination` table. To check if 'other symptoms' are observed, I should look for non-NULL values in the `Symptoms` column.\nI will join `Patient`, `Laboratory`, and `Examination` tables on `ID` to link these conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 JOIN Laboratory AS T2 ON T1.ID = T2.ID JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.SSB IN ('negative', '0') AND T3.Symptoms IS NOT NULL;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 JOIN Laboratory AS T2 ON T1.ID = T2.ID JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.SSB IN ('negative', '0') AND T3.Symptoms IS NOT NULL;",
        "pred_time": 0.0069828033447265625,
        "orig_time": 0.0011565685272216797,
        "time_ratio": 0.16563097514340344,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "original_query": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "llm_output": "-- Reasoning\nI need to count the number of distinct male patients with CRE >= 1.5 and distinct female patients with CRE >= 1.5.\nThen, I will compare these two counts to determine if the male count is greater than the female count.\nThe result should be 'True' or 'False'.\nI will join Patient and Laboratory tables on ID.\n\n-- SQL Query\nSELECT CASE\n           WHEN (SELECT COUNT(DISTINCT T1.ID)\n                 FROM Patient AS T1\n                 INNER JOIN Laboratory AS T2\n                 ON T1.ID = T2.ID\n                 WHERE T1.SEX = 'M' AND T2.CRE >= 1.5) >\n                (SELECT COUNT(DISTINCT T1.ID)\n                 FROM Patient AS T1\n                 INNER JOIN Laboratory AS T2\n                 ON T1.ID = T2.ID\n                 WHERE T1.SEX = 'F' AND T2.CRE >= 1.5)\n           THEN 'True'\n           ELSE 'False'\n       END;",
        "pred_query": "SELECT CASE\n           WHEN (SELECT COUNT(DISTINCT T1.ID)\n                 FROM Patient AS T1\n                 INNER JOIN Laboratory AS T2\n                 ON T1.ID = T2.ID\n                 WHERE T1.SEX = 'M' AND T2.CRE >= 1.5) >\n                (SELECT COUNT(DISTINCT T1.ID)\n                 FROM Patient AS T1\n                 INNER JOIN Laboratory AS T2\n                 ON T1.ID = T2.ID\n                 WHERE T1.SEX = 'F' AND T2.CRE >= 1.5)\n           THEN 'True'\n           ELSE 'False'\n       END;",
        "pred_time": 0.006172895431518555,
        "orig_time": 0.0034313201904296875,
        "time_ratio": 0.5558688347302151,
        "check": false
    },
    {
        "id": "student_club",
        "question": "List the name of students that have attended more than 7 events.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "llm_output": "-- Reasoning\nI need to join the `member` table with the `attendance` table.\nThen, I will group the results by member to count the number of events each member attended.\nFinally, I will filter for members who attended more than 7 events and select their first and last names.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_time": 0.001224517822265625,
        "orig_time": 0.0006678104400634766,
        "time_ratio": 0.5453660436137072,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many female customers have a junior credit card?",
        "original_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "llm_output": "-- Reasoning\nI need to count unique clients who are female and have a 'junior' type credit card.\nI will join `client` (for gender), `disp` (to link clients to cards), and `card` (for card type).\nFilter clients by gender 'F' and cards by type 'junior', then count distinct client IDs.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior';",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior';",
        "pred_time": 0.0024182796478271484,
        "orig_time": 0.0009646415710449219,
        "time_ratio": 0.39889579020013805,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "original_query": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "llm_output": "-- Reasoning\nThe question asks if a specific bond (TR001_1_8) connects atoms such that both chlorine ('cl') and carbon ('c') elements are present.\nA bond in the `connected` table links two atoms (`atom_id` and `atom_id2`).\nWe need to find the elements of these two atoms and check if one is 'cl' and the other is 'c', regardless of which `atom_id` holds which element.\nThis requires joining `connected` with the `atom` table twice, once for `atom_id` and once for `atom_id2`.\n\n-- SQL Query\nSELECT CASE WHEN (T3.element = 'cl' AND T4.element = 'c') OR (T3.element = 'c' AND T4.element = 'cl') THEN 'Yes' ELSE 'No' END FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T1.atom_id = T3.atom_id INNER JOIN atom AS T4 ON T1.atom_id2 = T4.atom_id WHERE T1.bond_id = 'TR001_1_8';",
        "pred_query": "SELECT CASE WHEN (T3.element = 'cl' AND T4.element = 'c') OR (T3.element = 'c' AND T4.element = 'cl') THEN 'Yes' ELSE 'No' END FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T1.atom_id = T3.atom_id INNER JOIN atom AS T4 ON T1.atom_id2 = T4.atom_id WHERE T1.bond_id = 'TR001_1_8';",
        "pred_time": 0.002721071243286133,
        "orig_time": 0.0023849010467529297,
        "time_ratio": 0.8764566722158942,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "llm_output": "-- Reasoning\nThe question asks to count distinct patients who meet two conditions: having a normal Ig G level and having symptoms.\nFirst, I will identify patients with a normal Ig G level by filtering the `Laboratory` table (assuming a common normal range for IgG, e.g., 700-1600).\nSecond, I will identify patients who have symptoms by checking the `Symptoms` column in the `Examination` table (where it's not NULL or empty).\nThen, I will join these filtered conditions and count the distinct patient IDs.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID)\nFROM Laboratory AS T1\nJOIN Examination AS T2\n  ON T1.ID = T2.ID\nWHERE T1.IGG BETWEEN 700 AND 1600 -- Assuming a common normal range for IgG (700-1600 mg/dL)\n  AND T2.Symptoms IS NOT NULL\n  AND T2.Symptoms != '';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID)\nFROM Laboratory AS T1\nJOIN Examination AS T2\n  ON T1.ID = T2.ID\nWHERE T1.IGG BETWEEN 700 AND 1600 -- Assuming a common normal range for IgG (700-1600 mg/dL)\n  AND T2.Symptoms IS NOT NULL\n  AND T2.Symptoms != '';",
        "pred_time": 0.004592180252075195,
        "orig_time": 0.000652313232421875,
        "time_ratio": 0.1420486994444733,
        "check": false
    },
    {
        "id": "financial",
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "original_query": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.district_id = ( SELECT district_id FROM client ORDER BY birth_date DESC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe question asks for the account number of the client who is youngest and has the highest average salary.\n1. To find the youngest client, we need to look for the maximum `birth_date` in the `client` table.\n2. The average salary information (`A11`) is in the `district` table.\n3. We need to link `client` to `district` via `district_id`.\n4. Then, we need to link `client` to `disp` via `client_id` to get the `account_id`.\n5. We will order the results by `birth_date` in descending order (youngest first) and then by `A11` in descending order (highest salary first) and take the top entry.\n\n-- SQL Query\nSELECT\n  T3.account_id\nFROM client AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3\n  ON T1.client_id = T3.client_id\nORDER BY\n  T1.birth_date DESC,\n  T2.A11 DESC\nLIMIT 1;",
        "pred_query": "SELECT\n  T3.account_id\nFROM client AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3\n  ON T1.client_id = T3.client_id\nORDER BY\n  T1.birth_date DESC,\n  T2.A11 DESC\nLIMIT 1;",
        "pred_time": 0.002525806427001953,
        "orig_time": 0.0010187625885009766,
        "time_ratio": 0.40334151406456487,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
        "original_query": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
        "llm_output": "-- Reasoning\nI need to count the number of races held at each circuit within the specified year range (1990 to 2000).\nFirst, I will filter the `races` table for the years between 1990 and 2000.\nThen, I will group these races by `circuitId` and count the occurrences.\nFinally, I will filter these groups to only include circuits where the count of races is 4, and join with the `circuits` table to retrieve the circuit name.\n\n-- SQL Query\nSELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year BETWEEN 1990 AND 2000 GROUP BY T1.circuitId HAVING COUNT(T2.raceId) = 4;",
        "pred_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year BETWEEN 1990 AND 2000 GROUP BY T1.circuitId HAVING COUNT(T2.raceId) = 4;",
        "pred_time": 0.00231170654296875,
        "orig_time": 0.001354217529296875,
        "time_ratio": 0.5858085808580858,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to count the number of superheroes for 'DC Comics' and 'Marvel Comics' separately.\nThen, I will calculate the absolute difference between these two counts.\nThis can be achieved by joining `superhero` and `publisher` tables, filtering by publisher names, and then using conditional aggregation.\n\n-- SQL Query\nSELECT\n  ABS(SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_query": "SELECT\n  ABS(SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_time": 0.0008282661437988281,
        "orig_time": 0.0006084442138671875,
        "time_ratio": 0.7345998848589522,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Please list the names of the badges obtained by csgillespie.",
        "original_query": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "llm_output": "-- Reasoning\nI need to retrieve badge names.\nBadges are listed in the `badges` table and are linked to users via `UserId`.\nUser information, including `DisplayName`, is in the `users` table.\nI will join `badges` and `users` on their respective ID columns and filter by the user's display name.\n\n-- SQL Query\nSELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_query": "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_time": 0.06376338005065918,
        "orig_time": 0.06107139587402344,
        "time_ratio": 0.9577816581477174,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "original_query": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "llm_output": "SELECT T3.team_long_name FROM Match AS T1 INNER JOIN League AS T2 ON T1.league_id = T2.id INNER JOIN Team AS T3 ON T1.away_team_api_id = T3.team_api_id WHERE T2.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T3.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1;",
        "pred_query": "SELECT T3.team_long_name FROM Match AS T1 INNER JOIN League AS T2 ON T1.league_id = T2.id INNER JOIN Team AS T3 ON T1.away_team_api_id = T3.team_api_id WHERE T2.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T3.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1;",
        "pred_time": 0.0592198371887207,
        "orig_time": 0.06178116798400879,
        "time_ratio": 1.043251229940496,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the bond type for atoms with element Tin?",
        "original_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "llm_output": "-- Reasoning\nI need to find the `bond_type` from the `bond` table.\nTo link bonds to atoms, I will join `bond` with `connected` on `bond_id`.\nThen, I will join `connected` with `atom` on `atom_id` to filter for atoms with 'Tin' element.\n\n-- SQL Query\nSELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Sn';",
        "pred_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Sn';",
        "pred_time": 0.016467571258544922,
        "orig_time": 0.015427112579345703,
        "time_ratio": 0.936817721152454,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "original_query": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "llm_output": "SELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "pred_query": "SELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "pred_time": 0.38884449005126953,
        "orig_time": 0.39062047004699707,
        "time_ratio": 1.004567327147913,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "llm_output": "\nSELECT COUNT(ID) FROM Examination WHERE `Examination Date` > '1997-01-01' AND KCT IS NOT NULL;\n",
        "pred_query": "SELECT COUNT(ID) FROM Examination WHERE `Examination Date` > '1997-01-01' AND KCT IS NOT NULL;",
        "pred_time": 0.001047372817993164,
        "orig_time": 0.003988981246948242,
        "time_ratio": 3.8085590712497153,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'Owner' AND T1.frequency = 'POPLATEK TYDNE'",
        "llm_output": "-- Reasoning\nI need to count clients based on their account frequency and their disposition type.\nI will join `client`, `disp`, and `account` tables.\nFilter `account` by `frequency = 'POPLATEK TYDNE'` and `disp` by `type = 'OWNER'`.\nFinally, count the distinct `client_id`s.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_time": 0.002247333526611328,
        "orig_time": 0.0008537769317626953,
        "time_ratio": 0.37990664120517714,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "How many users received commentator badges in 2014?",
        "original_query": "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'",
        "llm_output": "-- Reasoning\nI need to query the `badges` table.\nFilter the records where the `Name` is 'commentator'.\nFurther filter these records to include only those where the year of `Date` is '2014'.\nFinally, count the distinct `UserId` to find the number of unique users.\n\n-- SQL Query\nSELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'commentator' AND STRFTIME('%Y', Date) = '2014';",
        "pred_query": "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'commentator' AND STRFTIME('%Y', Date) = '2014';",
        "pred_time": 0.009347677230834961,
        "orig_time": 0.009475231170654297,
        "time_ratio": 1.0136455224832301,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "How many users are awarded with more than 5 badges?",
        "original_query": "SELECT UserId FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "llm_output": "-- Reasoning\nI need to count the number of badges for each user from the `badges` table.\nThen, I will filter these users to include only those who have received more than 5 badges using a HAVING clause.\nFinally, I will count the distinct users that meet this criteria.\n\n-- SQL Query\nSELECT COUNT(T1.UserId) FROM (SELECT UserId FROM badges GROUP BY UserId HAVING COUNT(Id) > 5) AS T1;",
        "pred_query": "SELECT COUNT(T1.UserId) FROM (SELECT UserId FROM badges GROUP BY UserId HAVING COUNT(Id) > 5) AS T1;",
        "pred_time": 0.028713703155517578,
        "orig_time": 0.03214740753173828,
        "time_ratio": 1.119584170583058,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "original_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "llm_output": "-- Reasoning\nI need to retrieve the `Title` from the `posts` table.\nThe condition is based on the `DisplayName` of the user who last edited the post.\nI will join `posts` with `users` on `posts.LastEditorUserId = users.Id` and filter by `users.DisplayName = 'Vebjosa Ljosa'`.\n\n-- SQL Query\nSELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_time": 0.1666247844696045,
        "orig_time": 0.21228957176208496,
        "time_ratio": 1.2740575925594706,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What percentage of cards without power are in French?",
        "original_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power LIKE '%*%'",
        "llm_output": "\nSELECT\n  CAST(COUNT(DISTINCT CASE WHEN T2.language = 'French' THEN T1.uuid ELSE NULL END) AS REAL) * 100\n  / COUNT(DISTINCT T1.uuid)\nFROM cards AS T1\nLEFT JOIN foreign_data AS T2\n  ON T1.uuid = T2.uuid\nWHERE T1.power IS NULL;\n",
        "pred_query": "SELECT\n  CAST(COUNT(DISTINCT CASE WHEN T2.language = 'French' THEN T1.uuid ELSE NULL END) AS REAL) * 100\n  / COUNT(DISTINCT T1.uuid)\nFROM cards AS T1\nLEFT JOIN foreign_data AS T2\n  ON T1.uuid = T2.uuid\nWHERE T1.power IS NULL;",
        "pred_time": 0.9363882541656494,
        "orig_time": 0.28978729248046875,
        "time_ratio": 0.3094734381719451,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "original_query": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "llm_output": "SELECT DISTINCT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high';",
        "pred_query": "SELECT DISTINCT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high';",
        "pred_time": 0.08144736289978027,
        "orig_time": 0.0794374942779541,
        "time_ratio": 0.9753230976391551,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "llm_output": "-- Reasoning\nI need to find members who attended a specific event.\nFirst, I will filter the `event` table for the event named 'Laugh Out Loud'.\nThen, I will join `event` with `attendance` to link events to attendees.\nFinally, I will join `attendance` with `member` to get the details of the attendees and select their full names.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud';",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud';",
        "pred_time": 0.0009186267852783203,
        "orig_time": 0.0006313323974609375,
        "time_ratio": 0.6872566831040747,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "llm_output": "\nSELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'\n",
        "pred_query": "SELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'",
        "pred_time": 0.06888127326965332,
        "orig_time": 0.06119656562805176,
        "time_ratio": 0.8884354589161293,
        "check": true
    },
    {
        "id": "card_games",
        "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
        "llm_output": "\nSELECT COUNT(id)\nFROM cards\nWHERE\n    (colors IS NOT NULL AND colors != '') AND\n    (borderColor IS NULL OR borderColor = '') AND\n    (edhrecRank IS NOT NULL AND edhrecRank < 12000);\n",
        "pred_query": "SELECT COUNT(id)\nFROM cards\nWHERE\n    (colors IS NOT NULL AND colors != '') AND\n    (borderColor IS NULL OR borderColor = '') AND\n    (edhrecRank IS NOT NULL AND edhrecRank < 12000);",
        "pred_time": 0.06239056587219238,
        "orig_time": 0.057370662689208984,
        "time_ratio": 0.9195406691250931,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Calculate the average height of all neutral superheroes.",
        "original_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `alignment` table to filter superheroes based on their alignment.\nThen, I will filter for rows where the `alignment` is 'Neutral'.\nFinally, I will calculate the average of the `height_cm` from the `superhero` table for the filtered results.\n\n-- SQL Query\nSELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_time": 0.0010085105895996094,
        "orig_time": 0.0006072521209716797,
        "time_ratio": 0.6021276595744681,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the date when the youngest user made his or her first post?",
        "original_query": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "llm_output": "-- Reasoning\nFirst, find the minimum age from the users table.\nThen, identify the user(s) with this minimum age.\nFinally, for these youngest user(s), find the earliest post creation date from the posts table.\n\n\nSELECT MIN(T2.CreaionDate)\nFROM users AS T1\nINNER JOIN posts AS T2\n  ON T1.Id = T2.OwnerUserId\nWHERE\n  T1.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );\n",
        "pred_query": "SELECT MIN(T2.CreaionDate)\nFROM users AS T1\nINNER JOIN posts AS T2\n  ON T1.Id = T2.OwnerUserId\nWHERE\n  T1.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );",
        "pred_time": 0.2310938835144043,
        "orig_time": 0.2593648433685303,
        "time_ratio": 1.1223353877834843,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
        "original_query": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "llm_output": "\nSELECT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL\n",
        "pred_query": "SELECT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "pred_time": 0.08222842216491699,
        "orig_time": 0.09482598304748535,
        "time_ratio": 1.1532020261473914,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
        "llm_output": "-- Reasoning\nI need to retrieve information from the Patient table based on a condition in the Laboratory table.\nThis requires joining the Patient and Laboratory tables using their common ID column.\nThen, I will filter the results where the 'ALB' column in the Laboratory table is less than 3.5.\nFinally, I will select the 'ID', 'SEX', and 'Diagnosis' columns from the Patient table.\n\n-- SQL Query\nSELECT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5;",
        "pred_query": "SELECT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5;",
        "pred_time": 0.005098581314086914,
        "orig_time": 0.0033292770385742188,
        "time_ratio": 0.6529810614916998,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Which foot is preferred by Abdou Diallo?",
        "original_query": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "llm_output": "-- Reasoning\nI need to find the `preferred_foot` for a player given their name.\nFirst, I will find the `player_api_id` for 'Abdou Diallo' from the `Player` table.\nThen, I will join `Player` with `Player_Attributes` on `player_api_id` and filter by the player's name to get the `preferred_foot`.\n\n-- SQL Query\nSELECT T2.preferred_foot FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Abdou Diallo' LIMIT 1;",
        "pred_query": "SELECT T2.preferred_foot FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Abdou Diallo' LIMIT 1;",
        "pred_time": 0.0014140605926513672,
        "orig_time": 0.1061394214630127,
        "time_ratio": 75.0600236047884,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "original_query": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "llm_output": "-- Reasoning\nI need to count the number of 'Discount' gas stations in the Czech Republic and Slovakia separately.\nThen, I will subtract the count of Slovakian 'Discount' gas stations from the count of Czech 'Discount' gas stations.\nThis can be achieved by filtering the `gasstations` table for `Segment = 'Discount'` and then conditionally summing counts based on `Country`.\n\n-- SQL Query\nSELECT\n  SUM(CASE WHEN Country = 'CZE' THEN 1 ELSE 0 END) - SUM(CASE WHEN Country = 'SVK' THEN 1 ELSE 0 END)\nFROM gasstations\nWHERE\n  Segment = 'Discount';",
        "pred_query": "SELECT\n  SUM(CASE WHEN Country = 'CZE' THEN 1 ELSE 0 END) - SUM(CASE WHEN Country = 'SVK' THEN 1 ELSE 0 END)\nFROM gasstations\nWHERE\n  Segment = 'Discount';",
        "pred_time": 0.001832723617553711,
        "orig_time": 0.0008080005645751953,
        "time_ratio": 0.44087420320020815,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "original_query": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 933 ORDER BY T2.fastestLapSpeed DESC LIMIT 1;",
        "pred_query": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 933 ORDER BY T2.fastestLapSpeed DESC LIMIT 1;",
        "pred_time": 0.0028541088104248047,
        "orig_time": 0.0019440650939941406,
        "time_ratio": 0.6811461030824493,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "llm_output": "-- Reasoning\nI need to retrieve superhero names from the `superhero` table.\nTo filter by eye color and hair color, I need to join the `superhero` table with the `colour` table twice, once for `eye_colour_id` and once for `hair_colour_id`.\nThen, I will apply conditions to select 'Blue' for eye color and 'Blond' for hair color.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_time": 0.001299142837524414,
        "orig_time": 0.0008840560913085938,
        "time_ratio": 0.6804918333639199,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What is the highest amount of budget spend for an event?",
        "original_query": "SELECT MAX(spent) FROM budget",
        "llm_output": "-- Reasoning\nTo find the highest amount of budget spent, I need to look at the 'budget' table.\nThe 'spent' column in the 'budget' table contains the amount spent.\nI will use the MAX aggregate function on the 'spent' column.\n\n-- SQL Query\nSELECT MAX(spent) FROM budget;",
        "pred_query": "SELECT MAX(spent) FROM budget;",
        "pred_time": 0.0009267330169677734,
        "orig_time": 0.0005319118499755859,
        "time_ratio": 0.5739644970414202,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the owner's display name of the most popular post?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "llm_output": "-- Reasoning\nTo find the most popular post, we should look for the post with the highest 'Score' in the 'posts' table.\nOnce we identify this post, we need its 'OwnerUserId'.\nFinally, we join with the 'users' table using 'OwnerUserId' to retrieve the corresponding 'DisplayName'.\n\n-- SQL Query\nSELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.Score DESC LIMIT 1;",
        "pred_query": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.Score DESC LIMIT 1;",
        "pred_time": 0.18825030326843262,
        "orig_time": 0.11040186882019043,
        "time_ratio": 0.5864631658136804,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "original_query": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to first filter the `Laboratory` table by the specified date range to find relevant patient IDs.\nThen, I will join these patient IDs with the `Patient` table to retrieve their diagnoses.\nFinally, I will count the occurrences of each diagnosis and select the one with the highest count.\n\n-- SQL Query\nSELECT T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.Date BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY\n  T1.Diagnosis\nORDER BY\n  COUNT(T1.Diagnosis) DESC\nLIMIT 1;",
        "pred_query": "SELECT T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.Date BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY\n  T1.Diagnosis\nORDER BY\n  COUNT(T1.Diagnosis) DESC\nLIMIT 1;",
        "pred_time": 0.004639863967895508,
        "orig_time": 0.0008587837219238281,
        "time_ratio": 0.1850881249678845,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "original_query": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find posts created in 2010.\nFrom these posts, I will identify the one with the highest FavoriteCount, indicating \"most valuable\".\nFinally, I will retrieve its Id and the DisplayName of its owner by joining with the users table.\n\n-- SQL Query\nSELECT T1.Id, T2.DisplayName\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  STRFTIME('%Y', T1.CreaionDate) = '2010'\nORDER BY\n  T1.FavoriteCount DESC\nLIMIT 1;",
        "pred_query": "SELECT T1.Id, T2.DisplayName\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  STRFTIME('%Y', T1.CreaionDate) = '2010'\nORDER BY\n  T1.FavoriteCount DESC\nLIMIT 1;",
        "pred_time": 0.13085436820983887,
        "orig_time": 0.2333519458770752,
        "time_ratio": 1.7832950406582575,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "llm_output": "-- Reasoning\nThe question asks for card names from a specific set identified by its translated name.\nI need to first find the `setCode` from the `set_translations` table using the given `translation`.\nThen, I will join this `setCode` with the `cards` table to retrieve the `name` of the cards.\n\n-- SQL Query\nSELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition';",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition';",
        "pred_time": 0.11284470558166504,
        "orig_time": 0.10111474990844727,
        "time_ratio": 0.8960522284784652,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What is the carcinogenic label for bond TR001_2_4?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
        "llm_output": "-- Reasoning\nTo find the carcinogenic label for a given bond, I need to link the `bond` table to the `molecule` table.\nThe `bond` table contains `bond_id` and `molecule_id`.\nThe `molecule` table contains `molecule_id` and `label`.\nI will join these two tables on `molecule_id` and then filter by the specific `bond_id` 'TR001_2_4' to retrieve the `label`.\n\n-- SQL Query\nSELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_query": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_time": 0.0007915496826171875,
        "orig_time": 0.0013034343719482422,
        "time_ratio": 1.6466867469879518,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "original_query": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "llm_output": "\nSELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.date, 1, 10) = '2015-09-10';\n",
        "pred_query": "SELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.date, 1, 10) = '2015-09-10';",
        "pred_time": 0.0017576217651367188,
        "orig_time": 0.001392364501953125,
        "time_ratio": 0.7921866521975041,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many positive comments are there on the list?",
        "original_query": "SELECT COUNT(id) FROM comments WHERE score > 60",
        "llm_output": "-- Reasoning\nI need to count the number of comments.\nA \"positive comment\" can be interpreted as a comment with a Score greater than 0.\nI will query the `comments` table and filter by `Score > 0`.\n\n-- SQL Query\nSELECT COUNT(Id) FROM comments WHERE Score > 0;",
        "pred_query": "SELECT COUNT(Id) FROM comments WHERE Score > 0;",
        "pred_time": 0.052902936935424805,
        "orig_time": 0.048248291015625,
        "time_ratio": 0.9120153588924291,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 10?",
        "original_query": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 10 AND T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the `sets` table with the `set_translations` table.\nI will filter the `set_translations` table for `language = 'Italian'` to find sets with Italian translations.\nAdditionally, I will filter the `sets` table for `baseSetSize < 10`.\nFinally, I will count the distinct set codes that satisfy both conditions.\n\nSELECT COUNT(DISTINCT T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_query": "SELECT COUNT(DISTINCT T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_time": 0.0041844844818115234,
        "orig_time": 0.004465579986572266,
        "time_ratio": 1.0671756595065809,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were adult?",
        "original_query": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "llm_output": "-- Reasoning\nTo find the number of adult users, I need to filter the `users` table by the `Age` column.\nAn adult is generally considered to be 18 years or older.\nI will count the number of users where `Age` is greater than or equal to 18.\n\nSELECT COUNT(Id) FROM users WHERE Age >= 18;",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Age >= 18;",
        "pred_time": 0.010535955429077148,
        "orig_time": 0.00845193862915039,
        "time_ratio": 0.8021995428933493,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "original_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `cards` table with the `sets` table to filter by set name.\nThen, I will filter for records where `sets.name` is 'Coldsnap'.\nAfter filtering, I need to find the maximum `convertedManaCost` among these cards.\nFinally, I will select the `name` of all cards that have this maximum `convertedManaCost` within the 'Coldsnap' set.\n\n-- SQL Query\nSELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1;",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1;",
        "pred_time": 0.07334518432617188,
        "orig_time": 0.06906604766845703,
        "time_ratio": 0.941657564882717,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "original_query": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "llm_output": "SELECT T1.name, T1.District FROM (SELECT AdmFName1 AS name, District, COUNT(*) AS name_count FROM schools WHERE AdmFName1 IS NOT NULL GROUP BY AdmFName1, District UNION ALL SELECT AdmFName2 AS name, District, COUNT(*) AS name_count FROM schools WHERE AdmFName2 IS NOT NULL GROUP BY AdmFName2, District UNION ALL SELECT AdmFName3 AS name, District, COUNT(*) AS name_count FROM schools WHERE AdmFName3 IS NOT NULL GROUP BY AdmFName3, District) AS T1 GROUP BY T1.name, T1.District ORDER BY SUM(T1.name_count) DESC LIMIT 2;",
        "pred_query": "SELECT T1.name, T1.District FROM (SELECT AdmFName1 AS name, District, COUNT(*) AS name_count FROM schools WHERE AdmFName1 IS NOT NULL GROUP BY AdmFName1, District UNION ALL SELECT AdmFName2 AS name, District, COUNT(*) AS name_count FROM schools WHERE AdmFName2 IS NOT NULL GROUP BY AdmFName2, District UNION ALL SELECT AdmFName3 AS name, District, COUNT(*) AS name_count FROM schools WHERE AdmFName3 IS NOT NULL GROUP BY AdmFName3, District) AS T1 GROUP BY T1.name, T1.District ORDER BY SUM(T1.name_count) DESC LIMIT 2;",
        "pred_time": 0.03524518013000488,
        "orig_time": 0.029191017150878906,
        "time_ratio": 0.8282272084638332,
        "check": false
    },
    {
        "id": "financial",
        "question": "List the top ten districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "original_query": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 10",
        "llm_output": "-- Reasoning\nTo find the top ten districts by the number of female account holders, we need to join the `client` table (to filter by gender and get client ID and district ID) with the `disp` table (to ensure they are account holders) and then with the `district` table (to group by district). We will count the distinct female clients for each district, order the results in descending order, and limit to the top 10.\n\n-- SQL Query\nSELECT T1.district_id\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nWHERE\n  T1.gender = 'F'\nGROUP BY\n  T1.district_id\nORDER BY\n  COUNT(T1.client_id) DESC\nLIMIT 10;",
        "pred_query": "SELECT T1.district_id\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nWHERE\n  T1.gender = 'F'\nGROUP BY\n  T1.district_id\nORDER BY\n  COUNT(T1.client_id) DESC\nLIMIT 10;",
        "pred_time": 0.002367258071899414,
        "orig_time": 0.0019311904907226562,
        "time_ratio": 0.8157921240809749,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01'",
        "llm_output": "-- Reasoning\nThe question asks for the number of patients.\nPatients are identified by their `ID` in the `Patient` table.\nThe condition \"normal Ig A level\" refers to the `IGA` column in the `Laboratory` table. Since no specific range for \"normal\" Ig A is provided, we will assume `IGA IS NOT NULL` for this condition.\nThe condition \"came to the hospital after 1990/1/1\" refers to the `First Date` column in the `Patient` table.\nWe need to join the `Patient` and `Laboratory` tables on `ID` to combine these conditions and then count distinct patient IDs.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA IS NOT NULL AND T1.`First Date` > '1990-01-01';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA IS NOT NULL AND T1.`First Date` > '1990-01-01';",
        "pred_time": 0.004483461380004883,
        "orig_time": 0.003899097442626953,
        "time_ratio": 0.8696623238500398,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "original_query": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "llm_output": "\nSELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.country NOT IN ('Asia', 'Europe');\n",
        "pred_query": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.country NOT IN ('Asia', 'Europe');",
        "pred_time": 0.0011243820190429688,
        "orig_time": 0.0008096694946289062,
        "time_ratio": 0.7201017811704835,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "original_query": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "llm_output": "\nSELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'Spanish' AND STRFTIME('%Y', T1.dob) < '1982'\nGROUP BY\n  T1.driverId,\n  T1.forename,\n  T1.surname\nORDER BY\n  MAX(T2.milliseconds) DESC\nLIMIT 10;\n",
        "pred_query": "SELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'Spanish' AND STRFTIME('%Y', T1.dob) < '1982'\nGROUP BY\n  T1.driverId,\n  T1.forename,\n  T1.surname\nORDER BY\n  MAX(T2.milliseconds) DESC\nLIMIT 10;",
        "pred_time": 0.05753660202026367,
        "orig_time": 0.0016522407531738281,
        "time_ratio": 0.028716342209293654,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "llm_output": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "pred_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "pred_time": 0.17392539978027344,
        "orig_time": 0.17576265335083008,
        "time_ratio": 1.0105634575103908,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Which customer paid the most in 2012/8/25?",
        "original_query": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the customer who paid the most on a specific date, I need to filter the `transactions_1k` table by the given date.\nThen, I will group the transactions by `CustomerID` and sum the `Price` for each customer.\nFinally, I will order the results by the total `Price` in descending order and select the top customer.\n\n-- SQL Query\nSELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1;",
        "pred_query": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1;",
        "pred_time": 0.00102996826171875,
        "orig_time": 0.0007359981536865234,
        "time_ratio": 0.7145833333333333,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with severe thrombosis have a normal prothrombin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.PT < 14 AND T3.Thrombosis < 3 AND T3.Thrombosis > 0",
        "llm_output": "-- Reasoning\nThe question asks for the count of patients with \"severe thrombosis\" and \"normal prothrombin time\".\n1.  From the few-shot examples, \"normal prothrombin time\" is defined by `PT < 14`. This condition will be applied to the `Laboratory` table.\n2.  From the few-shot examples, \"mild thrombosis\" is defined by `Thrombosis = 3`. Given this, and common medical ordinal scales where lower numbers often indicate higher severity (e.g., 1=severe, 2=moderate, 3=mild), it is a reasonable inference that \"severe thrombosis\" corresponds to `Thrombosis = 1` in the `Examination` table.\n3.  To count unique patients satisfying both conditions, we need to join the `Patient`, `Examination`, and `Laboratory` tables on their common `ID` column and then apply the filters.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Examination AS T2\n  ON T1.ID = T2.ID\nINNER JOIN Laboratory AS T3\n  ON T1.ID = T3.ID\nWHERE T2.Thrombosis = 1 AND T3.PT < 14;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Examination AS T2\n  ON T1.ID = T2.ID\nINNER JOIN Laboratory AS T3\n  ON T1.ID = T3.ID\nWHERE T2.Thrombosis = 1 AND T3.PT < 14;",
        "pred_time": 0.0014562606811523438,
        "orig_time": 0.0009980201721191406,
        "time_ratio": 0.6853307138179436,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "original_query": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "llm_output": "-- Reasoning\nI need to retrieve the `last_name` from the `member` table.\nTo filter by major, I need to join the `member` table with the `major` table using `link_to_major` and `major_id`.\nThen, I will apply a WHERE clause to select only those records where `major_name` is 'Law and Constitutional Studies'.\n\n-- SQL Query\nSELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';",
        "pred_query": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';",
        "pred_time": 0.0009999275207519531,
        "orig_time": 0.0005154609680175781,
        "time_ratio": 0.5154983309489747,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the average loan amount by male borrowers?",
        "original_query": "SELECT AVG(T3.amount) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M'",
        "llm_output": "-- Reasoning\nTo find the average loan amount by male borrowers, I need to join the `loan` table with the `disp` table to link accounts to clients, and then join with the `client` table to filter by gender.\nI will filter for 'M' gender and then calculate the average of the `amount` column from the `loan` table.\nThe `account` table is implicitly linked by `disp` and `loan` but not strictly needed for this specific query as `disp` already links `account_id` and `client_id`.\n\n-- SQL Query\nSELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.gender = 'M';",
        "pred_query": "SELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.gender = 'M';",
        "pred_time": 0.002987384796142578,
        "orig_time": 0.006666421890258789,
        "time_ratio": 2.2315243415802075,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "List out of players whose preferred foot is left.",
        "original_query": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "llm_output": "-- Reasoning\nTo find players whose preferred foot is left, I need to join the `Player` table with the `Player_Attributes` table.\nThe join condition will be `Player.player_api_id = Player_Attributes.player_api_id`.\nThen, I will filter the results where the `preferred_foot` column in `Player_Attributes` is 'left'.\nFinally, I will select the `player_name` from the `Player` table.\n\n-- SQL Query\nSELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot = 'left';",
        "pred_query": "SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot = 'left';",
        "pred_time": 0.10252690315246582,
        "orig_time": 0.09485030174255371,
        "time_ratio": 0.9251259798757758,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many white bordered cards are powerful?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "llm_output": "-- Reasoning\nThe question asks for \"white bordered cards\" which translates to `borderColor = 'white'`.\nFor \"powerful\", we need to interpret the `power` column (TEXT type).\nBased on the few-shot example, `power LIKE '%*%'` is considered part of \"unknown power\", so powerful cards should exclude this.\nAlso, `power IS NULL` is unknown, so powerful cards must have a non-NULL power.\nLastly, a \"powerful\" card should have a positive power value. Given `power` is TEXT, `CAST(power AS INTEGER) > 0` is a robust way to filter for strictly positive numerical power, while also implicitly excluding '0', 'X', and other non-numeric strings that `CAST` to `0` in SQLite.\n\n-- SQL Query\nSELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND power IS NOT NULL AND power NOT LIKE '%*%' AND CAST(power AS INTEGER) > 0;",
        "pred_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND power IS NOT NULL AND power NOT LIKE '%*%' AND CAST(power AS INTEGER) > 0;",
        "pred_time": 0.06795334815979004,
        "orig_time": 0.06124401092529297,
        "time_ratio": 0.9012655385468236,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
        "original_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
        "llm_output": "-- Reasoning\nTo answer the question, I need to retrieve information from the `member` table.\nThe hometown information (city, state, zip code) is stored in the `zip_code` table.\nI will join `member` and `zip_code` tables on their common zip code columns.\nThen I will filter the results by city, state, and zip code and select the `first_name`, `last_name`, and `position` of the members.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.short_state = 'NC' AND T1.zip = 28092;",
        "pred_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.short_state = 'NC' AND T1.zip = 28092;",
        "pred_time": 0.0007967948913574219,
        "orig_time": 0.00045228004455566406,
        "time_ratio": 0.5676241771394375,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Give the eye colour of Blackwulf.",
        "original_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf'",
        "llm_output": "-- Reasoning\nTo find the eye colour of 'Blackwulf', I need to join the `superhero` table with the `colour` table.\nThe join condition will be `superhero.eye_colour_id = colour.id`.\nFinally, I will filter the results where `superhero.superhero_name` is 'Blackwulf' and select the `colour` name.\n\n-- SQL Query\nSELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_time": 0.0007877349853515625,
        "orig_time": 0.0004711151123046875,
        "time_ratio": 0.5980629539951574,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal anti-SSA came to the hospital before 1990?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '1990'",
        "llm_output": "-- Reasoning\nI need to count distinct patients.\nPatients are defined by their `ID` in the `Patient` table.\nA patient has a \"normal anti-SSA\" if the `SSA` value in the `Laboratory` table is 'negative' or '0'.\nThe condition \"came to the hospital before 1990\" refers to the `First Date` in the `Patient` table being before '1990-01-01'.\nI will join `Patient` and `Laboratory` tables on `ID` to apply both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.SSA = 'negative' OR T2.SSA = '0') AND T1.`First Date` < '1990-01-01';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.SSA = 'negative' OR T2.SSA = '0') AND T1.`First Date` < '1990-01-01';",
        "pred_time": 0.0023093223571777344,
        "orig_time": 0.003935575485229492,
        "time_ratio": 1.7042122651249225,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "State the racing year which has the fastest lap time?",
        "original_query": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "llm_output": "-- Reasoning\nTo find the racing year with the fastest lap time, I need to look at the `lapTimes` table, which stores the duration of each lap in milliseconds.\nI will join the `lapTimes` table with the `races` table on `raceId` to get the year of the race.\nThen I will order the results by `milliseconds` in ascending order to find the fastest lap and select the corresponding year.\n\n-- SQL Query\nSELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId ORDER BY T1.milliseconds ASC LIMIT 1;",
        "pred_query": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId ORDER BY T1.milliseconds ASC LIMIT 1;",
        "pred_time": 0.04036712646484375,
        "orig_time": 0.004393815994262695,
        "time_ratio": 0.10884639009639009,
        "check": false
    },
    {
        "id": "superhero",
        "question": "How many green-skinned villains are there in the superhero universe?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "llm_output": "-- Reasoning\nI need to count superheroes that have 'Green' skin and an 'alignment' of 'Bad'.\nI will join `superhero` with `colour` on `skin_colour_id` and `alignment` on `alignment_id`.\nThen, I will filter the results based on the skin colour being 'Green' and the alignment being 'Bad'.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_time": 0.0013051033020019531,
        "orig_time": 0.000705718994140625,
        "time_ratio": 0.5407380343441724,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "original_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the maximum `overall_rating` from the `Player_Attributes` table.\nThen, I need to retrieve the `player_api_id` corresponding to this maximum rating.\nI will order the results by `overall_rating` in descending order and limit to 1 to get the player with the highest rating.\n\n-- SQL Query\nSELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "pred_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "pred_time": 0.0832984447479248,
        "orig_time": 0.09466671943664551,
        "time_ratio": 1.1364764339012934,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "original_query": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to query the `event` table.\nI will filter the events based on three conditions: `status` is 'closed', `type` is 'game', and `event_date` falls within the specified date range.\nThe `event_date` column is of type TEXT, so I will extract the date part using `SUBSTR` and convert it to a date for comparison.\n\n-- SQL Query\nSELECT event_name FROM event WHERE status = 'closed' AND type = 'game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_query": "SELECT event_name FROM event WHERE status = 'closed' AND type = 'game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_time": 0.0007469654083251953,
        "orig_time": 0.00048828125,
        "time_ratio": 0.6536865624002554,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List down top 5 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "original_query": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 5",
        "llm_output": "-- Reasoning\nI need to join the `drivers` table with the `pitStops` table to get driver information and pit stop durations.\nI will filter drivers by nationality 'German' and a birth year between 1980 and 1985.\nThen, I will calculate the average of `milliseconds` for pit stops for each driver.\nFinally, I will order the results by this average in ascending order and limit to the top 5.\n\nSELECT\n  T1.driverRef\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds)\nLIMIT 5;",
        "pred_query": "SELECT\n  T1.driverRef\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds)\nLIMIT 5;",
        "pred_time": 0.002109527587890625,
        "orig_time": 0.0018732547760009766,
        "time_ratio": 0.887997287522604,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "original_query": "SELECT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "llm_output": "\nSELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00';\n",
        "pred_query": "SELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00';",
        "pred_time": 0.0019299983978271484,
        "orig_time": 0.0010139942169189453,
        "time_ratio": 0.5253860407659049,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Count the fastest superheroes.",
        "original_query": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' ORDER BY T1.attribute_value DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the fastest superheroes, I need to identify the attribute that represents speed. This information is likely stored in the `attribute` table, with the actual speed values in `hero_attribute`.\nI will first find the `attribute_id` for 'Speed' from the `attribute` table.\nThen, I will find the maximum `attribute_value` associated with this 'Speed' attribute in the `hero_attribute` table.\nFinally, I will count the number of superheroes (`hero_id`) in `hero_attribute` who possess this maximum 'Speed' `attribute_value`.\n\n-- SQL Query\nSELECT\n  COUNT(T1.hero_id)\nFROM hero_attribute AS T1\nINNER JOIN attribute AS T2\n  ON T1.attribute_id = T2.id\nWHERE\n  T2.attribute_name = 'Speed' AND T1.attribute_value = (\n    SELECT\n      MAX(T3.attribute_value)\n    FROM hero_attribute AS T3\n    INNER JOIN attribute AS T4\n      ON T3.attribute_id = T4.id\n    WHERE\n      T4.attribute_name = 'Speed'\n  );",
        "pred_query": "SELECT\n  COUNT(T1.hero_id)\nFROM hero_attribute AS T1\nINNER JOIN attribute AS T2\n  ON T1.attribute_id = T2.id\nWHERE\n  T2.attribute_name = 'Speed' AND T1.attribute_value = (\n    SELECT\n      MAX(T3.attribute_value)\n    FROM hero_attribute AS T3\n    INNER JOIN attribute AS T4\n      ON T3.attribute_id = T4.id\n    WHERE\n      T4.attribute_name = 'Speed'\n  );",
        "pred_time": 0.002233266830444336,
        "orig_time": 0.000762939453125,
        "time_ratio": 0.3416248532080709,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "original_query": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "llm_output": "-- Reasoning\nThe user wants to retrieve the frame style and name for all cards illustrated by 'Allen Williams'.\nAdditionally, for each of these cards, the query must indicate whether the card is banned in any format.\nI will join `cards` with `legalities` using a `LEFT JOIN` or use an `EXISTS` subquery to determine the banned status.\nAn `EXISTS` subquery is suitable here to check for the presence of a 'Banned' status for a card's UUID.\n\n-- SQL Query\nSELECT\n  T1.frameVersion,\n  T1.name,\n  CASE\n    WHEN EXISTS (\n      SELECT\n        1\n      FROM legalities AS T2\n      WHERE\n        T1.uuid = T2.uuid AND T2.status = 'Banned'\n    )\n    THEN 'Banned'\n    ELSE 'Not Banned'\n  END AS BannedStatus\nFROM cards AS T1\nWHERE\n  T1.artist = 'Allen Williams';",
        "pred_query": "SELECT\n  T1.frameVersion,\n  T1.name,\n  CASE\n    WHEN EXISTS (\n      SELECT\n        1\n      FROM legalities AS T2\n      WHERE\n        T1.uuid = T2.uuid AND T2.status = 'Banned'\n    )\n    THEN 'Banned'\n    ELSE 'Not Banned'\n  END AS BannedStatus\nFROM cards AS T1\nWHERE\n  T1.artist = 'Allen Williams';",
        "pred_time": 6.564704418182373,
        "orig_time": 0.39497995376586914,
        "time_ratio": 0.06016721067773995,
        "check": false
    },
    {
        "id": "student_club",
        "question": "State the name of major that Phillip Cullen has joined.",
        "original_query": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "llm_output": "-- Reasoning\nTo find the major name of Phillip Cullen, I need to join the `member` table with the `major` table.\nThe `member` table contains the `first_name`, `last_name`, and `link_to_major`.\nThe `major` table contains the `major_id` and `major_name`.\nI will link these two tables on `member.link_to_major = major.major_id` and filter by the member's name.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_time": 0.0007526874542236328,
        "orig_time": 0.00044035911560058594,
        "time_ratio": 0.5850490972442192,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
        "original_query": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
        "llm_output": "-- Reasoning\nThe question asks for the number of crimes in 1995 for a specific account's district.\nI need to first find the `district_id` for `account_id` 532 from the `account` table.\nThen, I will use this `district_id` to query the `district` table and retrieve the value from column `A15`, which represents crimes committed in 1995 based on the few-shot examples.\n\n-- SQL Query\nSELECT T2.A15 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.account_id = 532;",
        "pred_query": "SELECT T2.A15 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.account_id = 532;",
        "pred_time": 0.0008356571197509766,
        "orig_time": 0.0004913806915283203,
        "time_ratio": 0.5880171184022824,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "llm_output": "\nSELECT\n  T1.ID,\n  T1.SEX,\n  T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.LDH IS NOT NULL AND (\n    T2.LDH < 140 OR T2.LDH > 280\n  );\n",
        "pred_query": "SELECT\n  T1.ID,\n  T1.SEX,\n  T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.LDH IS NOT NULL AND (\n    T2.LDH < 140 OR T2.LDH > 280\n  );",
        "pred_time": 0.009168386459350586,
        "orig_time": 0.003414154052734375,
        "time_ratio": 0.3723833051618775,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "original_query": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "llm_output": "-- Reasoning\nThe question asks for bond IDs that share the same 'atom_id2' as the bond 'TR000_2'.\nFirst, we need to find the 'atom_id2' associated with 'TR000_2' from the 'connected' table.\nThen, we select all 'bond_id's from the 'connected' table where 'atom_id2' matches the one found in the previous step, ensuring to exclude 'TR000_2' itself from the result.\n\n-- SQL Query\nSELECT T1.bond_id\nFROM connected AS T1\nWHERE T1.atom_id2 = (\n    SELECT T2.atom_id2\n    FROM connected AS T2\n    WHERE T2.bond_id = 'TR000_2'\n) AND T1.bond_id != 'TR000_2';",
        "pred_query": "SELECT T1.bond_id\nFROM connected AS T1\nWHERE T1.atom_id2 = (\n    SELECT T2.atom_id2\n    FROM connected AS T2\n    WHERE T2.bond_id = 'TR000_2'\n) AND T1.bond_id != 'TR000_2';",
        "pred_time": 0.0038313865661621094,
        "orig_time": 0.0023038387298583984,
        "time_ratio": 0.60130678282514,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "original_query": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "llm_output": "-- Reasoning\nTo answer the question, we need to join the `frpm` table with the `schools` table on their common `CDSCode`.\nThen, we will filter the results to find schools where any of the administrator's first names (`AdmFName1`, `AdmFName2`, `AdmFName3`) is 'Alusine'.\nFinally, we will select the `Percent (%) Eligible Free (K-12)` and `District Code` from the `frpm` table for these filtered schools.\n\n-- SQL Query\nSELECT T1.`Percent (%) Eligible Free (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine' OR T2.AdmFName2 = 'Alusine' OR T2.AdmFName3 = 'Alusine';",
        "pred_query": "SELECT T1.`Percent (%) Eligible Free (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine' OR T2.AdmFName2 = 'Alusine' OR T2.AdmFName3 = 'Alusine';",
        "pred_time": 0.014690160751342773,
        "orig_time": 0.00942230224609375,
        "time_ratio": 0.6414022559441694,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "original_query": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "llm_output": "-- Reasoning\nTo find information about races at Silverstone Circuit, I need to join the `races` table with the `circuits` table.\nI will filter the `circuits` table for the name 'Silverstone Circuit'.\nThen, I will select all columns from the `races` table to provide \"more information\" about these races.\n\n-- SQL Query\nSELECT T2.* FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Silverstone Circuit';",
        "pred_query": "SELECT T2.* FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Silverstone Circuit';",
        "pred_time": 0.0012390613555908203,
        "orig_time": 0.0008342266082763672,
        "time_ratio": 0.673273042139696,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Give the only one comment text of the post with parent id 107829.",
        "original_query": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "llm_output": "-- Reasoning\nI need to find the `PostId` from the `posts` table where the `ParentId` is `107829`.\nThen, I will use this `PostId` to filter the `comments` table and retrieve the `Text`.\nA subquery can be used to get the `PostId` first, and then the main query selects the comment text.\n\n-- SQL Query\nSELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ParentId = 107829;",
        "pred_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ParentId = 107829;",
        "pred_time": 0.2196345329284668,
        "orig_time": 0.21987342834472656,
        "time_ratio": 1.0010876951500953,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
        "original_query": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
        "llm_output": "-- Reasoning\nTo find the Italian name of the set, I need to first identify the set code for the card \"Ancestor's Chosen\" from the 'cards' table.\nThen, I will use this set code to look up the corresponding Italian translation in the 'set_translations' table.\nThis requires joining 'cards' and 'set_translations' tables on `setCode`.\n\n-- SQL Query\nSELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "pred_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "pred_time": 0.07152557373046875,
        "orig_time": 0.06599640846252441,
        "time_ratio": 0.9226966666666667,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many translations of the name of the set \"Salvat 2011\"?",
        "original_query": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Salvat 2011' AND T2.translation IS NOT NULL",
        "llm_output": "-- Reasoning\nTo find the number of translations, I need to first locate the 'setCode' for the set \"Salvat 2011\" in the 'sets' table.\nThen, I will query the 'set_translations' table using this 'setCode' and count the distinct translations associated with it.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.name = 'Salvat 2011';",
        "pred_query": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.name = 'Salvat 2011';",
        "pred_time": 0.010662555694580078,
        "orig_time": 0.0044460296630859375,
        "time_ratio": 0.41697598497383837,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "original_query": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
        "llm_output": "-- Reasoning\nI need to find members who attended a specific event and have a particular t-shirt size.\n1. Identify the `event_id` for the event \"Women's Soccer\" from the `event` table.\n2. Join `event` with `attendance` on `event_id` to find members who attended this event.\n3. Join the result with the `member` table on `member_id`.\n4. Filter these members by `t_shirt_size = 'Medium'`.\n5. Count the distinct `member_id`s.\n\n-- SQL Query\nSELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';",
        "pred_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';",
        "pred_time": 0.0016644001007080078,
        "orig_time": 0.0008637905120849609,
        "time_ratio": 0.518980088812491,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "original_query": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "llm_output": "-- Reasoning\nThe query needs to calculate the average of `A15` (crimes in 1995) from the `district` table.\nThe `district` must satisfy two conditions:\n1. The number of crimes in 1995 (`A15`) must be greater than 4000.\n2. The `district` must have at least one associated `account` that was opened in 1997 or later. This can be checked by joining `district` with `account` or using an `EXISTS` subquery and filtering on the `date` column of the `account` table.\n\n-- SQL Query\nSELECT AVG(T1.A15) FROM district AS T1 WHERE T1.A15 > 4000 AND EXISTS (SELECT 1 FROM account AS T2 WHERE T1.district_id = T2.district_id AND STRFTIME('%Y', T2.date) >= '1997');",
        "pred_query": "SELECT AVG(T1.A15) FROM district AS T1 WHERE T1.A15 > 4000 AND EXISTS (SELECT 1 FROM account AS T2 WHERE T1.district_id = T2.district_id AND STRFTIME('%Y', T2.date) >= '1997');",
        "pred_time": 0.0014293193817138672,
        "orig_time": 0.002037525177001953,
        "time_ratio": 1.4255212677231026,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "original_query": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "llm_output": "-- Reasoning\nI need to join the `frpm` table with the `schools` table on `CDSCode`.\nThen, I will select the `NCESSchool` from the `schools` table and `Enrollment (Ages 5-17)` from the `frpm` table.\nThe results should be ordered by `Enrollment (Ages 5-17)` in descending order and limited to the top 5.\n\n-- SQL Query\nSELECT T1.School, T2.NCESSchool, T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_query": "SELECT T1.School, T2.NCESSchool, T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_time": null,
        "orig_time": 0.024892091751098633,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level?",
        "original_query": "SELECT T2.ANA FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 ORDER BY T2.ANA DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the highest anti-nucleus antibody concentration, we need to query the `Examination` table.\nThe condition is based on \"normal creatinine level\", which is found in the `Laboratory` table (`CRE` column).\nWe need to join `Examination` and `Laboratory` tables on the common `ID` column.\nSince \"normal creatinine level\" is not explicitly defined with a range, we will assume it refers to any recorded (not NULL) creatinine value.\nFinally, we select the maximum `ANA` from the joined and filtered results.\n\n-- SQL Query\nSELECT MAX(T1.ANA) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE IS NOT NULL;",
        "pred_query": "SELECT MAX(T1.ANA) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE IS NOT NULL;",
        "pred_time": 0.0014393329620361328,
        "orig_time": 0.0011577606201171875,
        "time_ratio": 0.8043730329633925,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many male patients have elevated total bilirubin count?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "llm_output": "-- Reasoning\nI need to join the Patient and Laboratory tables on ID.\nThen, I will filter for male patients (SEX = 'M') and check for elevated total bilirubin.\nAssuming \"elevated\" means a T-BIL value greater than a common upper normal limit (e.g., 1.2 or 1.5). I will use 1.5 as the threshold for elevated.\nFinally, I will count the distinct IDs of these patients.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` > 1.5;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` > 1.5;",
        "pred_time": 0.001901388168334961,
        "orig_time": 0.0015459060668945312,
        "time_ratio": 0.8130407523510972,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "original_query": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "llm_output": "\nSELECT COUNT(DISTINCT T1.player_api_id)\nFROM Player_Attributes AS T1\nINNER JOIN (\n    -- Subquery to get unique player_api_id for players who have played for\n    -- any team that had a 'Maintain' buildUpPlayPositioningClass at some point.\n    SELECT DISTINCT player_api_id\n    FROM (\n        -- Combine all possible player-team associations from the Match table\n        SELECT home_player_1 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_2 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_3 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_4 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_5 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_6 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_7 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_8 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_9 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_10 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_11 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_1 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_2 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_3 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_4 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_5 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_6 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_7 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_8 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_9 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_10 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_11 AS player_api_id, away_team_api_id AS team_api_id FROM Match\n    ) AS PlayerTeamAssociations\n    INNER JOIN (\n        -- Get all team_api_id that have 'Maintain' buildUpPlayPositioningClass\n        SELECT DISTINCT team_api_id\n        FROM Team_Attributes\n        WHERE buildUpPlayPositioningClass = 'Maintain'\n    ) AS MaintainTeams ON PlayerTeamAssociations.team_api_id = MaintainTeams.team_api_id\n    WHERE PlayerTeamAssociations.player_api_id IS NOT NULL\n) AS PlayersInMaintainTeams ON T1.player_api_id = PlayersInMaintainTeams.player_api_id\nWHERE T1.preferred_foot = 'left';\n",
        "pred_query": "SELECT COUNT(DISTINCT T1.player_api_id)\nFROM Player_Attributes AS T1\nINNER JOIN (\n    -- Subquery to get unique player_api_id for players who have played for\n    -- any team that had a 'Maintain' buildUpPlayPositioningClass at some point.\n    SELECT DISTINCT player_api_id\n    FROM (\n        -- Combine all possible player-team associations from the Match table\n        SELECT home_player_1 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_2 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_3 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_4 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_5 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_6 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_7 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_8 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_9 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_10 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT home_player_11 AS player_api_id, home_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_1 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_2 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_3 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_4 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_5 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_6 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_7 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_8 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_9 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_10 AS player_api_id, away_team_api_id AS team_api_id FROM Match UNION ALL\n        SELECT away_player_11 AS player_api_id, away_team_api_id AS team_api_id FROM Match\n    ) AS PlayerTeamAssociations\n    INNER JOIN (\n        -- Get all team_api_id that have 'Maintain' buildUpPlayPositioningClass\n        SELECT DISTINCT team_api_id\n        FROM Team_Attributes\n        WHERE buildUpPlayPositioningClass = 'Maintain'\n    ) AS MaintainTeams ON PlayerTeamAssociations.team_api_id = MaintainTeams.team_api_id\n    WHERE PlayerTeamAssociations.player_api_id IS NOT NULL\n) AS PlayersInMaintainTeams ON T1.player_api_id = PlayersInMaintainTeams.player_api_id\nWHERE T1.preferred_foot = 'left';",
        "pred_time": 0.1194310188293457,
        "orig_time": 0.10855340957641602,
        "time_ratio": 0.9089214061844968,
        "check": false
    },
    {
        "id": "card_games",
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "original_query": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "llm_output": "SELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy'",
        "pred_query": "SELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy'",
        "pred_time": 0.07232356071472168,
        "orig_time": 0.06608200073242188,
        "time_ratio": 0.9136994926602208,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which SME customer consumed the least in June 2012?",
        "original_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `yearmonth` table with the `customers` table to filter by customer segment.\nI will filter the `yearmonth` table for the specific date '201206' and the `customers` table for the 'SME' segment.\nThen, I will order the results by `Consumption` in ascending order and take the first `CustomerID`.\n\n-- SQL Query\nSELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND SUBSTRING(T2.Date, 1, 6) = '201206' ORDER BY T2.Consumption ASC LIMIT 1;",
        "pred_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND SUBSTRING(T2.Date, 1, 6) = '201206' ORDER BY T2.Consumption ASC LIMIT 1;",
        "pred_time": 0.039038658142089844,
        "orig_time": 0.02138233184814453,
        "time_ratio": 0.5477219982899719,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the region of the client with the id 3541 from?",
        "original_query": "SELECT T2.district_id, T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
        "llm_output": "-- Reasoning\nTo find the region of a client, we need to connect the `client` table to the `district` table.\nThe `client` table contains `client_id` and `district_id`.\nThe `district` table contains `district_id` and the region name in column `A3`.\nWe will join these two tables on `district_id` and filter by the given `client_id`.\n\n-- SQL Query\nSELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541",
        "pred_query": "SELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541",
        "pred_time": 0.0010678768157958984,
        "orig_time": 0.0005273818969726562,
        "time_ratio": 0.49386023665996875,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the score and the link type ID for post ID 395?",
        "original_query": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395",
        "llm_output": "\nSELECT\n  T1.Score,\n  T2.LinkTypeId\nFROM posts AS T1\nINNER JOIN postLinks AS T2\n  ON T1.Id = T2.PostId\nWHERE\n  T1.Id = 395;\n",
        "pred_query": "SELECT\n  T1.Score,\n  T2.LinkTypeId\nFROM posts AS T1\nINNER JOIN postLinks AS T2\n  ON T1.Id = T2.PostId\nWHERE\n  T1.Id = 395;",
        "pred_time": 0.0017137527465820312,
        "orig_time": 0.001203775405883789,
        "time_ratio": 0.7024207011686143,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many French constructors have a lap number of over 50?",
        "original_query": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "llm_output": "\nSELECT COUNT(DISTINCT T1.constructorId) FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId INNER JOIN lapTimes AS T3 ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId WHERE T1.nationality = 'French' AND T3.lap > 50;\n",
        "pred_query": "SELECT COUNT(DISTINCT T1.constructorId) FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId INNER JOIN lapTimes AS T3 ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId WHERE T1.nationality = 'French' AND T3.lap > 50;",
        "pred_time": 0.00910496711730957,
        "orig_time": 0.0042095184326171875,
        "time_ratio": 0.46233208515541124,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "original_query": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA > 6.5 AND T1.SEX = 'F') OR (T2.UA > 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "llm_output": "-- Reasoning\nThe question asks for the average uric acid (UA) index for patients with normal UA, based on their latest laboratory examination.\n1. First, identify the latest laboratory examination date for each patient. This can be achieved by grouping the `Laboratory` table by `ID` and finding the `MAX(Date)`.\n2. Next, join this result back to the `Laboratory` table to retrieve the `UA` value corresponding to each patient's latest examination.\n3. Apply a filter to select only those results where the `UA` is considered \"normal\". Based on the first few-shot example where `UA > 6.5` is described as \"beyond the normal range\", we can infer that `UA <= 6.5` represents \"normal uric acid\".\n4. Finally, calculate the average of the `UA` values from these filtered, latest normal results.\n\n-- SQL Query\nSELECT AVG(T1.UA)\nFROM Laboratory AS T1\nINNER JOIN (\n    SELECT ID, MAX(Date) AS LatestDate\n    FROM Laboratory\n    GROUP BY ID\n) AS T2\nON T1.ID = T2.ID AND T1.Date = T2.LatestDate\nWHERE T1.UA <= 6.5;",
        "pred_query": "SELECT AVG(T1.UA)\nFROM Laboratory AS T1\nINNER JOIN (\n    SELECT ID, MAX(Date) AS LatestDate\n    FROM Laboratory\n    GROUP BY ID\n) AS T2\nON T1.ID = T2.ID AND T1.Date = T2.LatestDate\nWHERE T1.UA <= 6.5;",
        "pred_time": 0.0036118030548095703,
        "orig_time": 0.0044667720794677734,
        "time_ratio": 1.2367152947389266,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "original_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "llm_output": "-- Reasoning\nI need to find the circuit name for a specific race.\nThe `races` table contains information about races, including `year`, `name`, and `circuitId`.\nThe `circuits` table contains information about circuits, including `circuitId` and `name`.\nI will join `races` and `circuits` on `circuitId`, filter by `year` and `name` of the race, and select the circuit `name`.\n\n-- SQL Query\nSELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_time": 0.0012722015380859375,
        "orig_time": 0.0009636878967285156,
        "time_ratio": 0.757496251874063,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the molecule id of bond id TR001_1_7?",
        "original_query": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "llm_output": "-- Reasoning\nThe question asks for the `molecule_id` given a `bond_id`.\nThe `bond` table contains both `bond_id` and `molecule_id`.\nTherefore, I need to query the `bond` table and filter by the specified `bond_id`.\n\n-- SQL Query\nSELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';",
        "pred_query": "SELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';",
        "pred_time": 0.00077056884765625,
        "orig_time": 0.0024716854095458984,
        "time_ratio": 3.207611386138614,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "original_query": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "llm_output": "\nSELECT\n  CAST(\n    (\n      (\n        SELECT\n          T2.overall_rating\n        FROM Player AS T1\n        INNER JOIN Player_Attributes AS T2\n          ON T1.player_api_id = T2.player_api_id\n        WHERE\n          T1.player_name = 'Landon Donovan' AND T2.date = '2013-07-12 00:00:00'\n      ) - (\n        SELECT\n          T2.overall_rating\n        FROM Player AS T1\n        INNER JOIN Player_Attributes AS T2\n          ON T1.player_api_id = T2.player_api_id\n        WHERE\n          T1.player_name = 'Jordan Bowery' AND T2.date = '2013-07-12 00:00:00'\n      )\n    ) * 100.0 / (\n      SELECT\n        T2.overall_rating\n      FROM Player AS T1\n      INNER JOIN Player_Attributes AS T2\n        ON T1.player_api_id = T2.player_api_id\n      WHERE\n        T1.player_name = 'Jordan Bowery' AND T2.date = '2013-07-12 00:00:00'\n    ) AS REAL\n  );\n",
        "pred_query": "SELECT\n  CAST(\n    (\n      (\n        SELECT\n          T2.overall_rating\n        FROM Player AS T1\n        INNER JOIN Player_Attributes AS T2\n          ON T1.player_api_id = T2.player_api_id\n        WHERE\n          T1.player_name = 'Landon Donovan' AND T2.date = '2013-07-12 00:00:00'\n      ) - (\n        SELECT\n          T2.overall_rating\n        FROM Player AS T1\n        INNER JOIN Player_Attributes AS T2\n          ON T1.player_api_id = T2.player_api_id\n        WHERE\n          T1.player_name = 'Jordan Bowery' AND T2.date = '2013-07-12 00:00:00'\n      )\n    ) * 100.0 / (\n      SELECT\n        T2.overall_rating\n      FROM Player AS T1\n      INNER JOIN Player_Attributes AS T2\n        ON T1.player_api_id = T2.player_api_id\n      WHERE\n        T1.player_name = 'Jordan Bowery' AND T2.date = '2013-07-12 00:00:00'\n    ) AS REAL\n  );",
        "pred_time": 0.1069180965423584,
        "orig_time": 0.0780479907989502,
        "time_ratio": 0.7299792394641953,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "original_query": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe query needs to find the patient with the highest hemoglobin (HGB) count.\nIt then needs to calculate the patient's age at the time of that specific laboratory examination (`Laboratory.Date`) by comparing it with the patient's birth date (`Patient.Birthday`).\nFinally, it should retrieve the patient's overall diagnosis from the `Patient` table.\nThe `ORDER BY T2.HGB DESC LIMIT 1` clause is used to efficiently find the single patient entry with the maximum HGB.\n\n-- SQL Query\nSELECT\n  STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday),\n  T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nORDER BY\n  T2.HGB DESC\nLIMIT 1;",
        "pred_query": "SELECT\n  STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday),\n  T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nORDER BY\n  T2.HGB DESC\nLIMIT 1;",
        "pred_time": 0.005234956741333008,
        "orig_time": 0.004755973815917969,
        "time_ratio": 0.9085029831033383,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "original_query": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "llm_output": "-- Reasoning\nTo answer the question, I need to retrieve pit stop information for a specific race.\nI will join the `pitStops` table with the `races` table to filter by the '2011 Australian Grand Prix'.\nThen, I will join with the `drivers` table to get the names of the drivers.\nFinally, I will sum the `milliseconds` column from the `pitStops` table for each driver and group the results by driver.\n\n-- SQL Query\nSELECT\n  T2.forename,\n  T2.surname,\n  SUM(T1.milliseconds) AS total_pit_stop_milliseconds\nFROM pitStops AS T1\nINNER JOIN drivers AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T1.raceId = T3.raceId\nWHERE\n  T3.year = 2011 AND T3.name = 'Australian Grand Prix'\nGROUP BY\n  T2.driverId,\n  T2.forename,\n  T2.surname;",
        "pred_query": "SELECT\n  T2.forename,\n  T2.surname,\n  SUM(T1.milliseconds) AS total_pit_stop_milliseconds\nFROM pitStops AS T1\nINNER JOIN drivers AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T1.raceId = T3.raceId\nWHERE\n  T3.year = 2011 AND T3.name = 'Australian Grand Prix'\nGROUP BY\n  T2.driverId,\n  T2.forename,\n  T2.surname;",
        "pred_time": 0.0017633438110351562,
        "orig_time": 0.0006718635559082031,
        "time_ratio": 0.38101676581936184,
        "check": false
    },
    {
        "id": "financial",
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "original_query": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "llm_output": "-- Reasoning\nI need to count accounts opened in 1993 that are located in the 'Decin' district and divide this by the total count of accounts opened in 1993.\nThis requires joining the `account` and `district` tables.\nI will filter for the year 1993 using `strftime('%Y', T1.date) = '1993'` and then count the specific district and total.\n\n-- SQL Query\nSELECT\n  CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id)\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nWHERE\n  STRFTIME('%Y', T1.date) = '1993';",
        "pred_query": "SELECT\n  CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id)\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nWHERE\n  STRFTIME('%Y', T1.date) = '1993';",
        "pred_time": 0.0022416114807128906,
        "orig_time": 0.0019309520721435547,
        "time_ratio": 0.8614124654328866,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Please list the product description of the products consumed in September, 2013.",
        "original_query": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "llm_output": "-- Reasoning\nI need to retrieve product descriptions from the `products` table.\nThe consumption information (transactions with dates) is available in the `transactions_1k` table.\nI will join `products` and `transactions_1k` on `ProductID`.\nThen, I will filter the results for transactions that occurred in September 2013 using the `Date` column.\nFinally, I will select distinct product descriptions.\n\n-- SQL Query\nSELECT DISTINCT T1.Description FROM products AS T1 INNER JOIN transactions_1k AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Date BETWEEN '2013-09-01' AND '2013-09-30';",
        "pred_query": "SELECT DISTINCT T1.Description FROM products AS T1 INNER JOIN transactions_1k AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Date BETWEEN '2013-09-01' AND '2013-09-30';",
        "pred_time": 0.0009989738464355469,
        "orig_time": 0.0032067298889160156,
        "time_ratio": 3.2100238663484486,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the elements for bond id TR001_10_11?",
        "original_query": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
        "llm_output": "-- Reasoning\nThe question asks for the elements associated with a specific bond ID.\nI need to find the atoms connected by the given bond and then retrieve their respective elements.\nThe `connected` table links `bond_id` to `atom_id` and `atom_id2`.\nThe `atom` table stores the `element` for each `atom_id`.\nI will join `connected` with `atom` twice (once for `atom_id` and once for `atom_id2`) and select the distinct elements.\n\n-- SQL Query\nSELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_10_11' UNION SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 WHERE T2.bond_id = 'TR001_10_11';",
        "pred_query": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_10_11' UNION SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 WHERE T2.bond_id = 'TR001_10_11';",
        "pred_time": 0.004025697708129883,
        "orig_time": 0.0024526119232177734,
        "time_ratio": 0.6092389694995558,
        "check": true
    },
    {
        "id": "card_games",
        "question": "List the edhrecRank for cards with frame version 2015.",
        "original_query": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "llm_output": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_query": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "original_query": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "llm_output": "\nSELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1999' AND player_name LIKE 'Aaron %';\n",
        "pred_query": "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1999' AND player_name LIKE 'Aaron %';",
        "pred_time": 0.006251811981201172,
        "orig_time": 0.0038030147552490234,
        "time_ratio": 0.6083060025932423,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "original_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
        "llm_output": "\nSELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;\n",
        "pred_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;",
        "pred_time": 0.0030443668365478516,
        "orig_time": 0.003406524658203125,
        "time_ratio": 1.1189599812044797,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which college do most of the members go to?",
        "original_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the college with the most members, I need to join the 'member' table with the 'major' table.\nThen, I will group the results by the 'college' column from the 'major' table.\nFinally, I will count the members for each college, order them by count in descending order, and select the top one.\n\n-- SQL Query\nSELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_time": 0.0010492801666259766,
        "orig_time": 0.0006954669952392578,
        "time_ratio": 0.6628039082026812,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were from New York?",
        "original_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "llm_output": "-- Reasoning\nI need to count the number of users.\nThe `users` table contains user information, including their `Location`.\nI will filter the `users` table for entries where `Location` is 'New York' and then count the distinct user IDs.\n\n-- SQL Query\nSELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_time": 0.009448766708374023,
        "orig_time": 0.0096893310546875,
        "time_ratio": 1.0254598672756177,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which country is the Belgium Jupiler League from?",
        "original_query": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "llm_output": "\nSELECT T2.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League';\n",
        "pred_query": "SELECT T2.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League';",
        "pred_time": 0.0008533000946044922,
        "orig_time": 0.0006678104400634766,
        "time_ratio": 0.7826208438111204,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "original_query": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "llm_output": "SELECT\n  T1.ID,\n  CASE\n    WHEN T2.ALB BETWEEN 3.5 AND 5.5\n    THEN 'Within Range'\n    ELSE 'Not Within Range'\n  END\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  strftime('%Y', T1.Birthday) = '1982';",
        "pred_query": "SELECT\n  T1.ID,\n  CASE\n    WHEN T2.ALB BETWEEN 3.5 AND 5.5\n    THEN 'Within Range'\n    ELSE 'Not Within Range'\n  END\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  strftime('%Y', T1.Birthday) = '1982';",
        "pred_time": 0.00693821907043457,
        "orig_time": 0.006613492965698242,
        "time_ratio": 0.9531974846225215,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "original_query": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nI need to find sets that have an Italian translation from the `set_translations` table.\nThen, I need to retrieve the set name and the total number of cards for these sets from the `sets` table.\nI will join `set_translations` with `sets` on `setCode` and `code` respectively, filtering for 'Italian' language.\n\n-- SQL Query\nSELECT T2.name, T2.totalSetSize FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.language = 'Italian';",
        "pred_query": "SELECT T2.name, T2.totalSetSize FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.language = 'Italian';",
        "pred_time": 0.010693550109863281,
        "orig_time": 0.00521087646484375,
        "time_ratio": 0.4872915366092928,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many clients who choose statement of weekly issuance are User?",
        "original_query": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'USER'",
        "llm_output": "-- Reasoning\nTo find the number of clients who meet both criteria, I need to join the `client`, `disp`, and `account` tables.\n1. Join `client` with `disp` on `client_id`.\n2. Join the result with `account` on `account_id`.\n3. Filter by `account.frequency` for 'weekly issuance' (assuming 'WEEKLY' or similar, let's check the example given: 'POPLATEK PO OBRATU' is used. Without a list of frequency values, I'll use `WEEKLY` as a common interpretation for \"weekly issuance\").\n4. Filter by `disp.type` for 'User'.\n5. Count the distinct `client_id`s.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'WEEKLY' AND T2.type = 'USER';",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'WEEKLY' AND T2.type = 'USER';",
        "pred_time": 0.0011265277862548828,
        "orig_time": 0.0007307529449462891,
        "time_ratio": 0.6486772486772486,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "original_query": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "llm_output": "\nSELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'\n",
        "pred_query": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "pred_time": 0.07331061363220215,
        "orig_time": 0.07542967796325684,
        "time_ratio": 1.028905287052786,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients whose C-reactive protein level is abnormal, how many of them aren't 18 yet?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP != '-' AND T2.CRP != '+-') AND T2.CRP >= 1.0 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < '18'",
        "llm_output": "\nSELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  (\n    T2.CRP NOT IN ('-', '+-') AND CAST(T2.CRP AS REAL) >= 1.0\n  ) AND DATE('now') < DATE(T1.Birthday, '+18 years');\n",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  (\n    T2.CRP NOT IN ('-', '+-') AND CAST(T2.CRP AS REAL) >= 1.0\n  ) AND DATE('now') < DATE(T1.Birthday, '+18 years');",
        "pred_time": 0.006222248077392578,
        "orig_time": 0.010032176971435547,
        "time_ratio": 1.6123074565100775,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "original_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "llm_output": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_time": 0.06710028648376465,
        "orig_time": 0.059037208557128906,
        "time_ratio": 0.8798354172662637,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patient who first came to the hospital on 1991/6/13 who was diagnosed with SJS, what is the total number of his/her Laboratory tests in 1995?",
        "original_query": "SELECT COUNT(*) FROM Laboratory WHERE ID = ( SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS' ) AND STRFTIME('%Y', Date) = '1995'",
        "llm_output": "-- Reasoning\nThe query needs to first identify the patient based on their `First Date` and `Diagnosis` from the `Patient` table.\nThen, it will count the number of laboratory tests for this specific patient from the `Laboratory` table.\nThe count should be restricted to tests performed in the year 1995.\nI will join `Patient` and `Laboratory` tables on `ID`, filter by patient criteria, and then filter `Laboratory` dates by year.\n\n-- SQL Query\nSELECT COUNT(T2.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` = '1991-06-13' AND T1.Diagnosis = 'SJS' AND STRFTIME('%Y', T2.Date) = '1995';",
        "pred_query": "SELECT COUNT(T2.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` = '1991-06-13' AND T1.Diagnosis = 'SJS' AND STRFTIME('%Y', T2.Date) = '1995';",
        "pred_time": 0.0009469985961914062,
        "orig_time": 0.0006444454193115234,
        "time_ratio": 0.6805135951661632,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "original_query": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the display name of the user who acquired the first 'Autobiographer' badge, I need to join the `badges` table with the `users` table.\nFirst, filter the `badges` table for rows where `Name` is 'Autobiographer'.\nThen, order these results by `Date` in ascending order and take the top one to find the first badge.\nFinally, retrieve the `DisplayName` from the `users` table for the corresponding `UserId`.\n\n-- SQL Query\nSELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Autobiographer' ORDER BY T1.Date ASC LIMIT 1;",
        "pred_query": "SELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Autobiographer' ORDER BY T1.Date ASC LIMIT 1;",
        "pred_time": 0.0192108154296875,
        "orig_time": 0.018735408782958984,
        "time_ratio": 0.9752531771247022,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Identify the total number of posts with views above average.",
        "original_query": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "llm_output": "-- Reasoning\nFirst, calculate the average ViewCount from the 'posts' table.\nThen, count the number of posts whose ViewCount is greater than this calculated average.\nThis involves a subquery to get the average ViewCount.\n\n-- SQL Query\nSELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_query": "SELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_time": 0.21446609497070312,
        "orig_time": 0.2181382179260254,
        "time_ratio": 1.0171221607584355,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "llm_output": "\nSELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.type LIKE '%Artifact%' AND T1.colors LIKE '%Black%';\n",
        "pred_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.type LIKE '%Artifact%' AND T1.colors LIKE '%Black%';",
        "pred_time": 0.32135009765625,
        "orig_time": 0.309553861618042,
        "time_ratio": 0.9632916369895537,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "original_query": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "llm_output": "-- Reasoning\nThe query needs to retrieve distinct patient IDs.\nIt requires joining the `Patient` table with the `Examination` table to filter by `Examination Date`.\nIt also requires joining the `Patient` table with the `Laboratory` table to filter by `GPT` and `ALB` levels.\nAll conditions (`Examination Date` range, `GPT` > 30, `ALB` < 4) must be met by a patient across their records in these tables.\nThe `DISTINCT` keyword ensures each patient ID is listed only once.\n\n-- SQL Query\nSELECT DISTINCT T1.ID FROM Patient AS T1 JOIN Examination AS T2 ON T1.ID = T2.ID JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T2.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T3.GPT > 30 AND T3.ALB < 4;",
        "pred_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 JOIN Examination AS T2 ON T1.ID = T2.ID JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T2.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T3.GPT > 30 AND T3.ALB < 4;",
        "pred_time": 0.005869150161743164,
        "orig_time": 0.004043102264404297,
        "time_ratio": 0.688873542673762,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the labels for TR000, TR001 and TR002?",
        "original_query": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
        "llm_output": "-- Reasoning\nThe question asks for labels associated with specific molecule IDs ('TR000', 'TR001', 'TR002').\nThe `molecule` table contains both `molecule_id` and `label`.\nI need to select the `label` from the `molecule` table where the `molecule_id` is one of the specified values.\n\n-- SQL Query\nSELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_query": "SELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_time": 0.0010247230529785156,
        "orig_time": 0.0008442401885986328,
        "time_ratio": 0.8238715681712424,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin?",
        "original_query": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "llm_output": "\nSELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin'\n",
        "pred_query": "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin'",
        "pred_time": 0.010399818420410156,
        "orig_time": 0.008473634719848633,
        "time_ratio": 0.8147867950481431,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "original_query": "SELECT CAST(SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTRING(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "llm_output": "First, identify the CustomerID from `transactions_1k` based on the given date and price.\nThen, calculate the total consumption for this customer for the years 2012 and 2013 from the `yearmonth` table.\nFinally, compute the consumption decrease rate using the formula: (consumption_2012 - consumption_2013) / consumption_2012.\n\n\nSELECT\n  (SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2013' THEN T2.Consumption ELSE 0 END)) * 1.0 / SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END)\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2\n  ON T1.CustomerID = T2.CustomerID\nWHERE\n  T1.Date = '2012-08-25' AND T1.Price = 634.8;\n",
        "pred_query": "SELECT\n  (SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2013' THEN T2.Consumption ELSE 0 END)) * 1.0 / SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END)\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2\n  ON T1.CustomerID = T2.CustomerID\nWHERE\n  T1.Date = '2012-08-25' AND T1.Price = 634.8;",
        "pred_time": 0.15524768829345703,
        "orig_time": 0.03522038459777832,
        "time_ratio": 0.2268657587429126,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Identify the heaviest superhero in DC Comics.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `publisher` table to filter by 'DC Comics'.\nThen, I will order the results by `weight_kg` in descending order to find the heaviest superhero.\nFinally, I will limit the result to 1 and select the `superhero_name`.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1;",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1;",
        "pred_time": 0.0007765293121337891,
        "orig_time": 0.0005578994750976562,
        "time_ratio": 0.7184525637089346,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Please list the diseases of the patients born after 1995-1-1 and have a normal Rhuematoid Factor.",
        "original_query": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > 1995-01-01",
        "llm_output": "-- Reasoning\nThe query needs to retrieve the diagnosis from the `Patient` table.\nIt must filter patients born after '1995-01-01' using the `Birthday` column in the `Patient` table.\nIt also needs to filter for patients with a normal Rheumatoid Factor (`RA`) from the `Laboratory` table, which is typically represented as '-' or '+-'.\nBoth conditions require joining `Patient` and `Laboratory` tables on their common `ID` column.\n\n-- SQL Query\nSELECT DISTINCT\n  T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.Birthday > '1995-01-01' AND (T2.RA = '-' OR T2.RA = '+-');",
        "pred_query": "SELECT DISTINCT\n  T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.Birthday > '1995-01-01' AND (T2.RA = '-' OR T2.RA = '+-');",
        "pred_time": 0.004587650299072266,
        "orig_time": 0.00486445426940918,
        "time_ratio": 1.0603367633302152,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the name of user with the ID of 30?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = 30",
        "llm_output": "-- Reasoning\nI need to retrieve the user's name from the `users` table.\nThe question specifies the user by their `Id`, which is 30.\nI will filter the `users` table by `Id = 30` and select the `DisplayName` column.\n\n-- SQL Query\nSELECT DisplayName FROM users WHERE Id = 30;",
        "pred_query": "SELECT DisplayName FROM users WHERE Id = 30;",
        "pred_time": 0.0007510185241699219,
        "orig_time": 0.00044608116149902344,
        "time_ratio": 0.5939682539682539,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "original_query": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "llm_output": "SELECT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "pred_query": "SELECT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the names of the races held on the circuits in Spain.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "llm_output": "\nSELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain';\n",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain';",
        "pred_time": 0.0011279582977294922,
        "orig_time": 0.0007245540618896484,
        "time_ratio": 0.6423589093214965,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
        "original_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
        "llm_output": "-- Reasoning\nThe query needs to identify atoms that are part of a carcinogenic molecule and are oxygen atoms.\nFirst, filter the `molecule` table for molecules labeled as carcinogenic (assuming `label = '+'` from the few-shot examples for \"carcinogenic\").\nThen, join with the `atom` table on `molecule_id`.\nFinally, filter the `atom` table for atoms where the `element` is 'O' (oxygen) and select their `atom_id`.\n\n-- SQL Query\nSELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'O';",
        "pred_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'O';",
        "pred_time": 0.0014827251434326172,
        "orig_time": 0.0014774799346923828,
        "time_ratio": 0.9964624537707026,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "llm_output": "-- Reasoning\nThe question asks for the count of accounts that meet two criteria:\n1. They are associated with a district in 'Prague'. This can be found by joining `account` with `district` on `district_id` and filtering `district.A3 = 'Prague'`.\n2. They are \"eligible for loans\". In the context of a `loan` table with a `status` column, the most straightforward interpretation without further definitions is that the account has at least one associated loan record. If specific loan statuses (e.g., 'A' for finished without problems, 'C' for running and OK) were required for eligibility, the question would typically specify them. Therefore, we join with the `loan` table on `account_id`.\nFinally, we count the distinct `account_id`s to avoid double-counting accounts that might have multiple loans.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = 'Prague';",
        "pred_query": "SELECT COUNT(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = 'Prague';",
        "pred_time": 0.0011608600616455078,
        "orig_time": 0.0007793903350830078,
        "time_ratio": 0.6713904292462518,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Is molecule TR124 carcinogenic?",
        "original_query": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
        "llm_output": "-- Reasoning\nThe question asks about the carcinogenic property of a specific molecule, 'TR124'.\nThe `molecule` table contains `molecule_id` and a `label` column which is expected to hold information about the molecule's property, such as carcinogenicity, as seen in the few-shot examples.\nTherefore, I need to select the `label` for the molecule with `molecule_id` 'TR124' from the `molecule` table.\n\n-- SQL Query\nSELECT label FROM molecule WHERE molecule_id = 'TR124';",
        "pred_query": "SELECT label FROM molecule WHERE molecule_id = 'TR124';",
        "pred_time": 0.0006053447723388672,
        "orig_time": 0.00040149688720703125,
        "time_ratio": 0.6632532493107522,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the anti Cardiolipin antibody concentration of the female patient with the highest uric acid level in the normal range?",
        "original_query": "SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T1.SEX = 'F' AND T2.UA > 6.5 ORDER BY T2.UA DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo answer the question, we first need to identify the female patient with the highest uric acid level within the normal range. We'll assume a standard normal range for uric acid (UA) in adult females, such as 2.4 to 6.0 mg/dL.\n1. Filter the `Patient` table for female patients.\n2. Join `Patient` with `Laboratory` to access uric acid levels.\n3. Filter the uric acid levels (`UA`) to be within the assumed normal range.\n4. Order these filtered results by `UA` in descending order and select the top one to find the patient ID.\n5. Finally, join this patient ID with the `Examination` table to retrieve their `aCL IgG` concentration.\n\n-- SQL Query\nSELECT T3.`aCL IgG` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.SEX = 'F' AND T2.UA >= 2.4 AND T2.UA <= 6.0 ORDER BY T2.UA DESC LIMIT 1;",
        "pred_query": "SELECT T3.`aCL IgG` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.SEX = 'F' AND T2.UA >= 2.4 AND T2.UA <= 6.0 ORDER BY T2.UA DESC LIMIT 1;",
        "pred_time": 0.001758575439453125,
        "orig_time": 0.0013835430145263672,
        "time_ratio": 0.7867407809110629,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Calculate the ratio of votes in 2010 and 2011.",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
        "llm_output": "-- Reasoning\nI need to count the total number of votes for the year 2010 and the total number of votes for the year 2011 from the `votes` table.\nThen, I will divide the count of 2010 votes by the count of 2011 votes to get the ratio.\nThe `STRFTIME('%Y', CreationDate)` function can extract the year from the `CreationDate` column.\n\n-- SQL Query\nSELECT\n  CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) /\n  SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END)\nFROM votes;",
        "pred_query": "SELECT\n  CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) /\n  SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END)\nFROM votes;",
        "pred_time": 0.035649776458740234,
        "orig_time": 0.03339219093322754,
        "time_ratio": 0.9366732207107794,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Calculate the difference in view count from post posted by mornington and view count from posts posted by Amos.",
        "original_query": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "llm_output": "-- Reasoning\nTo find the view count for posts by 'mornington' and 'Amos', I will join the `users` and `posts` tables.\nThen, I will use conditional aggregation to sum `ViewCount` for each user separately.\nFinally, I will subtract the total view count of 'Amos' from 'mornington' to get the difference.\n\n-- SQL Query\nSELECT\n  SUM(CASE WHEN T1.DisplayName = 'mornington' THEN T2.ViewCount ELSE 0 END) - SUM(CASE WHEN T1.DisplayName = 'Amos' THEN T2.ViewCount ELSE 0 END)\nFROM users AS T1\nINNER JOIN posts AS T2\n  ON T1.Id = T2.OwnerUserId\nWHERE\n  T1.DisplayName IN ('mornington', 'Amos');",
        "pred_query": "SELECT\n  SUM(CASE WHEN T1.DisplayName = 'mornington' THEN T2.ViewCount ELSE 0 END) - SUM(CASE WHEN T1.DisplayName = 'Amos' THEN T2.ViewCount ELSE 0 END)\nFROM users AS T1\nINNER JOIN posts AS T2\n  ON T1.Id = T2.OwnerUserId\nWHERE\n  T1.DisplayName IN ('mornington', 'Amos');",
        "pred_time": 0.2167375087738037,
        "orig_time": 0.5811042785644531,
        "time_ratio": 2.6811431110935104,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "original_query": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "llm_output": "-- Reasoning\nI need to find the `Score` from the `comments` table.\nThe condition is related to the `CreationDate` of a `post`.\nTherefore, I will join the `comments` table with the `posts` table on `PostId` and `Id` respectively.\nThen, I will filter the results based on the `CreaionDate` from the `posts` table.\n\n-- SQL Query\nSELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CreaionDate = '2010-07-19 19:19:56.0'",
        "pred_query": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CreaionDate = '2010-07-19 19:19:56.0'",
        "pred_time": 0.23697519302368164,
        "orig_time": 0.05402255058288574,
        "time_ratio": 0.2279671129015057,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "original_query": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "llm_output": "-- Reasoning\nI need to query the `cards` table.\nI will filter the rows where the `artist` column is 'Aaron Boyd'.\nThen, I will count the distinct values in the `type` column for these filtered rows.\n\n-- SQL Query\nSELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "pred_query": "SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "pred_time": 0.060350656509399414,
        "orig_time": 0.06032419204711914,
        "time_ratio": 0.9995614884110473,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "original_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the earliest transaction on '2012-08-25' in the `transactions_1k` table.\nThen, I will get the `GasStationID` from that transaction.\nFinally, I will join with the `gasstations` table to retrieve the `Country` for that specific gas station.\n\n-- SQL Query\nSELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time ASC LIMIT 1;",
        "pred_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time ASC LIMIT 1;",
        "pred_time": 0.0011012554168701172,
        "orig_time": 0.0007550716400146484,
        "time_ratio": 0.685646243775709,
        "check": true
    },
    {
        "id": "student_club",
        "question": "When did the member, Casey Mason, received the income?",
        "original_query": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "llm_output": "-- Reasoning\nI need to find the `date_received` from the `income` table.\nThe `income` table is linked to the `member` table by `link_to_member` and `member_id`.\nI will filter the `member` table for 'Casey Mason' and then join with `income` to get the `date_received`.\n\nSELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_query": "SELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_time": 0.0009207725524902344,
        "orig_time": 0.0004935264587402344,
        "time_ratio": 0.5359917141377525,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "llm_output": "-- Reasoning\nI need to join the `Patient` table with the `Laboratory` table using the `ID` column.\nFilter patients whose `Birthday` year is '1937'.\nFilter laboratory records where `T-CHO` (total cholesterol) is greater than or equal to 250, assuming this is the threshold for 'beyond normal range' based on the few-shot example.\nSelect distinct `ID` from the filtered results.\n\n\nSELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250;\n",
        "pred_query": "Select distinct `ID` from the filtered results.\n\n\nSELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250;",
        "pred_time": null,
        "orig_time": 0.0010640621185302734,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "original_query": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "llm_output": "-- Reasoning\nI need to join the `customers` table with the `yearmonth` table on `CustomerID`.\nThen, I will filter for customers with `Segment = 'LAM'`.\nFrom this filtered set, I will count how many had `Consumption > 46.73` and divide it by the total count of `LAM` customers.\nFinally, I will multiply by 100 to get the percentage.\n\n-- SQL Query\nSELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM';",
        "pred_query": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM';",
        "pred_time": 0.06319570541381836,
        "orig_time": 0.041786909103393555,
        "time_ratio": 0.6612302027450181,
        "check": true
    },
    {
        "id": "superhero",
        "question": "What is the gender of Agent 13 hero?",
        "original_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'",
        "llm_output": "-- Reasoning\nTo find the gender of 'Agent 13', I need to query the `superhero` table to find the hero with that name.\nOnce I have the `gender_id` from the `superhero` table, I will join it with the `gender` table to get the corresponding `gender` name.\n\n-- SQL Query\nSELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_time": 0.0008916854858398438,
        "orig_time": 0.0005540847778320312,
        "time_ratio": 0.6213903743315508,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please give the full name of the tallest hero published by Marvel Comics.",
        "original_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `publisher` table to filter for 'Marvel Comics'.\nThen, I will order the results by `height_cm` in descending order.\nFinally, I will limit the result to 1 to get the tallest hero's `full_name`.\n\n-- SQL Query\nSELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_time": 0.0010628700256347656,
        "orig_time": 0.0006334781646728516,
        "time_ratio": 0.5960071781067744,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "original_query": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "llm_output": "-- Reasoning\nTo find the artists who illustrated cards in Phyrexian, I need to join the `foreign_data` table with the `cards` table.\nThe `foreign_data` table contains the `language` information, and the `cards` table contains the `artist` names.\nBoth tables can be linked using the `uuid` column.\nI will filter for `language = 'Phyrexian'` in `foreign_data` and then select the distinct artist names.\n\n-- SQL Query\nSELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian';",
        "pred_query": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian';",
        "pred_time": 0.08779573440551758,
        "orig_time": 0.08139681816101074,
        "time_ratio": 0.9271158640242014,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "original_query": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "llm_output": "-- Reasoning\nI need to find the user's display name.\nThe bounty amount is in the `votes` table.\nThe post title is in the `posts` table.\nThe user's display name is in the `users` table.\nI will join `users`, `votes`, and `posts` tables.\nFilter `votes` for `BountyAmount = 50`.\nFilter `posts` where `Title` contains 'variance'.\n\n-- SQL Query\nSELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_query": "SELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_time": 0.003748178482055664,
        "orig_time": 0.003179788589477539,
        "time_ratio": 0.8483557025634502,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Write down the ruling of Beacon of Immortality.",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "llm_output": "-- Reasoning\nI need to find the ruling text for a specific card.\nThe `rulings` table contains the `text` column which represents the ruling.\nThe `rulings` table is linked to the `cards` table by the `uuid` column.\nI will join these two tables and filter by the card `name` in the `cards` table.\n\n-- SQL Query\nSELECT T1.text FROM rulings AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Beacon of Immortality';",
        "pred_query": "SELECT T1.text FROM rulings AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Beacon of Immortality';",
        "pred_time": 0.17225027084350586,
        "orig_time": 0.16948866844177246,
        "time_ratio": 0.9839675003806386,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "original_query": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "llm_output": "-- Reasoning\nI need to first identify the `molecule_id`s that have triple bonds from the `bond` table.\nThen, I will join these `molecule_id`s with the `molecule` table to get their labels and with the `atom` table to get all elements contained within these specific molecules.\nFinally, I will select the distinct molecule labels and elements.\n\n-- SQL Query\nSELECT DISTINCT\n  T2.label,\n  T3.element\nFROM bond AS T1\nINNER JOIN molecule AS T2\n  ON T1.molecule_id = T2.molecule_id\nINNER JOIN atom AS T3\n  ON T2.molecule_id = T3.molecule_id\nWHERE\n  T1.bond_type = '#';",
        "pred_query": "SELECT DISTINCT\n  T2.label,\n  T3.element\nFROM bond AS T1\nINNER JOIN molecule AS T2\n  ON T1.molecule_id = T2.molecule_id\nINNER JOIN atom AS T3\n  ON T2.molecule_id = T3.molecule_id\nWHERE\n  T1.bond_type = '#';",
        "pred_time": 0.007062673568725586,
        "orig_time": 0.006495952606201172,
        "time_ratio": 0.9197582959187118,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "original_query": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "llm_output": "-- Reasoning\nI need to first find all users who have an 'Organizer' badge by joining the `users` and `badges` tables.\nThen, from this filtered set of users, I will count how many are teenagers (age between 13 and 18).\nFinally, I will divide the count of teenage organizers by the total count of organizers and multiply by 100 to get the percentage.\n\n-- SQL Query\nSELECT CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Organizer';",
        "pred_query": "SELECT CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Organizer';",
        "pred_time": 0.010834455490112305,
        "orig_time": 0.010106325149536133,
        "time_ratio": 0.9327949299121977,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to count superheroes for 'DC Comics' and 'Marvel Comics' separately from the 'superhero' and 'publisher' tables.\nThen, I will calculate the absolute difference between these two counts.\nI will use subqueries or CTEs to get the counts for each publisher and then subtract them.\n\n-- SQL Query\nSELECT\n  ABS(SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_query": "SELECT\n  ABS(SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_time": 0.0011594295501708984,
        "orig_time": 0.0005924701690673828,
        "time_ratio": 0.5110014394406744,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "original_query": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "llm_output": "-- Reasoning\nI need to find the user who owns a specific post.\nI will join the `posts` table with the `users` table using `posts.OwnerUserId = users.Id`.\nThen I will filter the results by the `Title` column in the `posts` table.\nFinally, I will select the `DisplayName` and `Reputation` from the `users` table.\n\n-- SQL Query\nSELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_query": "SELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_time": 0.11009359359741211,
        "orig_time": 0.10414290428161621,
        "time_ratio": 0.9459488139014133,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "original_query": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "llm_output": "\nSELECT DISTINCT T2.language\nFROM sets AS T1\nINNER JOIN set_translations AS T2\n  ON T1.code = T2.setCode\nWHERE\n  T1.name = 'Archenemy' AND T1.mcmName = 'Archenemy' AND T1.code = 'ARC';\n",
        "pred_query": "SELECT DISTINCT T2.language\nFROM sets AS T1\nINNER JOIN set_translations AS T2\n  ON T1.code = T2.setCode\nWHERE\n  T1.name = 'Archenemy' AND T1.mcmName = 'Archenemy' AND T1.code = 'ARC';",
        "pred_time": 0.004545450210571289,
        "orig_time": 0.0037431716918945312,
        "time_ratio": 0.8234985575662208,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "llm_output": "-- Reasoning\nThe query needs to identify patients who have both a \"normal proteinuria level\" and an \"SLE\" diagnosis.\nThe `Laboratory` table contains `U-PRO` (urinary protein), which is typed as TEXT. Assuming 'negative' represents a normal proteinuria level for a TEXT field.\nThe `Examination` table contains `Diagnosis` information, which can be filtered for 'SLE'.\nWe will join `Patient`, `Laboratory`, and `Examination` tables on `ID` to link these conditions to specific patients and select distinct patient IDs.\n\n-- SQL Query\nSELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nINNER JOIN Examination AS T3\n  ON T1.ID = T3.ID\nWHERE\n  T2.`U-PRO` = 'negative' AND T3.Diagnosis = 'SLE';",
        "pred_query": "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nINNER JOIN Examination AS T3\n  ON T1.ID = T3.ID\nWHERE\n  T2.`U-PRO` = 'negative' AND T3.Diagnosis = 'SLE';",
        "pred_time": 0.0013926029205322266,
        "orig_time": 0.0030243396759033203,
        "time_ratio": 2.1717171717171717,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What type of label is not on molecules with atoms with tin?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "llm_output": "-- Reasoning\nI need to find all molecule labels that are not associated with molecules containing 'sn' atoms.\nFirst, I will identify the labels of molecules that *do* have 'sn' atoms by joining `molecule` and `atom` tables and filtering for `element = 'sn'`.\nThen, I will select all labels from the `molecule` table that are not in the set of labels identified in the first step.\n\n-- SQL Query\nSELECT DISTINCT T1.label FROM molecule AS T1 WHERE T1.label NOT IN ( SELECT T2.label FROM molecule AS T2 INNER JOIN atom AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.element = 'sn' );",
        "pred_query": "SELECT DISTINCT T1.label FROM molecule AS T1 WHERE T1.label NOT IN ( SELECT T2.label FROM molecule AS T2 INNER JOIN atom AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.element = 'sn' );",
        "pred_time": 0.001781463623046875,
        "orig_time": 0.0031485557556152344,
        "time_ratio": 1.7673982869379015,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "original_query": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "llm_output": "-- Reasoning\nTo answer the question, I need to identify the driver based on the given `raceId` and `q2` time from the `qualifying` table.\nThen, I will join this information with the `drivers` table using `driverId` to retrieve the driver's `nationality`.\nThe Q2 time format in the question '0:01:40' suggests using `LIKE '1:40%'` for the `q2` column, similar to the provided few-shot examples.\n\n-- SQL Query\nSELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%';",
        "pred_query": "SELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%';",
        "pred_time": 0.001405954360961914,
        "orig_time": 0.0010433197021484375,
        "time_ratio": 0.7420722401220959,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "original_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "llm_output": "\nSELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'\n",
        "pred_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "pred_time": 0.21049046516418457,
        "orig_time": 0.21299362182617188,
        "time_ratio": 1.0118920192419871,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "original_query": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "llm_output": "-- Reasoning\nI need to retrieve the description of expenses.\nI will join the `expense` table with the `member` table to link expenses to members.\nThen, I will filter the results based on the `t_shirt_size` in the `member` table being 'X-Large'.\n\n-- SQL Query\nSELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';",
        "pred_query": "SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';",
        "pred_time": 0.0007681846618652344,
        "orig_time": 0.00054931640625,
        "time_ratio": 0.7150837988826816,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "original_query": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "llm_output": "-- Reasoning\nThe question asks for drivers born in 1971 who achieved the single fastest lap time in any race.\nI need to join the `drivers` table with the `results` table.\nFilter drivers whose birth year (from `dob`) is 1971.\nFilter results where `fastestLapTime` is not NULL.\nOrder the results by `fastestLapTime` in ascending order to find the fastest time.\nLimit the result to 1 to get the driver with that fastest time.\nFinally, select the `driverId` and `code` from the `drivers` table.\n\n-- SQL Query\nSELECT T1.driverId, T1.code FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE strftime('%Y', T1.dob) = '1971' AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1;",
        "pred_query": "SELECT T1.driverId, T1.code FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE strftime('%Y', T1.dob) = '1971' AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1;",
        "pred_time": 0.005429744720458984,
        "orig_time": 0.004946231842041016,
        "time_ratio": 0.9109510845701239,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the average age of patients examined in the laboratory for the October of the year 1991?",
        "original_query": "SELECT AVG('1999' - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "llm_output": "-- Reasoning\nTo find the average age, we need to join the `Patient` table with the `Laboratory` table on `ID`.\nWe then filter the `Laboratory` records to include only those from October 1991.\nFor each matching patient, calculate their age by subtracting their birth year from the examination year (1991).\nFinally, compute the average of these calculated ages.\n\n-- SQL Query\nSELECT AVG(STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.Date) = '1991' AND STRFTIME('%m', T2.Date) = '10';",
        "pred_query": "SELECT AVG(STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.Date) = '1991' AND STRFTIME('%m', T2.Date) = '10';",
        "pred_time": 0.006654500961303711,
        "orig_time": 0.003187417984008789,
        "time_ratio": 0.47898677940596895,
        "check": false
    },
    {
        "id": "financial",
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "original_query": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "llm_output": "-- Reasoning\nI need to find the `district_id` for a given `order_id`.\nThe `order` table contains `order_id` and `account_id`.\nThe `account` table contains `account_id` and `district_id`.\nI will join `order` and `account` tables on `account_id` and filter by the given `order_id`.\n\n-- SQL Query\nSELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_query": "SELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_time": 0.0008273124694824219,
        "orig_time": 0.00040268898010253906,
        "time_ratio": 0.4867435158501441,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "original_query": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "llm_output": "-- Reasoning\nI need to join the `Player` table with `Player_Attributes` on `player_api_id` to access both birthday and preferred foot information.\nThen, I will filter the players born between 1987 and 1992.\nFinally, I will calculate the ratio of left-footed players to the total players in this birth range and multiply by 100.\n\n-- SQL Query\nSELECT\n  CAST(SUM(CASE WHEN T2.preferred_foot = 'left' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.player_api_id)\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE\n  STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992';",
        "pred_query": "SELECT\n  CAST(SUM(CASE WHEN T2.preferred_foot = 'left' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.player_api_id)\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE\n  STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992';",
        "pred_time": 0.1572706699371338,
        "orig_time": 0.11558246612548828,
        "time_ratio": 0.7349270284897391,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the least common element of all carcinogenic molecules?",
        "original_query": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "llm_output": "-- Reasoning\nI need to find molecules with a `label` of '+'.\nThen, I will join these molecules with the `atom` table to get all elements present in them.\nI will count the occurrences of each element, order them by count ascending, and take the top one.\n\n-- SQL Query\nSELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T1.element ORDER BY COUNT(T1.element) ASC LIMIT 1;",
        "pred_query": "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T1.element ORDER BY COUNT(T1.element) ASC LIMIT 1;",
        "pred_time": 0.0038793087005615234,
        "orig_time": 0.0036377906799316406,
        "time_ratio": 0.9377419949603589,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "llm_output": "-- Reasoning\nTo find the percentage, we need to calculate two counts:\n1. The total number of unique drivers who were born before 1985 and participated in races between 2000 and 2005.\n2. The number of unique drivers from the above group who also had at least one lap number over 50.\nThe percentage will be (count 2 * 100.0) / count 1. We will join `drivers`, `lapTimes`, and `races` tables.\n\n-- SQL Query\nSELECT\n  CAST(COUNT(DISTINCT CASE WHEN T2.lap > 50 THEN T1.driverId ELSE NULL END) AS REAL) * 100.0 /\n  COUNT(DISTINCT T1.driverId)\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T2.raceId = T3.raceId\nWHERE\n  STRFTIME('%Y', T1.dob) < '1985' AND T3.year BETWEEN 2000 AND 2005;",
        "pred_query": "SELECT\n  CAST(COUNT(DISTINCT CASE WHEN T2.lap > 50 THEN T1.driverId ELSE NULL END) AS REAL) * 100.0 /\n  COUNT(DISTINCT T1.driverId)\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T2.raceId = T3.raceId\nWHERE\n  STRFTIME('%Y', T1.dob) < '1985' AND T3.year BETWEEN 2000 AND 2005;",
        "pred_time": 0.13290929794311523,
        "orig_time": 0.003743886947631836,
        "time_ratio": 0.02816873616497627,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "llm_output": "-- Reasoning\nI need to retrieve the `first_name` and `last_name` from the `member` table.\nTo filter by department, I need to join the `member` table with the `major` table using `link_to_major` and `major_id`.\nThen, I will filter the results where the `department` column in the `major` table is 'Art and Design'.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_time": 0.0007808208465576172,
        "orig_time": 0.0005311965942382812,
        "time_ratio": 0.6803053435114503,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "original_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to find the `setCode` for the card named \"Fellwar Stone\" from the `cards` table.\nThen, I will join with the `set_translations` table on `setCode`.\nFinally, I will filter for `language` = 'Japanese' and select the `translation`.\n\n-- SQL Query\nSELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese';",
        "pred_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese';",
        "pred_time": null,
        "orig_time": 0.0620884895324707,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Provide the name of superhero with superhero ID 294.",
        "original_query": "SELECT superhero_name FROM superhero WHERE id = 294",
        "llm_output": "-- Reasoning\nThe question asks for the name of a superhero given their ID.\nThe `superhero` table contains the `superhero_name` and `id` for each superhero.\nTherefore, I need to select the `superhero_name` from the `superhero` table and filter by the given `id`.\n\n-- SQL Query\nSELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_query": "SELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_time": 0.0008058547973632812,
        "orig_time": 0.0005035400390625,
        "time_ratio": 0.6248520710059171,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Mention the category of events which were held at MU 215.",
        "original_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "llm_output": "-- Reasoning\nI need to find the categories of events. The `category` information is in the `budget` table.\nThe `location` information is in the `event` table.\nBoth tables can be joined using `event.event_id` and `budget.link_to_event`.\nI will filter by `event.location = 'MU 215'` and select the `budget.category`.\n\n-- SQL Query\nSELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';",
        "pred_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';",
        "pred_time": 0.0010037422180175781,
        "orig_time": 0.0005776882171630859,
        "time_ratio": 0.5755344418052256,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Which group does superhero A-Bomb belong to?",
        "original_query": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'",
        "llm_output": "I need to find the publisher of the superhero 'A-Bomb'.\nI will join the `superhero` table with the `publisher` table using `publisher_id`.\nThen, I will filter the results for the superhero named 'A-Bomb' and select the publisher's name.\n\n\nSELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';\n",
        "pred_query": "select the publisher's name.\n\n\nSELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';",
        "pred_time": null,
        "orig_time": 0.0005810260772705078,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which year has the most number of races?",
        "original_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
        "llm_output": "SELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_time": 0.0015118122100830078,
        "orig_time": 0.0008034706115722656,
        "time_ratio": 0.531461914524523,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many posts were created by Daniel Vassallo?",
        "original_query": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "llm_output": "-- Reasoning\nTo find the number of posts created by a specific user, I need to join the `posts` table with the `users` table.\nThe join condition will be `posts.OwnerUserId = users.Id`.\nThen, I will filter the results using the `users.DisplayName` column for 'Daniel Vassallo' and count the distinct `posts.Id`.\n\n-- SQL Query\nSELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_query": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_time": 0.213331937789917,
        "orig_time": 0.3491997718811035,
        "time_ratio": 1.636884638553207,
        "check": false
    },
    {
        "id": "financial",
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "original_query": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "llm_output": "-- Reasoning\nTo find the percentage, I need to count the number of male clients who have an account with 'weekly issuance' frequency and divide it by the total number of male clients.\nI will join `client` with `disp` and `account` tables to link clients to their accounts and their respective statement frequencies.\nThen, I will filter for male clients and count those with 'weekly issuance' frequency, and the total male clients to calculate the percentage.\n\n-- SQL Query\nSELECT CAST(COUNT(DISTINCT T1.client_id) AS REAL) * 100 / (SELECT COUNT(DISTINCT client_id) FROM client WHERE gender = 'M') FROM client AS T1 JOIN disp AS T2 ON T1.client_id = T2.client_id JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M' AND T3.frequency = 'weekly issuance';",
        "pred_query": "SELECT CAST(COUNT(DISTINCT T1.client_id) AS REAL) * 100 / (SELECT COUNT(DISTINCT client_id) FROM client WHERE gender = 'M') FROM client AS T1 JOIN disp AS T2 ON T1.client_id = T2.client_id JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M' AND T3.frequency = 'weekly issuance';",
        "pred_time": 0.0023584365844726562,
        "orig_time": 0.0069735050201416016,
        "time_ratio": 2.9568338050950262,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "original_query": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the maximum value of the 'Percent (%) Eligible Free (K-12)' column.\nThis value must be for schools located in 'Alameda County'.\nBoth `Percent (%) Eligible Free (K-12)` and `County Name` are available in the `frpm` table.\nI will use a `WHERE` clause to filter by county and `MAX()` to find the highest rate.\n\n-- SQL Query\nSELECT MAX(`Percent (%) Eligible Free (K-12)`) FROM frpm WHERE `County Name` = 'Alameda';",
        "pred_query": "SELECT MAX(`Percent (%) Eligible Free (K-12)`) FROM frpm WHERE `County Name` = 'Alameda';",
        "pred_time": 0.003856182098388672,
        "orig_time": 0.003493070602416992,
        "time_ratio": 0.9058365277606034,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "original_query": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "llm_output": "-- Reasoning\nI need to find the `OwnerUserId` from the `posts` table for the post with `Id` 65041.\nThen, I will use this `OwnerUserId` to join with the `users` table to retrieve the `Reputation` of that user.\n\n-- SQL Query\nSELECT T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 65041;",
        "pred_query": "SELECT T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 65041;",
        "pred_time": 0.0008318424224853516,
        "orig_time": 0.0005154609680175781,
        "time_ratio": 0.6196617942103755,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "original_query": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the fastest lap speed, which is stored in the `results` table.\nThe question specifies a particular race by `year` and `name`, which are in the `races` table.\nTherefore, I will join `results` and `races` tables on `raceId`.\nThen, I will filter the results for the specified race and find the maximum `fastestLapSpeed`.\n\n-- SQL Query\nSELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_query": "SELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_time": 0.0033283233642578125,
        "orig_time": 0.003283262252807617,
        "time_ratio": 0.9864613180515759,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many high-level credit cards have \"disponent\" type of disposition?",
        "original_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'DISPONENT'",
        "llm_output": "-- Reasoning\nI need to count cards that are both 'high-level' and linked to a 'disponent' disposition.\nHigh-level cards are typically 'junior' or 'gold' based on common card types.\nI will join the `card` table with the `disp` table on `disp_id`.\nThen, I will filter `card.type` for 'junior' or 'gold' and `disp.type` for 'Disponent'.\n\n-- SQL Query\nSELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type IN ('junior', 'gold') AND T2.type = 'Disponent';",
        "pred_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type IN ('junior', 'gold') AND T2.type = 'Disponent';",
        "pred_time": 0.0010476112365722656,
        "orig_time": 0.0006518363952636719,
        "time_ratio": 0.622212107419208,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List all of the College of Humanities and Social Sciences' departments.",
        "original_query": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "llm_output": "-- Reasoning\nI need to retrieve department names from the 'major' table.\nThe condition is to filter by 'college' being 'College of Humanities and Social Sciences'.\nI should select distinct department names to avoid duplicates.\n\n-- SQL Query\nSELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "pred_query": "SELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "pred_time": 0.0009870529174804688,
        "orig_time": 0.0004992485046386719,
        "time_ratio": 0.5057971014492754,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List the expansion type of the set \"Huiti\u00c3\u00a8me \u00c3\u00a9dition\".",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition' )",
        "llm_output": "-- Reasoning\nThe question asks for the expansion type of a set identified by its translated name.\nI need to join `set_translations` table with the `sets` table.\nFilter `set_translations` by the provided `translation` and then select the `type` from the `sets` table.\n\n\nSELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';\n",
        "pred_query": "select the `type` from the `sets` table.\n\n\nSELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';",
        "pred_time": null,
        "orig_time": 0.010685920715332031,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "student_club",
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "original_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
        "llm_output": "\nSELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';\n",
        "pred_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';",
        "pred_time": 0.0008995532989501953,
        "orig_time": 0.0005421638488769531,
        "time_ratio": 0.6027034190299496,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List down at least five superpowers of male superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
        "llm_output": "SELECT DISTINCT T3.power_name FROM superhero AS T1 JOIN gender AS T2 ON T1.gender_id = T2.id JOIN hero_power AS T4 ON T1.id = T4.hero_id JOIN superpower AS T3 ON T4.power_id = T3.id WHERE T2.gender = 'Male' LIMIT 5",
        "pred_query": "SELECT DISTINCT T3.power_name FROM superhero AS T1 JOIN gender AS T2 ON T1.gender_id = T2.id JOIN hero_power AS T4 ON T1.id = T4.hero_id JOIN superpower AS T3 ON T4.power_id = T3.id WHERE T2.gender = 'Male' LIMIT 5",
        "pred_time": 0.0011603832244873047,
        "orig_time": 0.0005090236663818359,
        "time_ratio": 0.4386685843435381,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "For the race happened in 2015/11/29, how many drivers finished the game?",
        "original_query": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "llm_output": "\nSELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;\n",
        "pred_query": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;",
        "pred_time": 0.0039031505584716797,
        "orig_time": 0.003304004669189453,
        "time_ratio": 0.8464968541933907,
        "check": true
    },
    {
        "id": "superhero",
        "question": "How many superheroes are published by Marvel Comics?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "llm_output": "-- Reasoning\nTo count superheroes by publisher, I need to join the `superhero` table with the `publisher` table.\nI will filter the results where the `publisher_name` is 'Marvel Comics'.\nFinally, I will count the distinct `id` from the `superhero` table.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_time": 0.0009238719940185547,
        "orig_time": 0.0005674362182617188,
        "time_ratio": 0.6141935483870967,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "original_query": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "llm_output": "SELECT time FROM lapTimes ORDER BY milliseconds ASC LIMIT 1;",
        "pred_query": "SELECT time FROM lapTimes ORDER BY milliseconds ASC LIMIT 1;",
        "pred_time": 0.034392595291137695,
        "orig_time": 0.2854912281036377,
        "time_ratio": 8.300950413509598,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Give the publisher ID of Star Trek.",
        "original_query": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
        "llm_output": "-- Reasoning\nThe question asks for the publisher ID of 'Star Trek'.\nThe `superhero` table contains the `superhero_name` and `publisher_id`.\nI need to filter the `superhero` table by `superhero_name` = 'Star Trek' and select the `publisher_id`.\n\n-- SQL Query\nSELECT publisher_id FROM superhero WHERE superhero_name = 'Star Trek';",
        "pred_query": "SELECT publisher_id FROM superhero WHERE superhero_name = 'Star Trek';",
        "pred_time": 0.0008723735809326172,
        "orig_time": 0.0004150867462158203,
        "time_ratio": 0.4758130636786007,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the name of the race held on the circuits in Germany.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "llm_output": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'",
        "pred_time": 0.0012412071228027344,
        "orig_time": 0.0008213520050048828,
        "time_ratio": 0.661736457933154,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "original_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'",
        "llm_output": "-- Reasoning\nI need to find the `Id` of the post with the specified title from the `posts` table.\nThen, I will use this `PostId` to query the `comments` table and retrieve the `Text` of all comments associated with that post.\nThis requires a join or a subquery. A subquery is straightforward for this case.\n\n-- SQL Query\nSELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_time": 0.2216188907623291,
        "orig_time": 0.22685623168945312,
        "time_ratio": 1.023632195383293,
        "check": true
    },
    {
        "id": "financial",
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "original_query": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "llm_output": "\nSELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE strftime('%Y', T1.date) = '1993' AND T1.frequency = 'POPLATEK PO OBRATU';\n",
        "pred_query": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE strftime('%Y', T1.date) = '1993' AND T1.frequency = 'POPLATEK PO OBRATU';",
        "pred_time": 0.002225160598754883,
        "orig_time": 0.0008592605590820312,
        "time_ratio": 0.3861566484517304,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Which website should I go to if I want to know more about Anthony Davidson?",
        "original_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
        "llm_output": "-- Reasoning\nThe question asks for the website to learn more about a specific driver, \"Anthony Davidson\".\nThe `drivers` table contains information about drivers, including their `forename`, `surname`, and `url`.\nI need to query the `drivers` table, filter by the driver's name, and select the `url` column.\n\n-- SQL Query\nSELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "pred_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "pred_time": 0.0010766983032226562,
        "orig_time": 0.0007450580596923828,
        "time_ratio": 0.6919840566873339,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
        "original_query": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
        "llm_output": "-- Reasoning\nI need to first filter for molecules that are carcinogenic (label = '+').\nThen, for these carcinogenic molecules, I need to count the number of double bonds (bond_type = '=').\nFinally, I will find the molecule_id among these with the highest count of double bonds.\n\n-- SQL Query\nSELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' AND T2.bond_type = '=' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_id) DESC LIMIT 1;",
        "pred_query": "SELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' AND T2.bond_type = '=' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_id) DESC LIMIT 1;",
        "pred_time": 0.002203226089477539,
        "orig_time": 0.001688241958618164,
        "time_ratio": 0.7662590628719835,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
        "original_query": "SELECT NCESDist FROM schools WHERE SOC = 31",
        "llm_output": "-- Reasoning\nThe question asks for the National Center for Educational Statistics school district identification number (`NCESDist`).\nThis information is available in the `schools` table.\nThe filtering condition is based on \"School Ownership Code that are part of the State Special Schools\", which corresponds to the `SOCType` column in the `schools` table having the value 'State Special Schools'.\n\n-- SQL Query\nSELECT NCESDist FROM schools WHERE SOCType = 'State Special Schools';",
        "pred_query": "SELECT NCESDist FROM schools WHERE SOCType = 'State Special Schools';",
        "pred_time": 0.014831304550170898,
        "orig_time": 0.01761913299560547,
        "time_ratio": 1.1879691996077613,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List the power of superheroes with height greater than 80% of the average height of all superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm * 100 > ( SELECT AVG(height_cm) FROM superhero ) * 80",
        "llm_output": "-- Reasoning\nFirst, calculate the average height of all superheroes.\nThen, identify superheroes whose height is greater than 80% of this average height.\nFinally, join these superheroes with the `hero_power` and `superpower` tables to list their powers.\n\n-- SQL Query\nSELECT DISTINCT\n  T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2\n  ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3\n  ON T2.power_id = T3.id\nWHERE\n  T1.height_cm > (\n    SELECT\n      AVG(height_cm) * 0.8\n    FROM superhero\n  );",
        "pred_query": "SELECT DISTINCT\n  T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2\n  ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3\n  ON T2.power_id = T3.id\nWHERE\n  T1.height_cm > (\n    SELECT\n      AVG(height_cm) * 0.8\n    FROM superhero\n  );",
        "pred_time": 0.0015559196472167969,
        "orig_time": 0.001302957534790039,
        "time_ratio": 0.8374195525589948,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "original_query": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
        "llm_output": "-- Reasoning\nTo find the average long shots for a player, I need to join the `Player` table with the `Player_Attributes` table on `player_api_id`.\nThen, I will filter by the player's name 'Ahmed Samir Farag' and calculate the average of the `long_shots` column.\n\n-- SQL Query\nSELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';",
        "pred_query": "SELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';",
        "pred_time": 0.10386013984680176,
        "orig_time": 0.10148262977600098,
        "time_ratio": 0.9771085415992342,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What are the card layout of cards with keyword of flying?",
        "original_query": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to query the `cards` table.\nI will filter the rows where the `keywords` column contains the word 'Flying'.\nThen, I will select the `layout` column from these filtered rows.\nI should use `DISTINCT` to get unique layout types.\n\n-- SQL Query\nSELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%';",
        "pred_query": "SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%';",
        "pred_time": 0.058802127838134766,
        "orig_time": 0.05786919593811035,
        "time_ratio": 0.9841343853645482,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "original_query": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "llm_output": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton';",
        "pred_query": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton';",
        "pred_time": 0.0063893795013427734,
        "orig_time": 0.005426645278930664,
        "time_ratio": 0.8493227359229822,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "original_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "llm_output": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_time": 0.010408878326416016,
        "orig_time": 0.009036779403686523,
        "time_ratio": 0.8681799441110449,
        "check": true
    }
]