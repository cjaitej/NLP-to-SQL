[
    {
        "id": "european_football_2",
        "question": "Please list all team names which the speed class is fast.",
        "original_query": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "llm_output": "\nSELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast';\n",
        "pred_query": "SELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast';",
        "pred_time": 0.0031554698944091797,
        "orig_time": 0.002934694290161133,
        "time_ratio": 0.9300340007555723,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "How many circuits are there in Melbourne, Australia?",
        "original_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia'",
        "llm_output": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';",
        "pred_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';",
        "pred_time": 0.0021560192108154297,
        "orig_time": 0.0012843608856201172,
        "time_ratio": 0.5957093884772753,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many Formula_1 races took place on the circuits in Italy?",
        "original_query": "SELECT COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Italy'",
        "llm_output": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';",
        "pred_query": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';",
        "pred_time": 0.001796722412109375,
        "orig_time": 0.0011832714080810547,
        "time_ratio": 0.6585721868365181,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "original_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "llm_output": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 1.0 / COUNT(id) FROM cards;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 1.0 / COUNT(id) FROM cards;",
        "pred_time": 0.10919952392578125,
        "orig_time": 0.09759759902954102,
        "time_ratio": 0.893754803325648,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What's the magic card market name for the set which was released on 2017/6/9?",
        "original_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "llm_output": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "pred_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "pred_time": 0.015494823455810547,
        "orig_time": 0.006634950637817383,
        "time_ratio": 0.4282043391290968,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the percentage of molecules that are carcinogenic?",
        "original_query": "SELECT CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id) FROM molecule t",
        "llm_output": "-- Reasoning\nTo find the percentage of carcinogenic molecules, we need to count the molecules with a label of '+' and divide it by the total number of molecules.\nBoth counts can be obtained directly from the `molecule` table.\nThe result should be cast to REAL to ensure accurate floating-point percentage calculation.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.molecule_id) FROM molecule AS T1;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.molecule_id) FROM molecule AS T1;",
        "pred_time": 0.0012900829315185547,
        "orig_time": 0.0009129047393798828,
        "time_ratio": 0.7076326002587322,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What is the percentage of borderless cards?",
        "original_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "llm_output": "-- Reasoning\nTo find the percentage of borderless cards, I need to count all cards and count cards with 'borderless' as their borderColor.\nThen, I will divide the count of borderless cards by the total count of cards and multiply by 100.\nAll necessary information is available in the 'cards' table.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_time": 0.10468244552612305,
        "orig_time": 0.09820055961608887,
        "time_ratio": 0.9380804883048262,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "original_query": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe question asks for the `budget_id` that \"allowed the most money\" for specific items (water, chips, and cookies).\n\"Allowed the most money\" refers to the `amount` column in the `budget` table.\nThe condition \"for water, chips, and cookies\" implies that the budget must be associated with expenses containing these descriptions.\nTo satisfy \"water, chips, and cookies\", a budget must have at least one expense for 'water', at least one for 'chips', and at least one for 'cookies'.\nWe can find the `budget_id`s that meet this criteria by joining `budget` and `expense` tables and using `INTERSECT` to combine the sets of budget IDs related to each item.\nFinally, from this filtered set of `budget_id`s, we select the one with the maximum `amount` from the `budget` table.\n\n-- SQL Query\nSELECT budget_id FROM budget WHERE budget_id IN ( SELECT T1.budget_id FROM budget AS T1 JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description LIKE '%water%' INTERSECT SELECT T1.budget_id FROM budget AS T1 JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description LIKE '%chips%' INTERSECT SELECT T1.budget_id FROM budget AS T1 JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description LIKE '%cookies%' ) ORDER BY amount DESC LIMIT 1;",
        "pred_query": "SELECT budget_id FROM budget WHERE budget_id IN ( SELECT T1.budget_id FROM budget AS T1 JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description LIKE '%water%' INTERSECT SELECT T1.budget_id FROM budget AS T1 JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description LIKE '%chips%' INTERSECT SELECT T1.budget_id FROM budget AS T1 JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description LIKE '%cookies%' ) ORDER BY amount DESC LIMIT 1;",
        "pred_time": 0.001668691635131836,
        "orig_time": 0.0007059574127197266,
        "time_ratio": 0.42306043720531505,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "original_query": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "llm_output": "-- Reasoning\nI need to join the `Patient` and `Laboratory` tables to access patient sex and laboratory results.\nI will filter for female patients (`SEX = 'F'`) and those whose total protein (TP) is outside the normal range (TP < 6.0 or TP > 8.5), based on the provided examples.\nFor each such patient, I will calculate the absolute deviation from the closest normal boundary using a CASE statement.\nThe deviation is (6.0 - TP) if TP is below 6.0, and (TP - 8.5) if TP is above 8.5.\n\n-- SQL Query\nSELECT\n  T1.ID,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0\n    THEN 6.0 - T2.TP\n    WHEN T2.TP > 8.5\n    THEN T2.TP - 8.5\n    ELSE 0 -- Should not happen given the WHERE clause\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'F' AND (\n    T2.TP < 6.0 OR T2.TP > 8.5\n  );",
        "pred_query": "SELECT\n  T1.ID,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0\n    THEN 6.0 - T2.TP\n    WHEN T2.TP > 8.5\n    THEN T2.TP - 8.5\n    ELSE 0 -- Should not happen given the WHERE clause\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'F' AND (\n    T2.TP < 6.0 OR T2.TP > 8.5\n  );",
        "pred_time": 0.008020639419555664,
        "orig_time": 0.006340980529785156,
        "time_ratio": 0.7905829196516155,
        "check": false
    },
    {
        "id": "card_games",
        "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
        "original_query": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "llm_output": "-- Reasoning\nFirst, find the 'setCode' for the card \"Ancestor's Chosen\" from the 'cards' table.\nThen, use this 'setCode' to retrieve the 'releaseDate' from the 'sets' table.\nThis requires a JOIN between 'cards' and 'sets' tables on their respective code columns.\n\n-- SQL Query\nSELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor''s Chosen'",
        "pred_query": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor''s Chosen'",
        "pred_time": 0.10558938980102539,
        "orig_time": 0.09786605834960938,
        "time_ratio": 0.9268550422919386,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "original_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "llm_output": "\nSELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna';\n",
        "pred_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna';",
        "pred_time": 0.0025441646575927734,
        "orig_time": 0.002008676528930664,
        "time_ratio": 0.7895230062786993,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "original_query": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "llm_output": "-- Reasoning\nI need to retrieve the `Percent (%) Eligible Free (Ages 5-17)` from the `frpm` table.\nThe `frpm` table can be linked to the `schools` table using the `CDSCode` column.\nI need to filter the `schools` table for an administrator named 'Kacey Gibson', which could be in any of the `AdmFName` and `AdmLName` columns (1, 2, or 3).\n\nSELECT T1.`Percent (%) Eligible Free (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE (T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson') OR (T2.AdmFName2 = 'Kacey' AND T2.AdmLName2 = 'Gibson') OR (T2.AdmFName3 = 'Kacey' AND T2.AdmLName3 = 'Gibson');",
        "pred_query": "SELECT T1.`Percent (%) Eligible Free (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE (T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson') OR (T2.AdmFName2 = 'Kacey' AND T2.AdmLName2 = 'Gibson') OR (T2.AdmFName3 = 'Kacey' AND T2.AdmLName3 = 'Gibson');",
        "pred_time": 0.02411031723022461,
        "orig_time": 0.015180826187133789,
        "time_ratio": 0.6296402507762593,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "original_query": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "llm_output": "\nSELECT DISTINCT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0\n",
        "pred_query": "SELECT DISTINCT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "pred_time": 0.024733781814575195,
        "orig_time": 0.014739751815795898,
        "time_ratio": 0.5959360330052728,
        "check": false
    },
    {
        "id": "student_club",
        "question": "What's Angela Sanders's major?",
        "original_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "llm_output": "-- Reasoning\nTo find Angela Sanders's major, I need to look up her record in the `member` table.\nThen, I will use the `link_to_major` column from the `member` table to join with the `major` table.\nFinally, I will select the `major_name` from the `major` table.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_time": 0.0018091201782226562,
        "orig_time": 0.0011072158813476562,
        "time_ratio": 0.6120189773326304,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "llm_output": "-- Reasoning\nThe question requires counting distinct patients who satisfy two conditions: having a normal RNP level and having an admission record.\nThe `Laboratory` table contains the `RNP` level. Assuming 'normal' means RNP is neither '-' nor '+-', based on common patterns in the database examples.\nThe `Patient` table contains the `Admission` information. We will assume 'admitted' means the `Admission` column is not NULL and not an empty string.\nWe need to join `Patient` and `Laboratory` tables on `ID` to apply both conditions and then count distinct patient IDs.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RNP IS NULL OR (T2.RNP != '-' AND T2.RNP != '+-')) AND T1.Admission IS NOT NULL AND T1.Admission != '';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RNP IS NULL OR (T2.RNP != '-' AND T2.RNP != '+-')) AND T1.Admission IS NOT NULL AND T1.Admission != '';",
        "pred_time": 0.010354042053222656,
        "orig_time": 0.009685516357421875,
        "time_ratio": 0.9354333609652759,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "original_query": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' THEN 1 ELSE NULL END) FROM cards",
        "llm_output": "-- Reasoning\nI need to count distinct artists from the 'cards' table.\nThe conditions are that the card must have a 'black' border color.\nAdditionally, the card's 'availability' must include both 'arena' and 'mtgo'. This can be checked using LIKE or INSTR.\n\n-- SQL Query\nSELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%';",
        "pred_query": "SELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%';",
        "pred_time": 0.1239938735961914,
        "orig_time": 0.10950446128845215,
        "time_ratio": 0.8831441273064291,
        "check": false
    },
    {
        "id": "superhero",
        "question": "What is the name of the superhero that has the most powers?",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to count the number of powers for each superhero.\nI will join `superhero` and `hero_power` tables.\nThen, I will group the results by superhero name and count the powers.\nFinally, I will order by the count in descending order and limit to 1 to find the superhero with the most powers.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_time": 0.0038814544677734375,
        "orig_time": 0.0029506683349609375,
        "time_ratio": 0.7601965601965602,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to join the Laboratory and Examination tables on the patient ID.\nI will filter the Laboratory table for 'normal' anti-SSB, which is 'negative' or '0'.\nThen, I will filter the Examination table for patients who have symptoms, meaning the Symptoms column is not NULL and not an empty string.\nFinally, I will count the distinct patient IDs that satisfy both conditions.\n\nSELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SSB IN ('negative', '0') AND T2.Symptoms IS NOT NULL AND T2.Symptoms != '';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SSB IN ('negative', '0') AND T2.Symptoms IS NOT NULL AND T2.Symptoms != '';",
        "pred_time": 0.014539957046508789,
        "orig_time": 0.0035703182220458984,
        "time_ratio": 0.2455521849635156,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "original_query": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "llm_output": "-- Reasoning\nI need to count the number of distinct male patients whose creatinine (CRE) levels are not within the normal range, which I will interpret as CRE >= 1.5 based on previous examples.\nThen, I need to count the number of distinct female patients with the same condition.\nFinally, I will compare these two counts to determine if the male count is greater than the female count, returning True or False.\n\n-- SQL Query\nSELECT\n  (\n    SELECT\n      COUNT(DISTINCT T1.ID)\n    FROM Patient AS T1\n    INNER JOIN Laboratory AS T2\n      ON T1.ID = T2.ID\n    WHERE\n      T1.SEX = 'M' AND T2.CRE >= 1.5\n  ) > (\n    SELECT\n      COUNT(DISTINCT T1.ID)\n    FROM Patient AS T1\n    INNER JOIN Laboratory AS T2\n      ON T1.ID = T2.ID\n    WHERE\n      T1.SEX = 'F' AND T2.CRE >= 1.5\n  );",
        "pred_query": "SELECT\n  (\n    SELECT\n      COUNT(DISTINCT T1.ID)\n    FROM Patient AS T1\n    INNER JOIN Laboratory AS T2\n      ON T1.ID = T2.ID\n    WHERE\n      T1.SEX = 'M' AND T2.CRE >= 1.5\n  ) > (\n    SELECT\n      COUNT(DISTINCT T1.ID)\n    FROM Patient AS T1\n    INNER JOIN Laboratory AS T2\n      ON T1.ID = T2.ID\n    WHERE\n      T1.SEX = 'F' AND T2.CRE >= 1.5\n  );",
        "pred_time": 0.014156103134155273,
        "orig_time": 0.009444713592529297,
        "time_ratio": 0.6671831578947368,
        "check": false
    },
    {
        "id": "student_club",
        "question": "List the name of students that have attended more than 7 events.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "llm_output": "-- Reasoning\nI need to join the `member` table with the `attendance` table to link members to the events they attended.\nThen, I will group the results by member to count the number of events each member attended.\nFinally, I will filter these groups to only include members who attended more than 7 events and select their first and last names.\n\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_query": "select their first and last names.\n\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_time": null,
        "orig_time": 0.0015361309051513672,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many female customers have a junior credit card?",
        "original_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "llm_output": "-- Reasoning\nI need to join the `client`, `disp`, and `card` tables.\nFilter `client` for 'F' gender and `card` for 'junior' type.\nThen, count the distinct `client_id`s that satisfy both conditions.\n\nSELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 JOIN disp AS T2 ON T1.client_id = T2.client_id JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior';",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 JOIN disp AS T2 ON T1.client_id = T2.client_id JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior';",
        "pred_time": 0.0024499893188476562,
        "orig_time": 0.0018143653869628906,
        "time_ratio": 0.7405605293888673,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "original_query": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "llm_output": "-- Reasoning\nTo determine if a bond connects atoms of both chlorine and carbon, we need to:\n1. Identify the atoms involved in the bond 'TR001_1_8' using the `connected` table.\n2. Retrieve the elements of these identified atoms from the `atom` table.\n3. Check if the set of elements connected by this bond contains both 'cl' and 'c'. This can be done by filtering for 'cl' or 'c' elements among the connected atoms and counting the distinct results. If the count is 2, then both elements are present.\n\n-- SQL Query\nSELECT\n  CASE\n    WHEN COUNT(DISTINCT T1.element) = 2 THEN 'Yes'\n    ELSE 'No'\n  END\nFROM atom AS T1\nINNER JOIN connected AS T2\n  ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2\nWHERE\n  T2.bond_id = 'TR001_1_8' AND T1.element IN ('cl', 'c');",
        "pred_query": "SELECT\n  CASE\n    WHEN COUNT(DISTINCT T1.element) = 2 THEN 'Yes'\n    ELSE 'No'\n  END\nFROM atom AS T1\nINNER JOIN connected AS T2\n  ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2\nWHERE\n  T2.bond_id = 'TR001_1_8' AND T1.element IN ('cl', 'c');",
        "pred_time": 0.004227638244628906,
        "orig_time": 0.0034427642822265625,
        "time_ratio": 0.8143469433792014,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "llm_output": "-- Reasoning\nThe question asks for the count of patients with a \"normal Ig G level\" and \"symptoms\".\nBased on a previous example (`IGG < 900` being \"lower than normal\"), \"normal Ig G level\" is interpreted as `IGG >= 900`.\nPatients \"have symptoms\" if the `Symptoms` column in the `Examination` table is not NULL.\nWe need to join `Patient`, `Laboratory`, and `Examination` tables on `ID` and apply the filters.\nFinally, count the distinct `ID`s of these patients.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.IGG >= 900 AND T3.Symptoms IS NOT NULL;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.IGG >= 900 AND T3.Symptoms IS NOT NULL;",
        "pred_time": 0.012479782104492188,
        "orig_time": 0.0018894672393798828,
        "time_ratio": 0.15140226195934586,
        "check": false
    },
    {
        "id": "financial",
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "original_query": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.district_id = ( SELECT district_id FROM client ORDER BY birth_date DESC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe query needs to find the account_id of the client who is both the youngest and associated with the district that has the highest average salary.\nThis requires joining the `client`, `district`, and `account` tables.\nWe will order by `birth_date` in descending order to find the youngest client, and then by `A11` (average salary) in descending order to find the highest average salary.\nFinally, we will limit the result to 1 to get the single account that meets these combined criteria.\n\n-- SQL Query\nSELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T1.district_id = T3.district_id ORDER BY T1.birth_date DESC, T2.A11 DESC LIMIT 1;",
        "pred_query": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T1.district_id = T3.district_id ORDER BY T1.birth_date DESC, T2.A11 DESC LIMIT 1;",
        "pred_time": 0.07603859901428223,
        "orig_time": 0.002167940139770508,
        "time_ratio": 0.028511047913485448,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
        "original_query": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
        "llm_output": "-- Reasoning\nI need to count the number of races held at each circuit between 1990 and 2000.\nI will join the `races` table with the `circuits` table.\nFilter the `races` by `year` between 1990 and 2000.\nGroup the results by `circuitId` and `circuit` name.\nThen, I will use a `HAVING` clause to select only those circuits where the count of races is equal to 4.\n\n-- SQL Query\nSELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year >= 1990 AND T2.year <= 2000 GROUP BY T1.circuitId HAVING COUNT(T2.raceId) = 4;",
        "pred_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year >= 1990 AND T2.year <= 2000 GROUP BY T1.circuitId HAVING COUNT(T2.raceId) = 4;",
        "pred_time": 0.0021448135375976562,
        "orig_time": 0.0015442371368408203,
        "time_ratio": 0.7199866607381058,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to count the number of superheroes for 'DC Comics' and 'Marvel Comics' separately.\nThen, I will calculate the absolute difference between these two counts.\nThis can be achieved by joining the `superhero` and `publisher` tables and using conditional aggregation to count superheroes for each specified publisher, then subtracting the results.\n\n-- SQL Query\nSELECT\n  ABS(SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_query": "SELECT\n  ABS(SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_time": 0.0014934539794921875,
        "orig_time": 0.0011951923370361328,
        "time_ratio": 0.8002873563218391,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Please list the names of the badges obtained by csgillespie.",
        "original_query": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "llm_output": "-- Reasoning\nTo find the names of badges obtained by a specific user, I need to join the `badges` table with the `users` table on `UserId` and `Id` respectively.\nThen, I will filter the results where the `DisplayName` in the `users` table is 'csgillespie'.\nFinally, I will select the `Name` from the `badges` table.\n\n-- SQL Query\nSELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_query": "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_time": 0.11217188835144043,
        "orig_time": 0.10225439071655273,
        "time_ratio": 0.9115866035542198,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "original_query": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "llm_output": "\nSELECT T2.team_long_name FROM Match AS T1 INNER JOIN Team AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN League AS T3 ON T1.league_id = T3.id WHERE T3.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T2.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1\n",
        "pred_query": "SELECT T2.team_long_name FROM Match AS T1 INNER JOIN Team AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN League AS T3 ON T1.league_id = T3.id WHERE T3.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T2.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1",
        "pred_time": 0.13283848762512207,
        "orig_time": 0.1136465072631836,
        "time_ratio": 0.8555239471251783,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the bond type for atoms with element Tin?",
        "original_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "llm_output": "-- Reasoning\nTo find the bond types for atoms with element 'Tin', I need to join the `atom` table (to filter by element) with the `connected` table (to link atoms to bonds) and then with the `bond` table (to retrieve the bond type).\nAn atom can be either `atom_id` or `atom_id2` in the `connected` table, so the join condition needs to account for both possibilities.\nFinally, select the distinct bond types.\n\n-- SQL Query\nSELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2 INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Sn';",
        "pred_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2 INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Sn';",
        "pred_time": 0.04830431938171387,
        "orig_time": 0.02363872528076172,
        "time_ratio": 0.48937083853644814,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "original_query": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "llm_output": "-- Reasoning\nTo find the status of a card, I need to look into the `legalities` table.\nThe `legalities` table contains the 'status' and is linked to the `cards` table by `uuid`.\nI will join `cards` and `legalities` on their shared `uuid` column.\nThen, I will filter the results by the `name` column in the `cards` table, looking for 'Cloudchaser Eagle'.\n\n-- SQL Query\nSELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "pred_query": "SELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "pred_time": 0.6176948547363281,
        "orig_time": 0.6534607410430908,
        "time_ratio": 1.0579021923730123,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "llm_output": "-- Reasoning\nThe question asks to count \"examinations\" that meet two conditions:\n1. The examination's date is after '1997-01-01'. This refers to the `Examination Date` column in the `Examination` table.\n2. The examination \"has the result of an inactivated partial prothrom bin time\". This refers to the `APTT` column in the `Laboratory` table. Interpreting \"has the result\" as `APTT IS NOT NULL`.\nSince \"examinations\" are records in the `Examination` table, and `ID` is a foreign key to `Patient` (meaning `ID` alone is not unique in `Examination`), an examination is identified by its `ID` and `Examination Date`.\nWe need to count how many distinct `Examination` records (identified by `ID` and `Examination Date`) satisfy these conditions. An `EXISTS` clause is suitable for checking if an associated `Laboratory` record exists for the same patient (`ID`) with a non-null `APTT`.\n\n-- SQL Query\nSELECT COUNT(*)\nFROM Examination AS T1\nWHERE T1.`Examination Date` > '1997-01-01'\n  AND EXISTS (SELECT 1 FROM Laboratory AS T2 WHERE T2.ID = T1.ID AND T2.APTT IS NOT NULL);",
        "pred_query": "SELECT COUNT(*)\nFROM Examination AS T1\nWHERE T1.`Examination Date` > '1997-01-01'\n  AND EXISTS (SELECT 1 FROM Laboratory AS T2 WHERE T2.ID = T1.ID AND T2.APTT IS NOT NULL);",
        "pred_time": 0.0024878978729248047,
        "orig_time": 0.00859212875366211,
        "time_ratio": 3.4535697172975564,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'Owner' AND T1.frequency = 'POPLATEK TYDNE'",
        "llm_output": "-- Reasoning\nI need to count customers based on their account frequency and role.\nJoin `account` and `disp` tables on `account_id` to link accounts to their 'owner' or 'disponent' roles.\nFilter `account` records where `frequency` is 'POPLATEK TYDNE' (weekly issuance).\nFilter `disp` records where `type` is 'OWNER'.\nCount the distinct `client_id`s from the filtered results.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T2.client_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_query": "SELECT COUNT(DISTINCT T2.client_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_time": 0.0027511119842529297,
        "orig_time": 0.0011146068572998047,
        "time_ratio": 0.4051477597712107,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "How many users received commentator badges in 2014?",
        "original_query": "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'",
        "llm_output": "-- Reasoning\nI need to count the number of unique users.\nI will filter the `badges` table for badges named 'commentator'.\nThen, I will further filter these badges for the year 2014 using the `Date` column.\nFinally, I will count the distinct `UserId`s from the filtered results.\n\n-- SQL Query\nSELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'commentator' AND STRFTIME('%Y', Date) = '2014';",
        "pred_query": "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'commentator' AND STRFTIME('%Y', Date) = '2014';",
        "pred_time": 0.013555526733398438,
        "orig_time": 0.013696670532226562,
        "time_ratio": 1.0104122695933586,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "How many users are awarded with more than 5 badges?",
        "original_query": "SELECT UserId FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "llm_output": "-- Reasoning\nI need to count the number of badges for each user.\nI will join `users` and `badges` tables, group by `UserId`, and count badges.\nThen, I'll filter these groups to keep only users with more than 5 badges using `HAVING`.\nFinally, I will count the distinct users from the filtered result.\n\n-- SQL Query\nSELECT COUNT(T1.Id) FROM users AS T1 JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T1.Id HAVING COUNT(T2.Id) > 5;",
        "pred_query": "SELECT COUNT(T1.Id) FROM users AS T1 JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T1.Id HAVING COUNT(T2.Id) > 5;",
        "pred_time": 0.07696104049682617,
        "orig_time": 0.05385899543762207,
        "time_ratio": 0.6998215602327152,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "original_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "llm_output": "-- Reasoning\nI need to retrieve the `Title` from the `posts` table.\nTo identify the posts edited by a specific user, I need to join `posts` with the `users` table.\nThe join condition should be `posts.LastEditorUserId = users.Id`.\nFinally, I will filter the results where `users.DisplayName` is 'Vebjorn Ljosa'.\n\n-- SQL Query\nSELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_time": 0.27990102767944336,
        "orig_time": 0.36559247970581055,
        "time_ratio": 1.3061491154098417,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What percentage of cards without power are in French?",
        "original_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power LIKE '%*%'",
        "llm_output": "-- Reasoning\nTo find the percentage of cards without power that are in French, we need two counts:\n1. The number of unique cards that have no power AND have a French translation.\n2. The total number of unique cards that have no power.\nWe will then divide the first count by the second and multiply by 100.\nThis requires joining the `cards` table with the `foreign_data` table on `uuid`.\n\n-- SQL Query\nSELECT\n  CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)\nFROM cards AS T1\nINNER JOIN foreign_data AS T2\n  ON T1.uuid = T2.uuid\nWHERE\n  T1.power IS NULL;",
        "pred_query": "SELECT\n  CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)\nFROM cards AS T1\nINNER JOIN foreign_data AS T2\n  ON T1.uuid = T2.uuid\nWHERE\n  T1.power IS NULL;",
        "pred_time": 0.4859778881072998,
        "orig_time": 0.5923972129821777,
        "time_ratio": 1.2189797673497882,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "original_query": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "llm_output": "SELECT DISTINCT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high';",
        "pred_query": "SELECT DISTINCT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high';",
        "pred_time": 0.13653111457824707,
        "orig_time": 0.13919973373413086,
        "time_ratio": 1.0195458680911478,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "llm_output": "-- Reasoning\nI need to find members who attended a specific event.\nI will join `event` and `attendance` tables to link events to members.\nThen I will join the result with the `member` table to get the members' names.\nFinally, I will filter for the specific event name and select the concatenated first and last names.\n\n-- SQL Query\nSELECT T3.first_name || ' ' || T3.last_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Laugh Out Loud';",
        "pred_query": "SELECT T3.first_name || ' ' || T3.last_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Laugh Out Loud';",
        "pred_time": 0.0020079612731933594,
        "orig_time": 0.0009388923645019531,
        "time_ratio": 0.46758489669912134,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the `cards` table with the `sets` table.\nThe `cards` table contains card information, including `name` and `setCode`.\nThe `sets` table contains set information, including `code` and `type`.\nI will filter the `cards` table by `name` to find \"Samite Pilgrim\" and then use its `setCode` to find the matching `code` in the `sets` table to retrieve the `type`.\n\n-- SQL Query\nSELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'",
        "pred_query": "SELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'",
        "pred_time": 0.06363129615783691,
        "orig_time": 0.05814313888549805,
        "time_ratio": 0.9137506603869024,
        "check": true
    },
    {
        "id": "card_games",
        "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
        "llm_output": "-- Reasoning\nThe question asks to count cards that meet three criteria: \"color cards\", \"no borders\", and \"ranked higher than 12000 on EDHRec\".\n1. \"color cards\": A card has colors if its `colors` column is not empty or equivalent to `[]` (representing no colors). `length(colors) > 2` will filter out `NULL`, `''`, and `[]` (which has length 2).\n2. \"no borders\": This refers to cards with a 'borderless' print style. This can be directly filtered using `borderColor = 'borderless'`.\n3. \"ranked higher than 12000 on EDHRec\": A higher rank means a lower number for `edhrecRank`. So, `edhrecRank < 12000` is the correct condition.\nAll conditions can be applied to the `cards` table.\n\n-- SQL Query\nSELECT COUNT(id) FROM cards WHERE length(colors) > 2 AND borderColor = 'borderless' AND edhrecRank < 12000;",
        "pred_query": "SELECT COUNT(id) FROM cards WHERE length(colors) > 2 AND borderColor = 'borderless' AND edhrecRank < 12000;",
        "pred_time": 0.05959963798522949,
        "orig_time": 0.05181694030761719,
        "time_ratio": 0.8694170310306065,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Calculate the average height of all neutral superheroes.",
        "original_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "llm_output": "-- Reasoning\nTo calculate the average height of neutral superheroes, I need to join the `superhero` table with the `alignment` table.\nI will filter the results where the `alignment` name is 'Neutral'.\nThen, I will compute the average of the `height_cm` column from the filtered superheroes.\n\n-- SQL Query\nSELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_time": 0.001094818115234375,
        "orig_time": 0.000568389892578125,
        "time_ratio": 0.519163763066202,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the date when the youngest user made his or her first post?",
        "original_query": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "llm_output": "-- Reasoning\nFirst, find the minimum age among all users.\nThen, identify the user(s) who have this minimum age.\nFinally, find the earliest 'CreaionDate' from the 'posts' table for posts made by these youngest user(s).\n\n-- SQL Query\nSELECT MIN(T1.CreaionDate)\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  T2.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );",
        "pred_query": "SELECT MIN(T1.CreaionDate)\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  T2.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );",
        "pred_time": 0.19638395309448242,
        "orig_time": 0.1838986873626709,
        "time_ratio": 0.9364242060765284,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
        "original_query": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "llm_output": "\nSELECT name FROM cards WHERE isPromo = 1 AND isFullArt = 1 AND side IS NOT NULL;\n",
        "pred_query": "SELECT name FROM cards WHERE isPromo = 1 AND isFullArt = 1 AND side IS NOT NULL;",
        "pred_time": 0.06152224540710449,
        "orig_time": 0.05502057075500488,
        "time_ratio": 0.8943199389249079,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
        "llm_output": "-- Reasoning\nTo get the patient's ID, sex, and diagnosis, I need to query the `Patient` table.\nTo filter patients based on their albumin level, I need to join the `Patient` table with the `Laboratory` table using the `ID` column.\nThen, I will filter the results where `ALB` is less than 3.5.\nSince a patient might have multiple laboratory records, I should use `DISTINCT` to ensure each patient is listed only once.\n\n-- SQL Query\nSELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5;",
        "pred_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5;",
        "pred_time": 0.004599571228027344,
        "orig_time": 0.003971099853515625,
        "time_ratio": 0.8633630520422974,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which foot is preferred by Abdou Diallo?",
        "original_query": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "llm_output": "\nSELECT T2.preferred_foot FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Abdou Diallo' LIMIT 1;\n",
        "pred_query": "SELECT T2.preferred_foot FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Abdou Diallo' LIMIT 1;",
        "pred_time": 0.0018131732940673828,
        "orig_time": 0.09748601913452148,
        "time_ratio": 53.765417488494414,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "original_query": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "llm_output": "-- Reasoning\nI need to count 'Discount' segment gas stations for the Czech Republic and Slovakia separately from the `gasstations` table.\nThen, I will subtract the count of Slovakian 'Discount' gas stations from the Czech Republic's count to find the difference.\nI can use subqueries or conditional aggregation to achieve this.\n\n-- SQL Query\nSELECT\n  SUM(CASE WHEN Country = 'CZE' THEN 1 ELSE 0 END) - SUM(CASE WHEN Country = 'SVK' THEN 1 ELSE 0 END)\nFROM gasstations\nWHERE Segment = 'Discount';",
        "pred_query": "SELECT\n  SUM(CASE WHEN Country = 'CZE' THEN 1 ELSE 0 END) - SUM(CASE WHEN Country = 'SVK' THEN 1 ELSE 0 END)\nFROM gasstations\nWHERE Segment = 'Discount';",
        "pred_time": 0.0016417503356933594,
        "orig_time": 0.0013990402221679688,
        "time_ratio": 0.8521638106302643,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "original_query": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "SELECT T2.nationality FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 933 ORDER BY T1.fastestLapSpeed DESC LIMIT 1;",
        "pred_query": "SELECT T2.nationality FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 933 ORDER BY T1.fastestLapSpeed DESC LIMIT 1;",
        "pred_time": 0.0027191638946533203,
        "orig_time": 0.002143383026123047,
        "time_ratio": 0.7882507672073652,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "llm_output": "-- Reasoning\nI need to retrieve superhero names from the `superhero` table.\nTo filter by eye colour and hair colour, I need to join the `superhero` table with the `colour` table twice, aliasing it to differentiate between eye colour and hair colour.\nI will filter the first `colour` join for `colour.colour = 'Blue'` (for eyes) and the second `colour` join for `colour.colour = 'Blond'` (for hair).\nFinally, I will select the `superhero_name`.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_time": 0.001020669937133789,
        "orig_time": 0.0006399154663085938,
        "time_ratio": 0.6269563186171455,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What is the highest amount of budget spend for an event?",
        "original_query": "SELECT MAX(spent) FROM budget",
        "llm_output": "-- Reasoning\nThe question asks for the highest amount of budget spent.\nThe `budget` table contains a column `spent` which represents the amount spent.\nI need to find the maximum value of this `spent` column.\n\n-- SQL Query\nSELECT MAX(spent) FROM budget;",
        "pred_query": "SELECT MAX(spent) FROM budget;",
        "pred_time": 0.001071929931640625,
        "orig_time": 0.00046372413635253906,
        "time_ratio": 0.4326067615658363,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the owner's display name of the most popular post?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "llm_output": "-- Reasoning\nTo find the owner's display name of the most popular post, I need to identify the post with the highest 'ViewCount' first.\nThen, I will retrieve the 'OwnerUserId' for that post.\nFinally, I will join with the 'users' table to get the 'DisplayName' corresponding to the 'OwnerUserId'.\n\n-- SQL Query\nSELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.ViewCount DESC LIMIT 1;",
        "pred_query": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.ViewCount DESC LIMIT 1;",
        "pred_time": 0.19656038284301758,
        "orig_time": 0.11189818382263184,
        "time_ratio": 0.5692814706817041,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "original_query": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the most common illness, I need to join the Patient and Laboratory tables.\nI will filter the lab work dates between the specified range.\nThen, I will group by the patient's diagnosis and count the occurrences, ordering by the count to find the most common one.\n\n-- SQL Query\nSELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1;",
        "pred_query": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1;",
        "pred_time": 0.0039615631103515625,
        "orig_time": 0.00070953369140625,
        "time_ratio": 0.1791044776119403,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "original_query": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the most valuable post, we should look at the `FavoriteCount` column in the `posts` table.\nWe need to filter posts created in the year 2010 using the `CreaionDate` column.\nWe will join the `posts` table with the `users` table on `OwnerUserId` to get the owner's `DisplayName`.\nFinally, we order by `FavoriteCount` in descending order and limit to 1 to get the top post.\n\n-- SQL Query\nSELECT T1.Id, T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE strftime('%Y', T1.CreaionDate) = '2010' ORDER BY T1.FavoriteCount DESC LIMIT 1;",
        "pred_query": "SELECT T1.Id, T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE strftime('%Y', T1.CreaionDate) = '2010' ORDER BY T1.FavoriteCount DESC LIMIT 1;",
        "pred_time": 0.12246370315551758,
        "orig_time": 0.2106170654296875,
        "time_ratio": 1.719832570816704,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "llm_output": "-- Reasoning\nThe question asks for card names from a specific set translation.\nI need to join the `cards` table with the `set_translations` table using the `setCode` column.\nThen, I will filter the results based on the `translation` in `set_translations` and select the `name` from `cards`.\n\n-- SQL Query\nSELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition';",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition';",
        "pred_time": 0.09788298606872559,
        "orig_time": 0.08839297294616699,
        "time_ratio": 0.9030473680492801,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What is the carcinogenic label for bond TR001_2_4?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
        "llm_output": "-- Reasoning\nThe question asks for the carcinogenic label of a specific bond.\nThe `bond` table contains `bond_id` and `molecule_id`.\nThe `molecule` table contains `molecule_id` and the `label` which indicates carcinogenicity.\nTherefore, I need to join the `bond` and `molecule` tables on `molecule_id` and filter by the given `bond_id` to retrieve the `label`.\n\n-- SQL Query\nSELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_query": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_time": 0.0010330677032470703,
        "orig_time": 0.001367330551147461,
        "time_ratio": 1.3235633510270022,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "original_query": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "llm_output": "\nSELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.date, 1, 10) = '2015-09-10';\n",
        "pred_query": "SELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.date, 1, 10) = '2015-09-10';",
        "pred_time": 0.002232789993286133,
        "orig_time": 0.0016217231750488281,
        "time_ratio": 0.7263214095034703,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many positive comments are there on the list?",
        "original_query": "SELECT COUNT(id) FROM comments WHERE score > 60",
        "llm_output": "\nSELECT COUNT(Id) FROM comments WHERE Score > 0;\n",
        "pred_query": "SELECT COUNT(Id) FROM comments WHERE Score > 0;",
        "pred_time": 0.05088543891906738,
        "orig_time": 0.0406646728515625,
        "time_ratio": 0.7991416349230892,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 10?",
        "original_query": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 10 AND T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nI need to count the number of distinct sets.\nA set must meet two conditions: it has an Italian translation AND its baseSetSize is less than 10.\nI will join the `sets` table with the `set_translations` table on `code` and `setCode` respectively.\nThen, I'll filter for `language = 'Italian'` and `baseSetSize < 10` and count the distinct sets.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_query": "SELECT COUNT(DISTINCT T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_time": 0.010808944702148438,
        "orig_time": 0.004185199737548828,
        "time_ratio": 0.387197811893418,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were adult?",
        "original_query": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "llm_output": "-- Reasoning\nTo find the number of adult users, I need to query the `users` table.\nThe `Age` column in the `users` table indicates the user's age.\nBased on previous examples, 'adult' is defined as an age between 19 and 65, inclusive.\nI will count the distinct users whose age falls within this range.\n\n-- SQL Query\nSELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65;",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65;",
        "pred_time": 0.01009511947631836,
        "orig_time": 0.008172988891601562,
        "time_ratio": 0.8095980350479429,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "original_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to retrieve card names.\nI will join the `cards` table with the `sets` table using `setCode` and `code` to filter by the set 'Coldsnap'.\nThen, I will order the results by `convertedManaCost` in descending order.\nFinally, I will limit the result to 1 to get the card with the highest converted mana cost.\n\n-- SQL Query\nSELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1;",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1;",
        "pred_time": 0.09202837944030762,
        "orig_time": 0.0697488784790039,
        "time_ratio": 0.7579061904946955,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "original_query": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "llm_output": "-- Reasoning\n-- To find the two most common first names among school administrators, I first need to gather all administrator first names (AdmFName1, AdmFName2, AdmFName3) from the 'schools' table.\n-- I will use UNION ALL to combine these names into a single list, ensuring to filter out NULL values.\n-- Then, I'll group by name, count occurrences, and select the top two names based on their frequency.\n-- Finally, I will join these top two names back to the 'schools' table to retrieve all distinct districts where an administrator with one of these common first names is found.\n\nSELECT DISTINCT T1.FName, T2.District\nFROM (\n    SELECT FName\n    FROM (\n        SELECT AdmFName1 AS FName FROM schools WHERE AdmFName1 IS NOT NULL\n        UNION ALL\n        SELECT AdmFName2 AS FName FROM schools WHERE AdmFName2 IS NOT NULL\n        UNION ALL\n        SELECT AdmFName3 AS FName FROM schools WHERE AdmFName3 IS NOT NULL\n    ) AS AllFirstNames\n    GROUP BY FName\n    ORDER BY COUNT(*) DESC\n    LIMIT 2\n) AS T1\nINNER JOIN schools AS T2\nON T1.FName = T2.AdmFName1 OR T1.FName = T2.AdmFName2 OR T1.FName = T2.AdmFName3;",
        "pred_query": "select the top two names based on their frequency.\n-- Finally, I will join these top two names back to the 'schools' table to retrieve all distinct districts where an administrator with one of these common first names is found.\n\nSELECT DISTINCT T1.FName, T2.District\nFROM (\n    SELECT FName\n    FROM (\n        SELECT AdmFName1 AS FName FROM schools WHERE AdmFName1 IS NOT NULL\n        UNION ALL\n        SELECT AdmFName2 AS FName FROM schools WHERE AdmFName2 IS NOT NULL\n        UNION ALL\n        SELECT AdmFName3 AS FName FROM schools WHERE AdmFName3 IS NOT NULL\n    ) AS AllFirstNames\n    GROUP BY FName\n    ORDER BY COUNT(*) DESC\n    LIMIT 2\n) AS T1\nINNER JOIN schools AS T2\nON T1.FName = T2.AdmFName1 OR T1.FName = T2.AdmFName2 OR T1.FName = T2.AdmFName3;",
        "pred_time": null,
        "orig_time": 0.032071590423583984,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "financial",
        "question": "List the top ten districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "original_query": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 10",
        "llm_output": "-- Reasoning\nI need to count the number of female clients per district.\nI will filter the `client` table for `gender = 'F'`, group by `district_id`, count the clients, and then order by this count in descending order, finally limiting to the top 10.\n\n-- SQL Query\nSELECT district_id\nFROM client\nWHERE gender = 'F'\nGROUP BY district_id\nORDER BY COUNT(client_id) DESC\nLIMIT 10;",
        "pred_query": "SELECT district_id\nFROM client\nWHERE gender = 'F'\nGROUP BY district_id\nORDER BY COUNT(client_id) DESC\nLIMIT 10;",
        "pred_time": 0.0020322799682617188,
        "orig_time": 0.0024449825286865234,
        "time_ratio": 1.2030736743313,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01'",
        "llm_output": "-- Reasoning\nI need to count unique patients who meet two criteria:\n1. Their `IGA` level is within the normal range (assuming 80 to 500 as seen in previous examples).\n2. Their `First Date` in the `Patient` table is after '1990-01-01'.\nI will join `Patient` and `Laboratory` tables on `ID` to access both pieces of information.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01';",
        "pred_time": 0.004124641418457031,
        "orig_time": 0.004191875457763672,
        "time_ratio": 1.016300578034682,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "original_query": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "llm_output": "-- Reasoning\nThe question asks to count races in a specific year (2010) based on their geographical location (outside Asia and Europe).\n1. The `races` table contains the `year` and links to the `circuits` table via `circuitId`.\n2. The `circuits` table contains the `country` where each circuit is located.\n3. To filter races by year, we use `races.year = 2010`.\n4. To determine which circuits are \"outside Asia and Europe\", we need to filter the `circuits.country` column. Since the schema does not provide a direct continent mapping, and to avoid external knowledge of every single country's continent, we assume the question refers to the common F1 host countries that are geographically outside Asia and Europe, such as Australia, Brazil, Canada, USA, and Mexico.\n5. We will join `races` and `circuits` on `circuitId` and apply the year and country filters, then count the resulting races.\n\n-- SQL Query\nSELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.country IN ('Australia', 'Brazil', 'Canada', 'USA', 'Mexico');",
        "pred_query": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.country IN ('Australia', 'Brazil', 'Canada', 'USA', 'Mexico');",
        "pred_time": 0.0010390281677246094,
        "orig_time": 0.0006966590881347656,
        "time_ratio": 0.6704910509407985,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "original_query": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "llm_output": "\nSELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'Spanish' AND STRFTIME('%Y', T1.dob) < '1982'\n  AND T2.milliseconds IS NOT NULL\nGROUP BY\n  T1.driverId,\n  T1.forename,\n  T1.surname\nORDER BY\n  MAX(T2.milliseconds) DESC\nLIMIT 10;\n",
        "pred_query": "SELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'Spanish' AND STRFTIME('%Y', T1.dob) < '1982'\n  AND T2.milliseconds IS NOT NULL\nGROUP BY\n  T1.driverId,\n  T1.forename,\n  T1.surname\nORDER BY\n  MAX(T2.milliseconds) DESC\nLIMIT 10;",
        "pred_time": 0.06144857406616211,
        "orig_time": 0.0016264915466308594,
        "time_ratio": 0.026469150364329116,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "llm_output": "-- Reasoning\nThe question asks for the description of the ruling for a card.\nThe `rulings` table contains the `text` column which holds the description.\nThe `cards` table contains the card `name`.\nBoth tables can be joined using the `uuid` column.\n\nSELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "pred_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "pred_time": 0.16197824478149414,
        "orig_time": 0.15451645851135254,
        "time_ratio": 0.9539334045741301,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Which customer paid the most in 2012/8/25?",
        "original_query": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the customer with the highest total `Price` for transactions on a specific date.\nI will filter the `transactions_1k` table by the given `Date`.\nThen, I will group the results by `CustomerID` and calculate the sum of `Price` for each customer.\nFinally, I will order these sums in descending order and pick the `CustomerID` from the top entry.\n\n-- SQL Query\nSELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1;",
        "pred_query": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1;",
        "pred_time": 0.0013287067413330078,
        "orig_time": 0.0007183551788330078,
        "time_ratio": 0.5406423829176387,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with severe thrombosis have a normal prothrombin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.PT < 14 AND T3.Thrombosis < 3 AND T3.Thrombosis > 0",
        "llm_output": "-- Reasoning\nI need to count patients based on conditions from two different tables: Examination (for Thrombosis) and Laboratory (for PT).\nI will join `Examination` and `Laboratory` tables on `ID`.\nFilter for severe thrombosis (Thrombosis = 1) and normal prothrombin time (PT < 14).\nFinally, count the distinct `ID`s to get the number of unique patients.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Thrombosis = 1 AND T2.PT < 14;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Thrombosis = 1 AND T2.PT < 14;",
        "pred_time": 0.0013439655303955078,
        "orig_time": 0.0007753372192382812,
        "time_ratio": 0.5769026077700905,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "original_query": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "llm_output": "\nSELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';\n",
        "pred_query": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';",
        "pred_time": 0.0011057853698730469,
        "orig_time": 0.0005135536193847656,
        "time_ratio": 0.4644243208279431,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the average loan amount by male borrowers?",
        "original_query": "SELECT AVG(T3.amount) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M'",
        "llm_output": "-- Reasoning\nTo find the average loan amount for male borrowers, I need to link `loan` to `client` through `account` and `disp`.\nI will join `loan` with `account` using `account_id`, then `account` with `disp` using `account_id`, and finally `disp` with `client` using `client_id`.\nI will filter for `client.gender = 'M'` and `disp.type = 'OWNER'` to identify male borrowers.\nThen, I will calculate the average of the `amount` from the `loan` table.\n\n-- SQL Query\nSELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER';",
        "pred_query": "SELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M' AND T3.type = 'OWNER';",
        "pred_time": 0.0024385452270507812,
        "orig_time": 0.004886150360107422,
        "time_ratio": 2.003715291357059,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "List out of players whose preferred foot is left.",
        "original_query": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "llm_output": "SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot = 'left'",
        "pred_query": "SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot = 'left'",
        "pred_time": 0.09178447723388672,
        "orig_time": 0.07889890670776367,
        "time_ratio": 0.8596105690803487,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many white bordered cards are powerful?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "llm_output": "\nSELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND CAST(power AS INTEGER) > 0;\n",
        "pred_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND CAST(power AS INTEGER) > 0;",
        "pred_time": 0.06204867362976074,
        "orig_time": 0.05425596237182617,
        "time_ratio": 0.8744097044776005,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
        "original_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
        "llm_output": "-- Reasoning\nTo find the student's full name and position, I need to query the `member` table.\nThe hometown information (city, state, and zip code) is stored in the `zip_code` table.\nTherefore, I need to join the `member` table with the `zip_code` table on their respective zip code columns and filter the results by the specified city, state, and zip code.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092;",
        "pred_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092;",
        "pred_time": 0.0010848045349121094,
        "orig_time": 0.0005443096160888672,
        "time_ratio": 0.5017582417582418,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Give the eye colour of Blackwulf.",
        "original_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf'",
        "llm_output": "-- Reasoning\nI need to find the `eye_colour` for a specific superhero.\nI will join the `superhero` table with the `colour` table using `eye_colour_id`.\nThen, I will filter the results by `superhero_name` being 'Blackwulf' and select the `colour` name.\n\n-- SQL Query\nSELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_time": 0.0010886192321777344,
        "orig_time": 0.0005471706390380859,
        "time_ratio": 0.5026281208935611,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal anti-SSA came to the hospital before 1990?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '1990'",
        "llm_output": "-- Reasoning\nI need to count distinct patients.\nPatients are linked to laboratory results via `ID`.\nI will filter for `SSA` values that indicate 'normal' ('negative' or '0') from the `Laboratory` table.\nI will also filter for patients whose `First Date` in the `Patient` table is before 1990.\nA join between `Patient` and `Laboratory` tables on `ID` is necessary.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND T1.`First Date` < '1990-01-01';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND T1.`First Date` < '1990-01-01';",
        "pred_time": 0.002149820327758789,
        "orig_time": 0.0038404464721679688,
        "time_ratio": 1.7864034601308638,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "State the racing year which has the fastest lap time?",
        "original_query": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "llm_output": "\nSELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId ORDER BY T1.milliseconds ASC LIMIT 1\n",
        "pred_query": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId ORDER BY T1.milliseconds ASC LIMIT 1",
        "pred_time": 0.037813425064086914,
        "orig_time": 0.005914449691772461,
        "time_ratio": 0.15641137193334215,
        "check": false
    },
    {
        "id": "superhero",
        "question": "How many green-skinned villains are there in the superhero universe?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "llm_output": "-- Reasoning\nI need to count superheroes that have 'Green' skin and an 'alignment' of 'Bad'.\nThis requires joining the 'superhero' table with the 'colour' table (for skin_colour_id) and the 'alignment' table (for alignment_id).\nThen, I will filter the results based on the 'colour' name being 'Green' and the 'alignment' name being 'Bad'.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_time": 0.0008635520935058594,
        "orig_time": 0.0005886554718017578,
        "time_ratio": 0.6816675869685257,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "original_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
        "llm_output": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "pred_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "pred_time": 0.06500864028930664,
        "orig_time": 0.06319689750671387,
        "time_ratio": 0.9721307387059626,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "original_query": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "llm_output": "-- Reasoning\nThe query needs to retrieve event names.\nEvents must meet three criteria: their type is 'game', their budget status is 'Closed', and their event date falls within the specified range (2019-03-15 to 2020-03-20).\nWe need to join the `event` and `budget` tables on their respective event ID columns (`event_id` and `link_to_event`).\nThe `event_date` column in the `event` table is TEXT and includes time, so we'll use `SUBSTR` to extract only the date part for comparison.\n\n-- SQL Query\nSELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.type = 'game' AND T2.event_status = 'Closed' AND SUBSTR(T1.event_date, 1, 10) BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_query": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.type = 'game' AND T2.event_status = 'Closed' AND SUBSTR(T1.event_date, 1, 10) BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_time": 0.00090789794921875,
        "orig_time": 0.0005419254302978516,
        "time_ratio": 0.5969012605042017,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List down top 5 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "original_query": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 5",
        "llm_output": "-- Reasoning\nI need to join the `drivers` table with the `pitStops` table.\nFilter drivers by `nationality` being 'German' and their birth year (`dob`) being between 1980 and 1985 (inclusive).\nCalculate the average `milliseconds` for pit stops for these filtered drivers.\nGroup the results by driver to get the average per driver.\nOrder the results by the average pit stop duration in ascending order and take the top 5.\n\n\nSELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds) ASC\nLIMIT 5;\n",
        "pred_query": "SELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds) ASC\nLIMIT 5;",
        "pred_time": 0.002619504928588867,
        "orig_time": 0.0018856525421142578,
        "time_ratio": 0.7198507326840812,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "original_query": "SELECT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "llm_output": "-- Reasoning\nI need to find the currency used by a customer for a specific transaction.\nThe `transactions_1k` table contains the transaction date, time, and customer ID.\nThe `customers` table contains the customer ID and their currency.\nI will join `transactions_1k` with `customers` on `CustomerID` and filter by the given `Date` and `Time`.\n\n-- SQL Query\nSELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00';",
        "pred_query": "SELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00';",
        "pred_time": 0.0009152889251708984,
        "orig_time": 0.0006511211395263672,
        "time_ratio": 0.7113831727012243,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Count the fastest superheroes.",
        "original_query": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' ORDER BY T1.attribute_value DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the fastest superheroes, I need to identify the attribute representing 'Speed' and then find the superheroes who have the maximum value for this attribute.\nFirst, I will find the `id` of the 'Speed' attribute from the `attribute` table.\nNext, I will find the maximum `attribute_value` for this 'Speed' attribute from the `hero_attribute` table.\nFinally, I will count the number of superheroes that possess this maximum 'Speed' attribute value.\n\n-- SQL Query\nSELECT COUNT(T1.hero_id)\nFROM hero_attribute AS T1\nINNER JOIN attribute AS T2\n  ON T1.attribute_id = T2.id\nWHERE\n  T2.attribute_name = 'Speed' AND T1.attribute_value = (\n    SELECT\n      MAX(T3.attribute_value)\n    FROM hero_attribute AS T3\n    INNER JOIN attribute AS T4\n      ON T3.attribute_id = T4.id\n    WHERE\n      T4.attribute_name = 'Speed'\n  );",
        "pred_query": "SELECT COUNT(T1.hero_id)\nFROM hero_attribute AS T1\nINNER JOIN attribute AS T2\n  ON T1.attribute_id = T2.id\nWHERE\n  T2.attribute_name = 'Speed' AND T1.attribute_value = (\n    SELECT\n      MAX(T3.attribute_value)\n    FROM hero_attribute AS T3\n    INNER JOIN attribute AS T4\n      ON T3.attribute_id = T4.id\n    WHERE\n      T4.attribute_name = 'Speed'\n  );",
        "pred_time": 0.002895355224609375,
        "orig_time": 0.0008461475372314453,
        "time_ratio": 0.2922430830039526,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "original_query": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "llm_output": "-- Reasoning\nThe user wants to retrieve the `frameVersion` and `name` for all cards where the `artist` is 'Allen Williams'.\nAdditionally, for each of these cards, it needs to be determined if it is banned in any format.\nThis can be achieved by joining the `cards` table with the `legalities` table on `uuid` and checking for a `status` of 'Banned'.\nA `CASE` statement with an `EXISTS` subquery will efficiently check for the presence of a 'Banned' status for each card and provide a clear 'Banned' or 'Not Banned' indicator.\n\n-- SQL Query\nSELECT\n  T1.frameVersion,\n  T1.name,\n  CASE\n    WHEN EXISTS (\n      SELECT 1\n      FROM legalities AS T2\n      WHERE\n        T2.uuid = T1.uuid AND T2.status = 'Banned'\n    )\n    THEN 'Banned'\n    ELSE 'Not Banned'\n  END AS BanStatus\nFROM cards AS T1\nWHERE\n  T1.artist = 'Allen Williams';",
        "pred_query": "SELECT\n  T1.frameVersion,\n  T1.name,\n  CASE\n    WHEN EXISTS (\n      SELECT 1\n      FROM legalities AS T2\n      WHERE\n        T2.uuid = T1.uuid AND T2.status = 'Banned'\n    )\n    THEN 'Banned'\n    ELSE 'Not Banned'\n  END AS BanStatus\nFROM cards AS T1\nWHERE\n  T1.artist = 'Allen Williams';",
        "pred_time": 5.454447031021118,
        "orig_time": 0.32867932319641113,
        "time_ratio": 0.06025896325092364,
        "check": false
    },
    {
        "id": "student_club",
        "question": "State the name of major that Phillip Cullen has joined.",
        "original_query": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "llm_output": "-- Reasoning\nTo find the major name, I need to join the `member` table with the `major` table.\nThe `member` table contains the `first_name` and `last_name` of the member and a `link_to_major` column.\nThe `major` table contains the `major_id` and `major_name`.\nI will join these two tables on `member.link_to_major = major.major_id` and filter by the member's name.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_time": 0.0010554790496826172,
        "orig_time": 0.0004904270172119141,
        "time_ratio": 0.46464874632934267,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
        "original_query": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
        "llm_output": "-- Reasoning\nI need to first find the `district_id` associated with `account_id` 532 from the `account` table.\nThen, using that `district_id`, I will query the `district` table to retrieve the number of crimes committed in 1995, which is stored in the `A15` column.\n\n-- SQL Query\nSELECT T1.A15 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532;",
        "pred_query": "SELECT T1.A15 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532;",
        "pred_time": 0.0007975101470947266,
        "orig_time": 0.0004642009735107422,
        "time_ratio": 0.5820627802690583,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "llm_output": "-- Reasoning\nThe user wants to retrieve patient ID, sex, and birthday for patients whose LDH (Lactate Dehydrogenase) values are outside the normal range.\nThe \"normal range\" for LDH is not explicitly provided in the schema or question. Based on common medical knowledge and typical values, a widely accepted normal range for LDH is approximately 140-280 U/L.\nTherefore, \"beyond normal range\" implies values less than 140 or greater than 280.\nI will join the `Patient` and `Laboratory` tables on `ID` and filter the results using this condition.\n\n-- SQL Query\nSELECT DISTINCT\n  T1.ID,\n  T1.SEX,\n  T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.LDH < 140 OR T2.LDH > 280;",
        "pred_query": "SELECT DISTINCT\n  T1.ID,\n  T1.SEX,\n  T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.LDH < 140 OR T2.LDH > 280;",
        "pred_time": 0.005684375762939453,
        "orig_time": 0.003083944320678711,
        "time_ratio": 0.5425299890948746,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "original_query": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "llm_output": "-- Reasoning\nThe question asks for `bond_id`s.\nThe `connected` table contains `bond_id` and `atom_id2`.\nI need to filter the `connected` table where `atom_id2` is 'TR000_2' and select the corresponding `bond_id`s.\n\n-- SQL Query\nSELECT bond_id FROM connected WHERE atom_id2 = 'TR000_2';",
        "pred_query": "SELECT bond_id FROM connected WHERE atom_id2 = 'TR000_2';",
        "pred_time": 0.0032439231872558594,
        "orig_time": 0.0022068023681640625,
        "time_ratio": 0.6802881081875644,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "original_query": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "llm_output": "-- Reasoning\nTo answer the question, I need to retrieve information from both the `frpm` and `schools` tables.\nThe `frpm` table contains the `Percent (%) Eligible Free (K-12)` and `District Code`.\nThe `schools` table contains the administrator's first name (`AdmFName1`).\nBoth tables can be joined using the `CDSCode` column.\nI will filter the results based on `AdmFName1` being 'Alusine'.\n\n-- SQL Query\nSELECT T1.`Percent (%) Eligible Free (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine';",
        "pred_query": "SELECT T1.`Percent (%) Eligible Free (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine';",
        "pred_time": 0.011669158935546875,
        "orig_time": 0.008644819259643555,
        "time_ratio": 0.7408262504086303,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "original_query": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "llm_output": "SELECT T2.name, T2.year, T2.date, T2.time, T2.round FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "pred_query": "SELECT T2.name, T2.year, T2.date, T2.time, T2.round FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "pred_time": 0.001428365707397461,
        "orig_time": 0.0007963180541992188,
        "time_ratio": 0.5575029210482391,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Give the only one comment text of the post with parent id 107829.",
        "original_query": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "llm_output": "\nSELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ParentId = 107829\n",
        "pred_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ParentId = 107829",
        "pred_time": 0.21308684349060059,
        "orig_time": 0.21194911003112793,
        "time_ratio": 0.9946607052747354,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
        "original_query": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
        "llm_output": "-- Reasoning\nTo find the Italian name of the set, I need to:\n1. Find the `setCode` from the `cards` table for the card named 'Ancestor''s Chosen'.\n2. Join `cards` with `sets` on `setCode`.\n3. Join `sets` with `set_translations` on `setCode` and filter by `language` = 'Italian' to get the translation.\n\n-- SQL Query\nSELECT T3.translation FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code INNER JOIN set_translations AS T3 ON T2.code = T3.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T3.language = 'Italian';",
        "pred_query": "SELECT T3.translation FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code INNER JOIN set_translations AS T3 ON T2.code = T3.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T3.language = 'Italian';",
        "pred_time": 0.06729841232299805,
        "orig_time": 0.07507944107055664,
        "time_ratio": 1.1156197966485988,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many translations of the name of the set \"Salvat 2011\"?",
        "original_query": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Salvat 2011' AND T2.translation IS NOT NULL",
        "llm_output": "-- Reasoning\nTo find the number of translations for a set, I need to first identify the `setCode` of the set named \"Salvat 2011\" from the `sets` table.\nThen, I will use this `setCode` to query the `set_translations` table.\nI will count the distinct `translation` entries associated with that `setCode`.\n\nSELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.name = 'Salvat 2011'",
        "pred_query": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.name = 'Salvat 2011'",
        "pred_time": 0.013237237930297852,
        "orig_time": 0.004889965057373047,
        "time_ratio": 0.36940977287873056,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "original_query": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
        "llm_output": "-- Reasoning\nI need to count members who satisfy two conditions: attended the \"Women's Soccer\" event and have a 'Medium' t-shirt size.\nI will join `event` to `attendance` on `event_id`, and then `attendance` to `member` on `member_id`.\nFinally, I will apply filters for the event name and t-shirt size, and count the distinct member IDs.\n\n-- SQL Query\nSELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = \"Women's Soccer\" AND T1.t_shirt_size = 'Medium';",
        "pred_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = \"Women's Soccer\" AND T1.t_shirt_size = 'Medium';",
        "pred_time": 0.001384735107421875,
        "orig_time": 0.00061798095703125,
        "time_ratio": 0.4462809917355372,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "original_query": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "llm_output": "-- Reasoning\nI need to first find districts that have accounts opened in 1997 or later.\nThen, from these districts, I will filter those where the number of crimes in 1995 (A15) is greater than 4000.\nFinally, I will calculate the average of A15 for these filtered districts.\n\n-- SQL Query\nSELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A15 > 4000 AND STRFTIME('%Y', T2.date) >= '1997' GROUP BY T1.district_id;",
        "pred_query": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A15 > 4000 AND STRFTIME('%Y', T2.date) >= '1997' GROUP BY T1.district_id;",
        "pred_time": 0.002263307571411133,
        "orig_time": 0.001867532730102539,
        "time_ratio": 0.825134309491204,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "original_query": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "llm_output": "-- Reasoning\nTo answer the question, I need to retrieve the school name and NCES school identification number for the top five schools with the highest 'Enrollment (Ages 5-17)'.\nThe 'frpm' table contains the `Enrollment (Ages 5-17)` column.\nThe 'schools' table contains the `School` name and `NCESSchool` identification number.\nBoth tables can be linked using the `CDSCode` column.\n\n-- SQL Query\nSELECT T2.School, T2.NCESSchool FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_query": "SELECT T2.School, T2.NCESSchool FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_time": 0.006909847259521484,
        "orig_time": 0.013295650482177734,
        "time_ratio": 1.924159823338624,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level?",
        "original_query": "SELECT T2.ANA FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 ORDER BY T2.ANA DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the highest anti-nucleus antibody concentration, we need to look at the `ANA` column in the `Examination` table.\nThe condition is that the patient must have a \"normal creatinine level\", which refers to the `CRE` column in the `Laboratory` table.\nBased on the provided few-shot examples, a normal creatinine level is `CRE < 1.5`.\nWe will join `Examination` and `Laboratory` tables on their common `ID` column, filter for normal `CRE`, and then find the maximum `ANA`.\n\n-- SQL Query\nSELECT MAX(T2.ANA) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.CRE < 1.5;",
        "pred_query": "SELECT MAX(T2.ANA) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.CRE < 1.5;",
        "pred_time": 0.001470327377319336,
        "orig_time": 0.0011534690856933594,
        "time_ratio": 0.7844981352359331,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many male patients have elevated total bilirubin count?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "llm_output": "-- Reasoning\nI need to join the Patient and Laboratory tables using the common ID column.\nThen I will filter for male patients (SEX = 'M') and those with elevated total bilirubin (`T-BIL` >= 2.0, based on previous examples).\nFinally, I will count the distinct patient IDs that meet these criteria.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` >= 2.0;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` >= 2.0;",
        "pred_time": 0.002418041229248047,
        "orig_time": 0.0015158653259277344,
        "time_ratio": 0.6268980477223427,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "original_query": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "llm_output": "-- Reasoning\nTo answer the question, I need to look at the `Player_Attributes` table.\nI will filter for players whose `preferred_foot` is 'left'.\nI will also filter for players whose `attacking_work_rate` indicates they remain in position when attacking, which typically corresponds to a 'Low' attacking work rate.\nFinally, I will count the distinct `player_api_id` to get the number of unique players satisfying both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'Low';",
        "pred_query": "SELECT COUNT(DISTINCT player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'Low';",
        "pred_time": 0.060853004455566406,
        "orig_time": 0.06025123596191406,
        "time_ratio": 0.9901111128524189,
        "check": false
    },
    {
        "id": "card_games",
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "original_query": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "llm_output": "SELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy'",
        "pred_query": "SELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy'",
        "pred_time": 0.06483745574951172,
        "orig_time": 0.05650591850280762,
        "time_ratio": 0.8715011693411976,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which SME customer consumed the least in June 2012?",
        "original_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "llm_output": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date = '201206' ORDER BY T2.Consumption LIMIT 1;",
        "pred_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date = '201206' ORDER BY T2.Consumption LIMIT 1;",
        "pred_time": 0.018527984619140625,
        "orig_time": 0.019178152084350586,
        "time_ratio": 1.0350911056207535,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the region of the client with the id 3541 from?",
        "original_query": "SELECT T2.district_id, T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
        "llm_output": "-- Reasoning\nTo find the region of a client, I need to look up the client's district ID in the `client` table.\nThen, I will use this `district_id` to find the corresponding region name (A3 column) in the `district` table.\nI will join `client` and `district` tables on `district_id` and filter by the given `client_id`.\n\n-- SQL Query\nSELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541;",
        "pred_query": "SELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541;",
        "pred_time": 0.0010094642639160156,
        "orig_time": 0.0004737377166748047,
        "time_ratio": 0.4692961738308928,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the score and the link type ID for post ID 395?",
        "original_query": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395",
        "llm_output": "-- Reasoning\nThe question asks for the 'Score' and 'LinkTypeId' for a specific 'PostId' (395).\nThe 'Score' is found in the `posts` table, where `Id` is the post identifier.\nThe 'LinkTypeId' is found in the `postLinks` table, where `PostId` refers to the post that initiated the link.\nWe need to join these two tables on their respective post ID columns and filter for `PostId` 395.\n\n-- SQL Query\nSELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T1.Id = 395;",
        "pred_query": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T1.Id = 395;",
        "pred_time": 0.0017371177673339844,
        "orig_time": 0.001308441162109375,
        "time_ratio": 0.7532253637112271,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many French constructors have a lap number of over 50?",
        "original_query": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "llm_output": "-- Reasoning\nI need to identify French constructors and then check their lap times.\nJoin `constructors` with `results` on `constructorId` to link constructors to races and drivers.\nThen join `results` with `lapTimes` on `raceId` and `driverId` to get lap information.\nFilter `constructors` by `nationality = 'French'` and `lapTimes` by `lap > 50`.\nFinally, count the distinct `constructorId` to get the number of unique French constructors meeting the criteria.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.constructorId) FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId INNER JOIN lapTimes AS T3 ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId WHERE T1.nationality = 'French' AND T3.lap > 50;",
        "pred_query": "SELECT COUNT(DISTINCT T1.constructorId) FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId INNER JOIN lapTimes AS T3 ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId WHERE T1.nationality = 'French' AND T3.lap > 50;",
        "pred_time": 0.009534597396850586,
        "orig_time": 0.004075527191162109,
        "time_ratio": 0.4274461753894626,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "original_query": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA > 6.5 AND T1.SEX = 'F') OR (T2.UA > 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "llm_output": "-- Reasoning\n-- 1. For each patient, identify their latest laboratory examination date.\n-- 2. From these latest examinations, retrieve the corresponding Uric Acid (UA) level.\n-- 3. Filter these results to include only patients whose latest UA level is not NULL, interpreting 'normal UA' as a valid, recorded UA value in the absence of explicit numerical ranges.\n-- 4. Calculate the average of these filtered UA levels.\n\n-- SQL Query\nWITH LatestUA AS (\n  SELECT\n    L.ID,\n    L.UA,\n    L.Date,\n    ROW_NUMBER() OVER (PARTITION BY L.ID ORDER BY L.Date DESC) as rn\n  FROM Laboratory AS L\n)\nSELECT\n  AVG(T1.UA)\nFROM LatestUA AS T1\nWHERE\n  T1.rn = 1 AND T1.UA IS NOT NULL;",
        "pred_query": "SELECT\n    L.ID,\n    L.UA,\n    L.Date,\n    ROW_NUMBER() OVER (PARTITION BY L.ID ORDER BY L.Date DESC) as rn\n  FROM Laboratory AS L\n)\nSELECT\n  AVG(T1.UA)\nFROM LatestUA AS T1\nWHERE\n  T1.rn = 1 AND T1.UA IS NOT NULL;",
        "pred_time": null,
        "orig_time": 0.00467991828918457,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "original_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "llm_output": "-- Reasoning\nTo find the circuit name, I need to look into the `circuits` table.\nThe `races` table contains information about specific races, including the `year`, `name`, and the `circuitId`.\nI will join the `races` table with the `circuits` table using `circuitId`.\nThen, I will filter the `races` table for the year 2009 and the name 'Spanish Grand Prix'.\n\n-- SQL Query\nSELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_time": 0.0010259151458740234,
        "orig_time": 0.0006654262542724609,
        "time_ratio": 0.6486172437834069,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the molecule id of bond id TR001_1_7?",
        "original_query": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "llm_output": "The user is asking for the `molecule_id` associated with a specific `bond_id`.\nThe `bond` table contains both `bond_id` and `molecule_id`.\nI can select the `molecule_id` from the `bond` table where the `bond_id` matches the given value.\n\n\nSELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';\n",
        "pred_query": "select the `molecule_id` from the `bond` table where the `bond_id` matches the given value.\n\n\nSELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';",
        "pred_time": null,
        "orig_time": 0.002029895782470703,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "original_query": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "llm_output": "-- Reasoning\nTo calculate the percentage difference, I need to find the overall rating for each player on the specified date.\nI will join the `Player` and `Player_Attributes` tables using `player_api_id`.\nThen, I will filter the results by the player names ('Landon Donovan', 'Jordan Bowery') and the specific date ('2013-07-12').\nFinally, I'll calculate the percentage difference using the formula: ((Landon Donovan's rating - Jordan Bowery's rating) / Jordan Bowery's rating) * 100.\n\n-- SQL Query\nSELECT CAST((SUM(CASE WHEN T1.player_name = 'Landon Donovan' THEN T2.overall_rating ELSE 0 END) - SUM(CASE WHEN T1.player_name = 'Jordan Bowery' THEN T2.overall_rating ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN T1.player_name = 'Jordan Bowery' THEN T2.overall_rating ELSE 0 END) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name IN ('Landon Donovan', 'Jordan Bowery') AND T2.date = '2013-07-12 00:00:00';",
        "pred_query": "SELECT CAST((SUM(CASE WHEN T1.player_name = 'Landon Donovan' THEN T2.overall_rating ELSE 0 END) - SUM(CASE WHEN T1.player_name = 'Jordan Bowery' THEN T2.overall_rating ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN T1.player_name = 'Jordan Bowery' THEN T2.overall_rating ELSE 0 END) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name IN ('Landon Donovan', 'Jordan Bowery') AND T2.date = '2013-07-12 00:00:00';",
        "pred_time": 0.06399130821228027,
        "orig_time": 0.09148192405700684,
        "time_ratio": 1.4295992160924593,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "original_query": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe query needs to find the patient who had the highest hemoglobin (HGB) count.\nThen, it needs to determine the age of this patient at the time of the examination corresponding to that HGB count, and retrieve the doctor's diagnosis from that examination.\nTo link the hemoglobin count (from `Laboratory` table) to an examination event and diagnosis (from `Examination` table), it's assumed that `Laboratory.Date` corresponds to `Examination.Examination Date` for the same patient.\nThe age is calculated by subtracting the birth year (`Patient.Birthday`) from the examination year (`Examination.Examination Date`).\n\n-- SQL Query\n\nSELECT\n  STRFTIME('%Y', T3.`Examination Date`) - STRFTIME('%Y', T1.Birthday),\n  T3.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nINNER JOIN Examination AS T3\n  ON T1.ID = T3.ID AND T2.Date = T3.`Examination Date`\nWHERE\n  T2.HGB = (\n    SELECT\n      MAX(HGB)\n    FROM Laboratory\n  )\nLIMIT 1;\n",
        "pred_query": "SELECT\n  STRFTIME('%Y', T3.`Examination Date`) - STRFTIME('%Y', T1.Birthday),\n  T3.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nINNER JOIN Examination AS T3\n  ON T1.ID = T3.ID AND T2.Date = T3.`Examination Date`\nWHERE\n  T2.HGB = (\n    SELECT\n      MAX(HGB)\n    FROM Laboratory\n  )\nLIMIT 1;",
        "pred_time": 0.0046215057373046875,
        "orig_time": 0.0044116973876953125,
        "time_ratio": 0.9546017333883615,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "original_query": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "llm_output": "SELECT\n  T2.forename,\n  T2.surname,\n  T1.duration\nFROM pitStops AS T1\nINNER JOIN drivers AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T1.raceId = T3.raceId\nWHERE\n  T3.year = 2011 AND T3.name = 'Australian Grand Prix';",
        "pred_query": "SELECT\n  T2.forename,\n  T2.surname,\n  T1.duration\nFROM pitStops AS T1\nINNER JOIN drivers AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T1.raceId = T3.raceId\nWHERE\n  T3.year = 2011 AND T3.name = 'Australian Grand Prix';",
        "pred_time": 0.001697540283203125,
        "orig_time": 0.0006530284881591797,
        "time_ratio": 0.38469101123595506,
        "check": false
    },
    {
        "id": "financial",
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "original_query": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "llm_output": "-- Reasoning\nI need to first filter accounts that were opened in 1993.\nThen, I will count how many of these accounts belong to the 'Decin' district.\nFinally, I will divide this count by the total number of accounts opened in 1993 and multiply by 100 to get the percentage.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993';",
        "pred_query": "SELECT CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993';",
        "pred_time": 0.0020036697387695312,
        "orig_time": 0.0016057491302490234,
        "time_ratio": 0.80140409328891,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Please list the product description of the products consumed in September, 2013.",
        "original_query": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "llm_output": "-- Reasoning\nThe question asks for product descriptions of items consumed in September 2013.\nThe `transactions_1k` table contains `ProductID` and `Date` for individual transactions, which represent consumption.\nThe `products` table contains `ProductID` and `Description`.\nWe need to filter `transactions_1k` for dates in September 2013, then join with `products` to get the descriptions.\nUsing `DISTINCT` will ensure each unique product description is listed only once.\n\n-- SQL Query\nSELECT DISTINCT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID WHERE SUBSTR(T1.Date, 1, 7) = '2013-09';",
        "pred_query": "SELECT DISTINCT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID WHERE SUBSTR(T1.Date, 1, 7) = '2013-09';",
        "pred_time": 0.0008177757263183594,
        "orig_time": 0.0020134449005126953,
        "time_ratio": 2.4620991253644315,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the elements for bond id TR001_10_11?",
        "original_query": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
        "llm_output": "-- Reasoning\nTo find the elements for a given bond ID, we need to look at the `connected` table, which links a `bond_id` to two atom IDs (`atom_id` and `atom_id2`). For each of these atom IDs, we then need to query the `atom` table to get their respective `element`. Since a bond connects two atoms, we must retrieve the elements for both `atom_id` and `atom_id2` from the `connected` table. A `UNION` operation can be used to combine the results from querying for both `atom_id` and `atom_id2`, ensuring all distinct elements are listed.\n\n-- SQL Query\nSELECT T1.element\nFROM atom AS T1\nINNER JOIN connected AS T2\n  ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id = 'TR001_10_11'\nUNION\nSELECT T3.element\nFROM atom AS T3\nINNER JOIN connected AS T2\n  ON T3.atom_id = T2.atom_id2\nWHERE T2.bond_id = 'TR001_10_11';",
        "pred_query": "SELECT T1.element\nFROM atom AS T1\nINNER JOIN connected AS T2\n  ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id = 'TR001_10_11'\nUNION\nSELECT T3.element\nFROM atom AS T3\nINNER JOIN connected AS T2\n  ON T3.atom_id = T2.atom_id2\nWHERE T2.bond_id = 'TR001_10_11';",
        "pred_time": 0.00455784797668457,
        "orig_time": 0.002283334732055664,
        "time_ratio": 0.5009677250614636,
        "check": true
    },
    {
        "id": "card_games",
        "question": "List the edhrecRank for cards with frame version 2015.",
        "original_query": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "llm_output": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_query": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "original_query": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "llm_output": "-- Reasoning\nI need to count players from the 'Player' table.\nI will filter by `birthday` to find players born after the 1990s (i.e., from 2000 onwards).\nI will also filter by `player_name` to find players whose first name is \"Aaron\".\n\n-- SQL Query\nSELECT COUNT(id) FROM Player WHERE SUBSTR(birthday, 1, 4) > '1999' AND player_name LIKE 'Aaron %';",
        "pred_query": "SELECT COUNT(id) FROM Player WHERE SUBSTR(birthday, 1, 4) > '1999' AND player_name LIKE 'Aaron %';",
        "pred_time": 0.005003929138183594,
        "orig_time": 0.003987550735473633,
        "time_ratio": 0.7968839336763865,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "original_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
        "llm_output": "\nSELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;\n",
        "pred_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;",
        "pred_time": 0.0036084651947021484,
        "orig_time": 0.0024576187133789062,
        "time_ratio": 0.6810703666997027,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which college do most of the members go to?",
        "original_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to count the members for each college.\nFirst, I will join the `member` table with the `major` table using `link_to_major` and `major_id`.\nThen, I will group the results by `college` and count the members in each group.\nFinally, I will order the results by the count in descending order and pick the top one.\n\n-- SQL Query\nSELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_time": 0.0009145736694335938,
        "orig_time": 0.0005478858947753906,
        "time_ratio": 0.5990615224191866,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were from New York?",
        "original_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "llm_output": "-- Reasoning\nI need to count the number of users.\nThe `users` table contains information about users, including their `Location`.\nI will filter the `users` table for entries where the `Location` is 'New York' and then count the `Id`s.\n\nSELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_time": 0.009892702102661133,
        "orig_time": 0.00890207290649414,
        "time_ratio": 0.899862627431133,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which country is the Belgium Jupiler League from?",
        "original_query": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "llm_output": "\nSELECT T1.name FROM Country AS T1 INNER JOIN League AS T2 ON T1.id = T2.country_id WHERE T2.name = 'Belgium Jupiler League';\n",
        "pred_query": "SELECT T1.name FROM Country AS T1 INNER JOIN League AS T2 ON T1.id = T2.country_id WHERE T2.name = 'Belgium Jupiler League';",
        "pred_time": 0.0009169578552246094,
        "orig_time": 0.0005803108215332031,
        "time_ratio": 0.6328653146125846,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "original_query": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "llm_output": "-- Reasoning\nI need to join the Patient and Laboratory tables using the common ID.\nThen, I will filter patients whose birth year is 1982 using the 'Birthday' column.\nFinally, for each of these patients, I will use a CASE statement to determine if their 'ALB' value falls within the normal range (3.5 to 5.5) and label it accordingly.\n\n-- SQL Query\nSELECT\n  T1.ID,\n  CASE WHEN T2.ALB BETWEEN 3.5 AND 5.5 THEN 'normal' ELSE 'abNormal' END\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  STRFTIME('%Y', T1.Birthday) = '1982';",
        "pred_query": "SELECT\n  T1.ID,\n  CASE WHEN T2.ALB BETWEEN 3.5 AND 5.5 THEN 'normal' ELSE 'abNormal' END\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  STRFTIME('%Y', T1.Birthday) = '1982';",
        "pred_time": 0.0077075958251953125,
        "orig_time": 0.005892276763916016,
        "time_ratio": 0.7644766146993318,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "original_query": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "llm_output": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "pred_query": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "pred_time": 0.005734443664550781,
        "orig_time": 0.0041615962982177734,
        "time_ratio": 0.7257192749043738,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many clients who choose statement of weekly issuance are User?",
        "original_query": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'USER'",
        "llm_output": "-- Reasoning\nI need to count clients based on two conditions: account frequency and disp type.\n1. Join `client` with `disp` on `client_id`.\n2. Join the result with `account` on `account_id`.\n3. Filter by `account.frequency = 'POPLATEK TYDNE'` for \"weekly issuance\".\n4. Filter by `disp.type = 'OWNER'` for \"User\".\n5. Count distinct `client_id`s.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_time": 0.0026111602783203125,
        "orig_time": 0.001035451889038086,
        "time_ratio": 0.3965485756026297,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "original_query": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "llm_output": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre';",
        "pred_query": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre';",
        "pred_time": 0.06455683708190918,
        "orig_time": 0.060398101806640625,
        "time_ratio": 0.9355802504699543,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients whose C-reactive protein level is abnormal, how many of them aren't 18 yet?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP != '-' AND T2.CRP != '+-') AND T2.CRP >= 1.0 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < '18'",
        "llm_output": "-- Reasoning\nThe query needs to identify patients who meet two conditions: their C-reactive protein (CRP) level is abnormal, and they are not yet 18 years old.\n1.  **Abnormal CRP:** Based on the example `(T2.CRP = '-' OR T2.CRP = '+-' OR T2.CRP < 1.0)` for a \"normal\" CRP, an \"abnormal\" CRP would be the negation of this condition. This translates to `T2.CRP IS NOT NULL AND T2.CRP NOT IN ('-', '+-') AND CAST(T2.CRP AS REAL) >= 1.0`. The `CAST(T2.CRP AS REAL)` is necessary because `CRP` is stored as `TEXT` but needs numerical comparison.\n2.  **Not 18 yet:** This can be determined by checking if adding 18 years to the patient's `Birthday` results in a date later than the `CURRENT_DATE`. This is expressed as `DATE(T1.Birthday, '+18 years') > CURRENT_DATE`.\n3.  **Joining and Counting:** The `Patient` and `Laboratory` tables are joined on `ID` to access both `Birthday` and `CRP` information. `COUNT(DISTINCT T1.ID)` is used to count unique patients.\n\n-- SQL Query\n\nSELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  (\n    T2.CRP IS NOT NULL\n    AND T2.CRP NOT IN ('-', '+-')\n    AND CAST(T2.CRP AS REAL) >= 1.0\n  )\n  AND DATE(T1.Birthday, '+18 years') > CURRENT_DATE;\n",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  (\n    T2.CRP IS NOT NULL\n    AND T2.CRP NOT IN ('-', '+-')\n    AND CAST(T2.CRP AS REAL) >= 1.0\n  )\n  AND DATE(T1.Birthday, '+18 years') > CURRENT_DATE;",
        "pred_time": 0.006966114044189453,
        "orig_time": 0.009403467178344727,
        "time_ratio": 1.34988705592443,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "original_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to first identify the set code for \"Hauptset Zehnte Edition\" from the `set_translations` table.\nThen, I will join this information with the `cards` table using the `setCode`.\nFinally, I will count the cards where the `artist` is 'Adam Rex' and the `setCode` matches the identified set.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_time": 0.060897111892700195,
        "orig_time": 0.0531611442565918,
        "time_ratio": 0.8729665924101777,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patient who first came to the hospital on 1991/6/13 who was diagnosed with SJS, what is the total number of his/her Laboratory tests in 1995?",
        "original_query": "SELECT COUNT(*) FROM Laboratory WHERE ID = ( SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS' ) AND STRFTIME('%Y', Date) = '1995'",
        "llm_output": "-- Reasoning\nI need to join the Patient and Laboratory tables using the ID column.\nI will filter the Patient table for `First Date` = '1991-06-13' and `Diagnosis` = 'SJS'.\nThen, I will filter the Laboratory table for tests conducted in the year 1995.\nFinally, I will count the number of such laboratory tests.\n\n-- SQL Query\nSELECT COUNT(T2.Date) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` = '1991-06-13' AND T1.Diagnosis = 'SJS' AND STRFTIME('%Y', T2.Date) = '1995';",
        "pred_query": "SELECT COUNT(T2.Date) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` = '1991-06-13' AND T1.Diagnosis = 'SJS' AND STRFTIME('%Y', T2.Date) = '1995';",
        "pred_time": 0.0011949539184570312,
        "orig_time": 0.0007300376892089844,
        "time_ratio": 0.6109337589784517,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "original_query": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the user who acquired the first 'Autobiographer' badge, I need to:\n1. Filter the `badges` table for entries where the `Name` is 'Autobiographer'.\n2. Order these badges by their `Date` in ascending order to identify the \"first\" one.\n3. Limit the result to 1 to get only the earliest 'Autobiographer' badge.\n4. Join this result with the `users` table on `UserId` to retrieve the `DisplayName` of that user.\n\n-- SQL Query\nSELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Autobiographer' ORDER BY T1.Date ASC LIMIT 1;",
        "pred_query": "SELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Autobiographer' ORDER BY T1.Date ASC LIMIT 1;",
        "pred_time": 0.016259431838989258,
        "orig_time": 0.012373924255371094,
        "time_ratio": 0.7610305438655659,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Identify the total number of posts with views above average.",
        "original_query": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "llm_output": "-- Reasoning\nI need to first calculate the average view count across all posts.\nThen, I will count how many posts have a `ViewCount` greater than this calculated average.\nThis requires a subquery to get the average view count.\n\n-- SQL Query\nSELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_query": "SELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_time": 0.19161248207092285,
        "orig_time": 0.19246220588684082,
        "time_ratio": 1.0044345953182916,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "llm_output": "\nSELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.type LIKE '%Artifact%' AND T1.colors LIKE '%Black%';\n",
        "pred_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.type LIKE '%Artifact%' AND T1.colors LIKE '%Black%';",
        "pred_time": 0.2888071537017822,
        "orig_time": 0.27808308601379395,
        "time_ratio": 0.9628677214171025,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "original_query": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "llm_output": "-- Reasoning\nThe question asks for the count of distinct patients.\nPatients are identified by ID in the `Patient` table.\nThe examination date range is found in the `Examination` table.\nThe GPT and ALB levels are found in the `Laboratory` table.\nWe need to join `Patient`, `Examination`, and `Laboratory` tables on their common `ID` column and apply the filtering conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 JOIN Examination AS T2 ON T1.ID = T2.ID JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T2.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T3.GPT > 30 AND T3.ALB < 4;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 JOIN Examination AS T2 ON T1.ID = T2.ID JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T2.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T3.GPT > 30 AND T3.ALB < 4;",
        "pred_time": 0.006336212158203125,
        "orig_time": 0.003854513168334961,
        "time_ratio": 0.6083308248043348,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the labels for TR000, TR001 and TR002?",
        "original_query": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
        "llm_output": "-- Reasoning\nThe question asks for the labels of specific molecule IDs ('TR000', 'TR001', 'TR002').\nThe `molecule` table contains both `molecule_id` and `label`.\nI will select the `label` column from the `molecule` table and filter by the given `molecule_id`s using an IN clause.\n\n-- SQL Query\nSELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_query": "SELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_time": 0.0010607242584228516,
        "orig_time": 0.0004673004150390625,
        "time_ratio": 0.4405484378512025,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin?",
        "original_query": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "llm_output": "-- Reasoning\nI need to count schools from the 'schools' table.\nThe conditions are: `MailState` is 'CA', `County` is 'San Joaquin', and `StatusType` is 'Active'.\nI will use a COUNT(*) to get the total number of schools that meet these criteria.\n\n-- SQL Query\nSELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin' AND StatusType = 'Active';",
        "pred_query": "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin' AND StatusType = 'Active';",
        "pred_time": 0.009690046310424805,
        "orig_time": 0.0076904296875,
        "time_ratio": 0.7936422016091332,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "original_query": "SELECT CAST(SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTRING(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "llm_output": "-- Reasoning\nFirst, identify the CustomerID from the transactions_1k table based on the given date and price.\nThen, calculate the total consumption for this customer for the year 2012 and year 2013 from the yearmonth table.\nFinally, compute the decrease rate using the formula: (consumption_2012 - consumption_2013) / consumption_2012.\n\n-- SQL Query\nSELECT\n  (SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2013' THEN T2.Consumption ELSE 0 END)) * 1.0 / SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END)\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2\n  ON T1.CustomerID = T2.CustomerID\nWHERE\n  T1.Price = 634.8 AND T1.Date = '2012-08-25';",
        "pred_query": "SELECT\n  (SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2013' THEN T2.Consumption ELSE 0 END)) * 1.0 / SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END)\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2\n  ON T1.CustomerID = T2.CustomerID\nWHERE\n  T1.Price = 634.8 AND T1.Date = '2012-08-25';",
        "pred_time": 0.12415742874145508,
        "orig_time": 0.022330760955810547,
        "time_ratio": 0.17985843603697715,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Identify the heaviest superhero in DC Comics.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `publisher` table to filter by 'DC Comics'.\nThen, I will order the results by `weight_kg` in descending order to find the heaviest superhero.\nFinally, I will select the `superhero_name` and limit the result to 1.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1;",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1;",
        "pred_time": 0.0011131763458251953,
        "orig_time": 0.0008344650268554688,
        "time_ratio": 0.7496251874062968,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Please list the diseases of the patients born after 1995-1-1 and have a normal Rhuematoid Factor.",
        "original_query": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > 1995-01-01",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the `Patient` table with the `Laboratory` table using the `ID` column.\nI will filter patients based on their `Birthday` being after '1995-01-01' from the `Patient` table.\nAdditionally, I will filter for a normal Rhuematoid Factor (`RA` = '-') from the `Laboratory` table.\nFinally, I will select the distinct `Diagnosis` from the `Patient` table.\n\n-- SQL Query\nSELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday > '1995-01-01' AND T2.RA = '-';",
        "pred_query": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday > '1995-01-01' AND T2.RA = '-';",
        "pred_time": 0.0052182674407958984,
        "orig_time": 0.0043506622314453125,
        "time_ratio": 0.8337369214602275,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the name of user with the ID of 30?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = 30",
        "llm_output": "-- Reasoning\nThe question asks for the name of a user given their ID.\nThe `users` table contains user information, including `DisplayName` and `Id`.\nI will select the `DisplayName` from the `users` table where the `Id` is 30.\n\n-- SQL Query\nSELECT DisplayName FROM users WHERE Id = 30;",
        "pred_query": "SELECT DisplayName FROM users WHERE Id = 30;",
        "pred_time": 0.0008289813995361328,
        "orig_time": 0.0007190704345703125,
        "time_ratio": 0.8674144377336784,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "original_query": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "llm_output": "-- Reasoning\nTo find the time of races, I need to access the `races` table.\nThe question specifies races held on 'Sepang International Circuit', which is in the `circuits` table.\nI will join `races` and `circuits` tables using `circuitId`.\nThen, I will filter the results where `circuits.name` is 'Sepang International Circuit' and select the `time` from the `races` table.\n\n-- SQL Query\nSELECT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "pred_query": "SELECT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the names of the races held on the circuits in Spain.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "llm_output": "ite\nSELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain'\n",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain'",
        "pred_time": 0.001257181167602539,
        "orig_time": 0.0008623600006103516,
        "time_ratio": 0.6859472785890385,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
        "original_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
        "llm_output": "-- Reasoning\nThe user wants to find atom IDs.\nWe need to join the `atom` table with the `molecule` table to filter by molecule properties.\nWe filter for molecules with a `label` of '+' (carcinogenic) and atoms with an `element` of 'O' (oxygen).\n\n-- SQL Query\nSELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'O';",
        "pred_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'O';",
        "pred_time": 0.002604961395263672,
        "orig_time": 0.001981496810913086,
        "time_ratio": 0.7606626395753249,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "llm_output": "-- Reasoning\nI need to count accounts that are linked to the 'Prague' district and also have an entry in the `loan` table.\nI will join `account` with `district` to filter for 'Prague' and then join with `loan` to identify accounts with loans.\nFinally, I will count the distinct `account_id`s.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = 'Prague';",
        "pred_query": "SELECT COUNT(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = 'Prague';",
        "pred_time": 0.0012378692626953125,
        "orig_time": 0.0007827281951904297,
        "time_ratio": 0.6323189522342064,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Is molecule TR124 carcinogenic?",
        "original_query": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
        "llm_output": "-- Reasoning\nThe question asks for the carcinogenicity of a specific molecule, 'TR124'.\nThe `molecule` table contains `molecule_id` and a `label` column, which likely indicates whether the molecule is carcinogenic or not.\nTo answer the question, I need to query the `molecule` table and select the `label` where `molecule_id` is 'TR124'.\n\n-- SQL Query\nSELECT label FROM molecule WHERE molecule_id = 'TR124';",
        "pred_query": "SELECT label FROM molecule WHERE molecule_id = 'TR124';",
        "pred_time": 0.0008227825164794922,
        "orig_time": 0.00045990943908691406,
        "time_ratio": 0.5589684149521877,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the anti Cardiolipin antibody concentration of the female patient with the highest uric acid level in the normal range?",
        "original_query": "SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T1.SEX = 'F' AND T2.UA > 6.5 ORDER BY T2.UA DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo answer this question, I need to identify female patients with uric acid levels within the normal range. From previous examples, a normal UA range for females is `UA <= 6.5`. Then, I need to find the patient among this group who has the highest `UA` level. Finally, I will retrieve their anti-Cardiolipin antibody concentration (`aCL IgA`) from the `Examination` table.\n\n-- SQL Query\n\nSELECT T2.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T3.UA <= 6.5 ORDER BY T3.UA DESC LIMIT 1;\n",
        "pred_query": "SELECT T2.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T3.UA <= 6.5 ORDER BY T3.UA DESC LIMIT 1;",
        "pred_time": 0.0033233165740966797,
        "orig_time": 0.0012042522430419922,
        "time_ratio": 0.3623645885644594,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Calculate the ratio of votes in 2010 and 2011.",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
        "llm_output": "-- Reasoning\nTo calculate the ratio, we need to count the votes for each year (2010 and 2011) from the `votes` table.\nThe year can be extracted from the `CreationDate` column using `STRFTIME('%Y', CreationDate)`.\nFinally, divide the total votes in 2010 by the total votes in 2011 to get the ratio.\n\n-- SQL Query\nSELECT\n  CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) /\n  SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0))\nFROM votes;",
        "pred_query": "SELECT\n  CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) /\n  SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0))\nFROM votes;",
        "pred_time": 0.02453923225402832,
        "orig_time": 0.017671585083007812,
        "time_ratio": 0.7201360213747875,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Calculate the difference in view count from post posted by mornington and view count from posts posted by Amos.",
        "original_query": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "llm_output": "-- Reasoning\nI need to find the total view count for posts by 'mornington' and 'Amos' separately.\nI will join the `posts` table with the `users` table on `OwnerUserId` to link posts to their owners.\nThen, I will filter by `DisplayName` for each user and sum their respective `ViewCount`s.\nFinally, I will subtract the total view count of posts by 'Amos' from the total view count of posts by 'mornington'.\n\n-- SQL Query\nSELECT\n  (\n    SELECT\n      SUM(T1.ViewCount)\n    FROM posts AS T1\n    INNER JOIN users AS T2\n      ON T1.OwnerUserId = T2.Id\n    WHERE\n      T2.DisplayName = 'mornington'\n  ) - (\n    SELECT\n      SUM(T1.ViewCount)\n    FROM posts AS T1\n    INNER JOIN users AS T2\n      ON T1.OwnerUserId = T2.Id\n    WHERE\n      T2.DisplayName = 'Amos'\n  );",
        "pred_query": "SELECT\n  (\n    SELECT\n      SUM(T1.ViewCount)\n    FROM posts AS T1\n    INNER JOIN users AS T2\n      ON T1.OwnerUserId = T2.Id\n    WHERE\n      T2.DisplayName = 'mornington'\n  ) - (\n    SELECT\n      SUM(T1.ViewCount)\n    FROM posts AS T1\n    INNER JOIN users AS T2\n      ON T1.OwnerUserId = T2.Id\n    WHERE\n      T2.DisplayName = 'Amos'\n  );",
        "pred_time": 0.4087331295013428,
        "orig_time": 1.6238720417022705,
        "time_ratio": 3.972939613883038,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "original_query": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "llm_output": "-- Reasoning\nTo find the comment's rating score, we first need to identify the `PostId` from the `posts` table using the given `CreaionDate`.\nThen, we can join or use a subquery to find the `Score` from the `comments` table where the `PostId` matches the one found in the previous step.\n\n-- SQL Query\nSELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CreaionDate = '2010-07-19 19:19:56.0';",
        "pred_query": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CreaionDate = '2010-07-19 19:19:56.0';",
        "pred_time": 0.19440412521362305,
        "orig_time": 0.05493903160095215,
        "time_ratio": 0.28260219036289386,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "original_query": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "llm_output": "-- Reasoning\nI need to query the `cards` table.\nFilter the cards to only include those illustrated by 'Aaron Boyd'.\nThen, count the distinct values of the `type` column for these cards.\n\n-- SQL Query\nSELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "pred_query": "SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "pred_time": 0.056639909744262695,
        "orig_time": 0.05219101905822754,
        "time_ratio": 0.9214530760002526,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "original_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find transactions that occurred on '2012-08-25'.\nFrom these transactions, I need to identify the one with the earliest time.\nThen, I will join with the `gasstations` table using `GasStationID` to retrieve the `Country` of that gas station.\n\n-- SQL Query\nSELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time ASC LIMIT 1;",
        "pred_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time ASC LIMIT 1;",
        "pred_time": 0.0013687610626220703,
        "orig_time": 0.0007441043853759766,
        "time_ratio": 0.5436335133252047,
        "check": true
    },
    {
        "id": "student_club",
        "question": "When did the member, Casey Mason, received the income?",
        "original_query": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "llm_output": "-- Reasoning\nThe question asks for the income receipt date for a specific member.\nI need to join the `income` table with the `member` table using `link_to_member` and `member_id`.\nThen, I will filter the results by the member's first and last name and select the `date_received`.\n\n-- SQL Query\nSELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_query": "SELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_time": 0.0070416927337646484,
        "orig_time": 0.0007417201995849609,
        "time_ratio": 0.105332656170645,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "llm_output": "-- Reasoning\nI need to select patient IDs from the Patient table.\nI will filter patients born in 1937 using the 'Birthday' column.\nI will join the Patient table with the Laboratory table on 'ID' to access total cholesterol ('T-CHO').\nI will filter for 'T-CHO' values greater than or equal to 250, based on the provided examples defining \"normal\" cholesterol.\nI will select distinct patient IDs to avoid duplicates.\n\n-- SQL Query\nSELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250;",
        "pred_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250;",
        "pred_time": 0.001890420913696289,
        "orig_time": 0.001049041748046875,
        "time_ratio": 0.5549249590112246,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "original_query": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "llm_output": "-- Reasoning\nI need to join the `customers` and `yearmonth` tables to filter for 'LAM' segment customers and their consumption.\nThen, I will count how many of these 'LAM' customers have a consumption greater than 46.73.\nFinally, I will divide this count by the total number of 'LAM' customers and multiply by 100 to get the percentage.\n\n-- SQL Query\nSELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS REAL) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM';",
        "pred_query": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS REAL) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM';",
        "pred_time": 0.03885459899902344,
        "orig_time": 0.0399167537689209,
        "time_ratio": 1.0273366550488439,
        "check": true
    },
    {
        "id": "superhero",
        "question": "What is the gender of Agent 13 hero?",
        "original_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'",
        "llm_output": "-- Reasoning\nTo find the gender of 'Agent 13', I need to join the `superhero` table with the `gender` table.\nFirst, I will filter the `superhero` table for `superhero_name` 'Agent 13'.\nThen, I will use the `gender_id` from the `superhero` table to join with the `gender` table and retrieve the `gender` name.\n\n-- SQL Query\nSELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_time": 0.00780177116394043,
        "orig_time": 0.0007250308990478516,
        "time_ratio": 0.0929315771781316,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please give the full name of the tallest hero published by Marvel Comics.",
        "original_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the tallest hero, I need to access the `superhero` table.\nTo filter by publisher, I need to join `superhero` with the `publisher` table using `publisher_id`.\nI will filter for 'Marvel Comics' and then order the results by `height_cm` in descending order, taking the top one.\nFinally, I will select the `full_name` of that hero.\n\n-- SQL Query\nSELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_time": 0.0008590221405029297,
        "orig_time": 0.0005452632904052734,
        "time_ratio": 0.6347488204274216,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "original_query": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "llm_output": "-- Reasoning\nTo find the artists who illustrated cards in Phyrexian, I need to join the `cards` table with the `foreign_data` table.\nThe `foreign_data` table contains the `language` of the card art.\nI will filter the `foreign_data` table where the `language` is 'Phyrexian'.\nThen, I will select the distinct `artist` names from the `cards` table.\n\n-- SQL Query\nSELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian';",
        "pred_query": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian';",
        "pred_time": 0.10953092575073242,
        "orig_time": 0.0762033462524414,
        "time_ratio": 0.695724479001145,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "original_query": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "llm_output": "-- Reasoning\nI need to find the user's display name.\nThe user's ID is in the `votes` table (`UserId`) and their display name is in the `users` table.\nI will join `votes` with `posts` on `PostId` to filter posts by title.\nThen, I will filter the `votes` table for `BountyAmount = 50`.\nFinally, I will join with the `users` table on `UserId` to get the `DisplayName`.\n\n-- SQL Query\nSELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_query": "SELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_time": 0.004057645797729492,
        "orig_time": 0.0032231807708740234,
        "time_ratio": 0.7943474939773195,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Write down the ruling of Beacon of Immortality.",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "llm_output": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "pred_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "pred_time": 0.16146111488342285,
        "orig_time": 0.15398716926574707,
        "time_ratio": 0.9537105536334735,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "original_query": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "llm_output": "-- Reasoning\nI need to find molecules that contain at least one triple bond.\nThen, for each of these molecules, I need to list all unique elements that are part of that molecule.\nI can achieve this by joining the `bond` table with the `atom` table on `molecule_id`, filtering for triple bonds, and then selecting the distinct elements.\n\n-- SQL Query\nSELECT DISTINCT T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#';",
        "pred_query": "SELECT DISTINCT T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#';",
        "pred_time": 0.017589330673217773,
        "orig_time": 0.006497859954833984,
        "time_ratio": 0.3694205354117248,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "original_query": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "llm_output": "-- Reasoning\nI need to first identify all users who have received the 'Organizer' badge.\nThen, from this group of users, I will count how many are teenagers (Age between 13 and 18).\nFinally, I will calculate the percentage of teenage organizers out of the total number of organizers.\n\n-- SQL Query\nSELECT CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id)\nFROM users AS T1\nINNER JOIN badges AS T2\n  ON T1.Id = T2.UserId\nWHERE\n  T2.Name = 'Organizer';",
        "pred_query": "SELECT CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id)\nFROM users AS T1\nINNER JOIN badges AS T2\n  ON T1.Id = T2.UserId\nWHERE\n  T2.Name = 'Organizer';",
        "pred_time": 0.010479211807250977,
        "orig_time": 0.008340597152709961,
        "time_ratio": 0.7959183673469388,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to first count the number of superheroes for 'DC Comics' and 'Marvel Comics' separately.\nThen, I will compare these two counts to determine which publisher has more superheroes.\nFinally, I will calculate the absolute difference between these two counts.\n\n-- SQL Query\nWITH PublisherHeroCounts AS (\n  SELECT\n    T2.publisher_name,\n    COUNT(T1.id) AS hero_count\n  FROM superhero AS T1\n  INNER JOIN publisher AS T2\n    ON T1.publisher_id = T2.id\n  WHERE\n    T2.publisher_name IN ('DC Comics', 'Marvel Comics')\n  GROUP BY\n    T2.publisher_name\n),\nDCCount AS (\n  SELECT hero_count FROM PublisherHeroCounts WHERE publisher_name = 'DC Comics'\n),\nMarvelCount AS (\n  SELECT hero_count FROM PublisherHeroCounts WHERE publisher_name = 'Marvel Comics'\n)\nSELECT\n  CASE\n    WHEN (SELECT hero_count FROM DCCount) > (SELECT hero_count FROM MarvelCount)\n    THEN 'DC Comics'\n    ELSE 'Marvel Comics'\n  END AS publisher_with_more_heroes,\n  ABS((SELECT hero_count FROM DCCount) - (SELECT hero_count FROM MarvelCount)) AS difference_in_superheroes;",
        "pred_query": "SELECT\n    T2.publisher_name,\n    COUNT(T1.id) AS hero_count\n  FROM superhero AS T1\n  INNER JOIN publisher AS T2\n    ON T1.publisher_id = T2.id\n  WHERE\n    T2.publisher_name IN ('DC Comics', 'Marvel Comics')\n  GROUP BY\n    T2.publisher_name\n),\nDCCount AS (\n  SELECT hero_count FROM PublisherHeroCounts WHERE publisher_name = 'DC Comics'\n),\nMarvelCount AS (\n  SELECT hero_count FROM PublisherHeroCounts WHERE publisher_name = 'Marvel Comics'\n)\nSELECT\n  CASE\n    WHEN (SELECT hero_count FROM DCCount) > (SELECT hero_count FROM MarvelCount)\n    THEN 'DC Comics'\n    ELSE 'Marvel Comics'\n  END AS publisher_with_more_heroes,\n  ABS((SELECT hero_count FROM DCCount) - (SELECT hero_count FROM MarvelCount)) AS difference_in_superheroes;",
        "pred_time": null,
        "orig_time": 0.0009458065032958984,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "original_query": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "llm_output": "-- Reasoning\nI need to find the user who created a post with a specific title.\nI can achieve this by joining the `posts` table (which contains the post title and owner user ID) with the `users` table (which contains the user's display name and reputation).\nI will filter the `posts` table using the given `Title` and then select the `DisplayName` and `Reputation` from the `users` table.\n\n-- SQL Query\nSELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_query": "SELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_time": 0.10958576202392578,
        "orig_time": 0.09852099418640137,
        "time_ratio": 0.89903097233463,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "original_query": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "llm_output": "-- Reasoning\nTo find the languages available for the set, I need to query the `set_translations` table.\nThe set is identified by its `mcmName` as 'Archenemy' and `code` as 'ARC'.\nFirst, I will find the `code` from the `sets` table using the given `mcmName` and `code`.\nThen, I will use this `code` (which is `setCode` in `set_translations`) to filter and get the distinct `language` from `set_translations`.\n\n-- SQL Query\nSELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T1.code = 'ARC';",
        "pred_query": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T1.code = 'ARC';",
        "pred_time": 0.011029958724975586,
        "orig_time": 0.004145622253417969,
        "time_ratio": 0.3758511121198366,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "llm_output": "\nSELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND CAST(T2.`U-PRO` AS REAL) > 0 AND CAST(T2.`U-PRO` AS REAL) < 30;\n",
        "pred_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND CAST(T2.`U-PRO` AS REAL) > 0 AND CAST(T2.`U-PRO` AS REAL) < 30;",
        "pred_time": 0.0026421546936035156,
        "orig_time": 0.002410411834716797,
        "time_ratio": 0.9122902003248511,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What type of label is not on molecules with atoms with tin?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "llm_output": "-- Reasoning\nI need to find labels of molecules that do not contain any atoms with the element 'sn'.\nFirst, I will identify all labels associated with molecules that *do* contain atoms with element 'sn'.\nThen, I will select all labels from the `molecule` table that are *not* in the previously identified set.\n\n-- SQL Query\nSELECT T1.label FROM molecule AS T1 WHERE T1.label NOT IN (SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'sn');",
        "pred_query": "SELECT T1.label FROM molecule AS T1 WHERE T1.label NOT IN (SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'sn');",
        "pred_time": 0.002026796340942383,
        "orig_time": 0.003134012222290039,
        "time_ratio": 1.5462886719209505,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "original_query": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "llm_output": "-- Reasoning\nI need to find the `driverId` from the `qualifying` table by filtering on `raceId` and `q2` time.\nThen, I will join the `qualifying` table with the `drivers` table on `driverId`.\nFinally, I will select the `nationality` from the `drivers` table.\n\n-- SQL Query\nSELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%';",
        "pred_query": "SELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%';",
        "pred_time": 0.0017669200897216797,
        "orig_time": 0.0010004043579101562,
        "time_ratio": 0.5661854000809607,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "original_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nI need to find the flavor text for \"Ancestor's Chosen\" in Italian.\nThe `foreign_data` table contains flavor text broken down by language.\nI will join the `cards` table with `foreign_data` using the `uuid` column.\nThen I will filter by the card name 'Ancestor''s Chosen' and language 'Italian', and select the `flavorText` from `foreign_data`.\n\n-- SQL Query\nSELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';",
        "pred_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';",
        "pred_time": 0.1925339698791504,
        "orig_time": 0.1913166046142578,
        "time_ratio": 0.9936771403734277,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "original_query": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "llm_output": "-- Reasoning\nI need to find the `expense_description` from the `expense` table.\nThis information needs to be filtered based on the `t_shirt_size` of the member who incurred the expense.\nTherefore, I will join the `expense` table with the `member` table using `link_to_member` and `member_id`.\nFinally, I will filter the results where `t_shirt_size` is 'X-Large'.\n\n-- SQL Query\nSELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';",
        "pred_query": "SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';",
        "pred_time": 0.0011565685272216797,
        "orig_time": 0.0005042552947998047,
        "time_ratio": 0.4359925788497217,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "original_query": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "llm_output": "\nSELECT\n  T1.driverId,\n  T1.code\nFROM drivers AS T1\nINNER JOIN results AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  CAST(strftime('%Y', T1.dob) AS INTEGER) = 1971 AND T2.fastestLapTime IS NOT NULL AND T2.fastestLapTime = (\n    SELECT\n      MIN(T2_sub.fastestLapTime)\n    FROM drivers AS T1_sub\n    INNER JOIN results AS T2_sub\n      ON T1_sub.driverId = T2_sub.driverId\n    WHERE\n      CAST(strftime('%Y', T1_sub.dob) AS INTEGER) = 1971 AND T2_sub.fastestLapTime IS NOT NULL\n  );\n",
        "pred_query": "SELECT\n  T1.driverId,\n  T1.code\nFROM drivers AS T1\nINNER JOIN results AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  CAST(strftime('%Y', T1.dob) AS INTEGER) = 1971 AND T2.fastestLapTime IS NOT NULL AND T2.fastestLapTime = (\n    SELECT\n      MIN(T2_sub.fastestLapTime)\n    FROM drivers AS T1_sub\n    INNER JOIN results AS T2_sub\n      ON T1_sub.driverId = T2_sub.driverId\n    WHERE\n      CAST(strftime('%Y', T1_sub.dob) AS INTEGER) = 1971 AND T2_sub.fastestLapTime IS NOT NULL\n  );",
        "pred_time": 0.0072383880615234375,
        "orig_time": 0.004851341247558594,
        "time_ratio": 0.6702239789196311,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the average age of patients examined in the laboratory for the October of the year 1991?",
        "original_query": "SELECT AVG('1999' - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "llm_output": "-- Reasoning\nTo find the average age, we need to join the Patient and Laboratory tables on ID.\nWe filter the Laboratory table for records occurring in October 1991.\nThe age is calculated by subtracting the birth year from the examination year.\nFinally, we compute the average of these ages.\n\n-- SQL Query\nSELECT AVG(STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y-%m', T2.Date) = '1991-10';",
        "pred_query": "SELECT AVG(STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y-%m', T2.Date) = '1991-10';",
        "pred_time": 0.005262851715087891,
        "orig_time": 0.0020444393157958984,
        "time_ratio": 0.3884660686780828,
        "check": false
    },
    {
        "id": "financial",
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "original_query": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "llm_output": "-- Reasoning\nTo find the district ID of the account that placed a specific order, I need to join the `order` table with the `account` table.\nFirst, I will filter the `order` table by the given `order_id`.\nThen, I will join this result with the `account` table on `account_id` to retrieve the `district_id`.\n\n-- SQL Query\nSELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_query": "SELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_time": 0.0011560916900634766,
        "orig_time": 0.0005588531494140625,
        "time_ratio": 0.4833986388946174,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "original_query": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "llm_output": "-- Reasoning\nI need to calculate a percentage, which requires two counts: the total number of distinct players born between 1987 and 1992, and the number of distinct players from that group who prefer their left foot.\nI will use the `Player` table to filter players by birth year (`birthday` column) and the `Player_Attributes` table to determine their preferred foot.\nA `JOIN` on `player_api_id` will link players to their attributes. I must use `COUNT(DISTINCT player_api_id)` to ensure each player is counted only once.\nThe `STRFTIME('%Y', birthday)` function will extract the year from the `birthday` text column for filtering.\n\n-- SQL Query\nSELECT\n  CAST(\n    (SELECT COUNT(DISTINCT T1.player_api_id)\n     FROM Player AS T1\n     JOIN Player_Attributes AS T2\n       ON T1.player_api_id = T2.player_api_id\n     WHERE STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992'\n       AND T2.preferred_foot = 'left') AS REAL\n  ) * 100 /\n  (SELECT COUNT(DISTINCT player_api_id)\n   FROM Player\n   WHERE STRFTIME('%Y', birthday) BETWEEN '1987' AND '1992');",
        "pred_query": "SELECT\n  CAST(\n    (SELECT COUNT(DISTINCT T1.player_api_id)\n     FROM Player AS T1\n     JOIN Player_Attributes AS T2\n       ON T1.player_api_id = T2.player_api_id\n     WHERE STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992'\n       AND T2.preferred_foot = 'left') AS REAL\n  ) * 100 /\n  (SELECT COUNT(DISTINCT player_api_id)\n   FROM Player\n   WHERE STRFTIME('%Y', birthday) BETWEEN '1987' AND '1992');",
        "pred_time": 0.10278105735778809,
        "orig_time": 0.10476446151733398,
        "time_ratio": 1.0192973706491608,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What is the least common element of all carcinogenic molecules?",
        "original_query": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "llm_output": "-- Reasoning\nI need to first identify all carcinogenic molecules using the `molecule` table (label = '+').\nThen, I will join this with the `atom` table to get the elements present in these molecules.\nI will count the distinct number of carcinogenic molecules each element appears in.\nFinally, I will order by this count in ascending order and limit to 1 to find the least common element.\n\n-- SQL Query\nSELECT T1.element\nFROM atom AS T1\nINNER JOIN molecule AS T2\n  ON T1.molecule_id = T2.molecule_id\nWHERE\n  T2.label = '+'\nGROUP BY\n  T1.element\nORDER BY\n  COUNT(DISTINCT T1.molecule_id) ASC\nLIMIT 1;",
        "pred_query": "SELECT T1.element\nFROM atom AS T1\nINNER JOIN molecule AS T2\n  ON T1.molecule_id = T2.molecule_id\nWHERE\n  T2.label = '+'\nGROUP BY\n  T1.element\nORDER BY\n  COUNT(DISTINCT T1.molecule_id) ASC\nLIMIT 1;",
        "pred_time": 0.004445075988769531,
        "orig_time": 0.003596782684326172,
        "time_ratio": 0.8091611242222699,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "llm_output": "-- Reasoning\nI need to count the number of distinct drivers meeting the criteria (born before 1985, raced between 2000-2005, and had laps over 50) and divide it by the total distinct drivers meeting the birth year and race year criteria.\nI will join `drivers`, `races`, and `lapTimes` tables.\nThe `dob` column in `drivers` will be used to filter drivers born before 1985, and `year` in `races` will filter races between 2000 and 2005.\nThe `lap` column in `lapTimes` will be used to identify drivers with lap numbers over 50.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN T3.lap > 50 THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(T1.driverId)\nFROM drivers AS T1\nINNER JOIN lapTimes AS T3\n  ON T1.driverId = T3.driverId\nINNER JOIN races AS T2\n  ON T3.raceId = T2.raceId\nWHERE\n  T2.year BETWEEN 2000 AND 2005 AND STRFTIME('%Y', T1.dob) < '1985';",
        "pred_query": "SELECT CAST(SUM(CASE WHEN T3.lap > 50 THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(T1.driverId)\nFROM drivers AS T1\nINNER JOIN lapTimes AS T3\n  ON T1.driverId = T3.driverId\nINNER JOIN races AS T2\n  ON T3.raceId = T2.raceId\nWHERE\n  T2.year BETWEEN 2000 AND 2005 AND STRFTIME('%Y', T1.dob) < '1985';",
        "pred_time": 0.24522686004638672,
        "orig_time": 0.003297090530395508,
        "time_ratio": 0.013445062787052917,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "llm_output": "-- Reasoning\nI need to retrieve the first and last names of members.\nMembers are linked to their major via `link_to_major`.\nThe major table contains the `department` information.\nI will join `member` and `major` tables and filter by `department = 'Art and Design'`.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_time": 0.0018067359924316406,
        "orig_time": 0.0008206367492675781,
        "time_ratio": 0.4542095539720243,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "original_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to find the `setCode` for the card named \"Fellwar Stone\" from the `cards` table.\nThen I will join `cards` with `set_translations` on `setCode`.\nFinally, I will filter `set_translations` by `language = 'Japanese'` to get the Japanese name of the set.\n\n-- SQL Query\nSELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese';",
        "pred_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese';",
        "pred_time": null,
        "orig_time": 0.09886693954467773,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Provide the name of superhero with superhero ID 294.",
        "original_query": "SELECT superhero_name FROM superhero WHERE id = 294",
        "llm_output": "-- Reasoning\nI need to retrieve the superhero's name from the `superhero` table.\nThe question specifies a `superhero ID` of 294.\nTherefore, I will select `superhero_name` from the `superhero` table where the `id` column matches 294.\n\n-- SQL Query\nSELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_query": "SELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_time": 0.0025267601013183594,
        "orig_time": 0.0012595653533935547,
        "time_ratio": 0.4984902811851293,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Mention the category of events which were held at MU 215.",
        "original_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "llm_output": "-- Reasoning\nTo find the category of events held at 'MU 215', I need to join the 'event' table (which contains location information) with the 'budget' table (which contains event categories). I will filter by the location 'MU 215' and select the distinct categories.\n\n-- SQL Query\nSELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';",
        "pred_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';",
        "pred_time": 0.0011146068572998047,
        "orig_time": 0.0005426406860351562,
        "time_ratio": 0.48684491978609623,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Which group does superhero A-Bomb belong to?",
        "original_query": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'",
        "llm_output": "-- Reasoning\nThe question asks for the group a superhero belongs to, which can be interpreted as their publisher.\nI need to find the `publisher_name` from the `publisher` table.\nThis requires joining the `superhero` table with the `publisher` table on `publisher_id`.\nThen, filter the results where the `superhero_name` is 'A-Bomb'.\n\n-- SQL Query\nSELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';",
        "pred_query": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';",
        "pred_time": 0.0011250972747802734,
        "orig_time": 0.0068433284759521484,
        "time_ratio": 6.082432718796355,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which year has the most number of races?",
        "original_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the year with the most races, I need to count the races for each year.\nI will group the `races` table by the 'year' column.\nThen, I will count the number of races in each group and order the results in descending order of the count.\nFinally, I will limit the result to 1 to get the year with the maximum number of races.\n\n-- SQL Query\nSELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_time": 0.0015006065368652344,
        "orig_time": 0.0007941722869873047,
        "time_ratio": 0.5292341912932952,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many posts were created by Daniel Vassallo?",
        "original_query": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "llm_output": "-- Reasoning\nI need to count the entries in the 'posts' table.\nEach post is linked to a user via `OwnerUserId`.\nI will join 'posts' with 'users' on `posts.OwnerUserId = users.Id`.\nThen, I will filter the results where `users.DisplayName` is 'Daniel Vassallo' and count the posts.\n\n-- SQL Query\nSELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_query": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_time": 0.1844618320465088,
        "orig_time": 0.30681920051574707,
        "time_ratio": 1.663320791687616,
        "check": false
    },
    {
        "id": "financial",
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "original_query": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "llm_output": "\nSELECT CAST(SUM(CASE WHEN T3.frequency = 'weekly issuance' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nINNER JOIN account AS T3\n  ON T2.account_id = T3.account_id\nWHERE\n  T1.gender = 'M';\n",
        "pred_query": "SELECT CAST(SUM(CASE WHEN T3.frequency = 'weekly issuance' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nINNER JOIN account AS T3\n  ON T2.account_id = T3.account_id\nWHERE\n  T1.gender = 'M';",
        "pred_time": 0.0024750232696533203,
        "orig_time": 0.0074727535247802734,
        "time_ratio": 3.019265966669878,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "original_query": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "llm_output": "SELECT MAX(`Percent (%) Eligible Free (K-12)`) FROM frpm WHERE `County Name` = 'Alameda'",
        "pred_query": "SELECT MAX(`Percent (%) Eligible Free (K-12)`) FROM frpm WHERE `County Name` = 'Alameda'",
        "pred_time": 0.004613399505615234,
        "orig_time": 0.0032477378845214844,
        "time_ratio": 0.7039793281653747,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "original_query": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "llm_output": "-- Reasoning\nTo find the reputation of the owner of post 65041, I first need to find the `OwnerUserId` from the `posts` table using the given `PostId`.\nThen, I will use this `OwnerUserId` to join with the `users` table and retrieve the `Reputation` for that user.\n\n-- SQL Query\nSELECT T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 65041;",
        "pred_query": "SELECT T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 65041;",
        "pred_time": 0.0011446475982666016,
        "orig_time": 0.0005552768707275391,
        "time_ratio": 0.4851072693188919,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "original_query": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the fastest lap speed, I need to look at the `fastestLapSpeed` column in the `results` table.\nI need to filter for a specific race, \"Spanish Grand Prix\" in the year 2009.\nThis information is available in the `races` table.\nTherefore, I will join `results` and `races` tables on `raceId` and then filter by `races.year` and `races.name`.\nFinally, I will select the maximum `fastestLapSpeed` from the filtered results.\n\n-- SQL Query\nSELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_query": "SELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_time": 0.005572080612182617,
        "orig_time": 0.0036313533782958984,
        "time_ratio": 0.6517051046168328,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many high-level credit cards have \"disponent\" type of disposition?",
        "original_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'DISPONENT'",
        "llm_output": "-- Reasoning\nThe question asks to count \"high-level credit cards\" with a \"disponent\" type of disposition.\n1.  Identify cards: The `card` table contains information about cards, including their `type`.\n2.  Filter by card type: \"high-level credit cards\" is interpreted as a specific type within the `card.type` column. In banking contexts, 'gold' is often considered a \"high-level\" card type.\n3.  Filter by disposition type: The `disp` table contains disposition information, including `type`. We need to filter for `type = 'Disponent'`.\n4.  Join tables: The `card` and `disp` tables are linked by `disp_id`.\n5.  Count: Count the `card_id`s that meet both criteria.\n\n-- SQL Query\nSELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'Disponent';",
        "pred_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'Disponent';",
        "pred_time": 0.001188516616821289,
        "orig_time": 0.0006186962127685547,
        "time_ratio": 0.5205616850551655,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List all of the College of Humanities and Social Sciences' departments.",
        "original_query": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "llm_output": "SELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "pred_query": "SELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "pred_time": 0.0010800361633300781,
        "orig_time": 0.0005335807800292969,
        "time_ratio": 0.49403973509933774,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List the expansion type of the set \"Huiti\u00c3\u00a8me \u00c3\u00a9dition\".",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition' )",
        "llm_output": "\nSELECT type FROM sets WHERE name = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';\n",
        "pred_query": "SELECT type FROM sets WHERE name = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';",
        "pred_time": 0.005249738693237305,
        "orig_time": 0.003958463668823242,
        "time_ratio": 0.7540306099277896,
        "check": true
    },
    {
        "id": "student_club",
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "original_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
        "llm_output": "\nSELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';\n",
        "pred_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';",
        "pred_time": 0.001232147216796875,
        "orig_time": 0.0005068778991699219,
        "time_ratio": 0.41137770897832815,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List down at least five superpowers of male superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
        "llm_output": "SELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN hero_power AS T4 ON T1.id = T4.hero_id INNER JOIN superpower AS T3 ON T4.power_id = T3.id WHERE T2.gender = 'Male' LIMIT 5",
        "pred_query": "SELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN hero_power AS T4 ON T1.id = T4.hero_id INNER JOIN superpower AS T3 ON T4.power_id = T3.id WHERE T2.gender = 'Male' LIMIT 5",
        "pred_time": 0.007417440414428711,
        "orig_time": 0.0008242130279541016,
        "time_ratio": 0.11111825399376427,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "For the race happened in 2015/11/29, how many drivers finished the game?",
        "original_query": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "llm_output": "-- Reasoning\nTo find the race that happened on '2015-11-29', I will query the `races` table.\nThen, I need to join with the `results` table to get driver information for that specific race.\nA driver finished the race if their `time` in the `results` table is not NULL.\nFinally, I will count the distinct `driverId`s that satisfy these conditions.\n\n-- SQL Query\nSELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;",
        "pred_query": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;",
        "pred_time": 0.00406646728515625,
        "orig_time": 0.003283262252807617,
        "time_ratio": 0.8073991557223265,
        "check": true
    },
    {
        "id": "superhero",
        "question": "How many superheroes are published by Marvel Comics?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "llm_output": "-- Reasoning\nTo find the number of superheroes published by Marvel Comics, I need to join the `superhero` table with the `publisher` table.\nI will filter the results where the `publisher_name` is 'Marvel Comics'.\nFinally, I will count the `id` from the `superhero` table.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_time": 0.001093149185180664,
        "orig_time": 0.0005903244018554688,
        "time_ratio": 0.5400218102508179,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "original_query": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "llm_output": "SELECT MIN(milliseconds) FROM lapTimes;",
        "pred_query": "SELECT MIN(milliseconds) FROM lapTimes;",
        "pred_time": 0.028302431106567383,
        "orig_time": 0.27254509925842285,
        "time_ratio": 9.629741637112604,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Give the publisher ID of Star Trek.",
        "original_query": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
        "llm_output": "-- Reasoning\nI need to find the publisher ID from the 'superhero' table.\nI will filter the 'superhero' table by the superhero_name 'Star Trek'.\nThen I will select the 'publisher_id' column.\n\n-- SQL Query\nSELECT publisher_id FROM superhero WHERE superhero_name = 'Star Trek';",
        "pred_query": "SELECT publisher_id FROM superhero WHERE superhero_name = 'Star Trek';",
        "pred_time": 0.0009179115295410156,
        "orig_time": 0.0004544258117675781,
        "time_ratio": 0.49506493506493504,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the name of the race held on the circuits in Germany.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "llm_output": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'",
        "pred_time": 0.001195669174194336,
        "orig_time": 0.0008213520050048828,
        "time_ratio": 0.6869391824526421,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "original_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'",
        "llm_output": "-- Reasoning\nI need to find the `Id` of the post with the title 'How does gentle boosting differ from AdaBoost?' from the `posts` table.\nThen, I will select the `Text` from the `comments` table where the `PostId` matches the `Id` found in the previous step.\n\n-- SQL Query\nSELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_query": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_time": 0.20062565803527832,
        "orig_time": 0.1900191307067871,
        "time_ratio": 0.9471327474643042,
        "check": true
    },
    {
        "id": "financial",
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "original_query": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "llm_output": "-- Reasoning\nThe query needs to join the `account` and `district` tables on `district_id`.\nIt filters accounts created in 1993 using the `date` column in the `account` table.\nIt also filters for accounts with 'POPLATEK PO OBRATU' in the `frequency` column, which corresponds to statements issued after transactions.\nFinally, it selects the `account_id` from `account` and the `A2` (district name) and `A3` (district region) from `district`.\n\n-- SQL Query\nSELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993' AND T1.frequency = 'POPLATEK PO OBRATU';",
        "pred_query": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993' AND T1.frequency = 'POPLATEK PO OBRATU';",
        "pred_time": 0.002565622329711914,
        "orig_time": 0.0008823871612548828,
        "time_ratio": 0.3439271443174426,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Which website should I go to if I want to know more about Anthony Davidson?",
        "original_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
        "llm_output": "-- Reasoning\nTo find the website for Anthony Davidson, I need to look into the `drivers` table.\nThe `drivers` table contains the `forename`, `surname`, and `url` for each driver.\nI will filter by the driver's full name and select the corresponding URL.\n\n-- SQL Query\nSELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "pred_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "pred_time": 0.009263992309570312,
        "orig_time": 0.0007150173187255859,
        "time_ratio": 0.07718241712991558,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
        "original_query": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
        "llm_output": "-- Reasoning\nI need to filter molecules that are carcinogenic (label = '+').\nThen, for these carcinogenic molecules, I need to count the number of double bonds (bond_type = '=').\nFinally, I will find the molecule with the highest count of double bonds among the carcinogenic ones and return its ID.\n\n-- SQL Query\nSELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' AND T2.bond_type = '=' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_id) DESC LIMIT 1;",
        "pred_query": "SELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' AND T2.bond_type = '=' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_id) DESC LIMIT 1;",
        "pred_time": 0.002577543258666992,
        "orig_time": 0.0017478466033935547,
        "time_ratio": 0.6781056331514198,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
        "original_query": "SELECT NCESDist FROM schools WHERE SOC = 31",
        "llm_output": "\nSELECT NCESDist FROM schools WHERE SOCType = 'State Special Schools' AND SOC IS NOT NULL;\n",
        "pred_query": "SELECT NCESDist FROM schools WHERE SOCType = 'State Special Schools' AND SOC IS NOT NULL;",
        "pred_time": 0.010242938995361328,
        "orig_time": 0.008514165878295898,
        "time_ratio": 0.8312229412038545,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List the power of superheroes with height greater than 80% of the average height of all superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm * 100 > ( SELECT AVG(height_cm) FROM superhero ) * 80",
        "llm_output": "-- Reasoning\nI need to calculate the average height of all superheroes first.\nThen, I will filter superheroes whose height is greater than 80% of this average.\nFinally, I will join with `hero_power` and `superpower` tables to retrieve the power names for these filtered superheroes.\n\n-- SQL Query\nSELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm > (SELECT AVG(height_cm) FROM superhero) * 0.8;",
        "pred_query": "SELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm > (SELECT AVG(height_cm) FROM superhero) * 0.8;",
        "pred_time": 0.0019197463989257812,
        "orig_time": 0.0014233589172363281,
        "time_ratio": 0.7414307004470939,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "original_query": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
        "llm_output": "\nSELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';\n",
        "pred_query": "SELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';",
        "pred_time": 0.0951528549194336,
        "orig_time": 0.09568262100219727,
        "time_ratio": 1.005567526935605,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What are the card layout of cards with keyword of flying?",
        "original_query": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "llm_output": "\nSELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%'\n",
        "pred_query": "SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%'",
        "pred_time": 0.05880022048950195,
        "orig_time": 0.06011080741882324,
        "time_ratio": 1.022288809776747,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "original_query": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "llm_output": "SELECT DISTINCT T2.year FROM drivers AS T1 INNER JOIN results AS T3 ON T1.driverId = T3.driverId INNER JOIN races AS T2 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton';",
        "pred_query": "SELECT DISTINCT T2.year FROM drivers AS T1 INNER JOIN results AS T3 ON T1.driverId = T3.driverId INNER JOIN races AS T2 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton';",
        "pred_time": 0.005967140197753906,
        "orig_time": 0.005164146423339844,
        "time_ratio": 0.8654307175962922,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "original_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "llm_output": "-- Reasoning\nI need to retrieve the 'Reputation' and 'Views' columns from the 'users' table.\nThe specific user is identified by their 'DisplayName', which is 'Jarrod Dixon'.\nTherefore, I will filter the 'users' table based on the 'DisplayName' column.\n\n-- SQL Query\nSELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_time": 0.009168624877929688,
        "orig_time": 0.009068965911865234,
        "time_ratio": 0.9891304347826086,
        "check": true
    }
]