[
    {
        "id": "european_football_2",
        "question": "Please list all team names which the speed class is fast.",
        "original_query": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "llm_output": "\nSELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast'\n",
        "pred_query": "SELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast'",
        "pred_time": 0.005797386169433594,
        "orig_time": 0.0014965534210205078,
        "time_ratio": 0.25814278664253987,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "How many circuits are there in Melbourne, Australia?",
        "original_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia'",
        "llm_output": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';",
        "pred_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';",
        "pred_time": 0.0019707679748535156,
        "orig_time": 0.0009162425994873047,
        "time_ratio": 0.4649165255262521,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many Formula_1 races took place on the circuits in Italy?",
        "original_query": "SELECT COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Italy'",
        "llm_output": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';",
        "pred_query": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';",
        "pred_time": 0.010707616806030273,
        "orig_time": 0.0009622573852539062,
        "time_ratio": 0.08986662510298145,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "original_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "llm_output": "-- Reasoning\nI need to count cards that have a text box (isTextless = 0) AND have a normal layout.\nThen, I need to divide this count by the total number of cards in the 'cards' table.\nThe `isTextless` and `layout` columns are available in the `cards` table.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN isTextless = 0 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 1.0 / COUNT(id) FROM cards;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN isTextless = 0 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 1.0 / COUNT(id) FROM cards;",
        "pred_time": 1.7108879089355469,
        "orig_time": 0.05814480781555176,
        "time_ratio": 0.03398516496134885,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What's the magic card market name for the set which was released on 2017/6/9?",
        "original_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "llm_output": "-- Reasoning\nI need to find the `mcmName` from the `sets` table.\nThe filtering condition is based on the `releaseDate` column in the `sets` table.\nI will filter for `releaseDate` equal to '2017-06-09'.\n\n-- SQL Query\nSELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "pred_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "pred_time": 0.013983011245727539,
        "orig_time": 0.004185199737548828,
        "time_ratio": 0.2993060410237174,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the percentage of molecules that are carcinogenic?",
        "original_query": "SELECT CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id) FROM molecule t",
        "llm_output": "-- Reasoning\nTo find the percentage of carcinogenic molecules, I need to count all molecules and count the molecules labeled as '+'.\nThen, I will divide the count of carcinogenic molecules by the total count of molecules and multiply by 100.\nAll necessary information is available in the `molecule` table.\n\n-- SQL Query\nSELECT CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id) FROM molecule AS T;",
        "pred_query": "SELECT CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id) FROM molecule AS T;",
        "pred_time": 0.007098674774169922,
        "orig_time": 0.0008382797241210938,
        "time_ratio": 0.11808960838315309,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What is the percentage of borderless cards?",
        "original_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "llm_output": "-- Reasoning\nTo find the percentage of borderless cards, I need to count cards with 'borderless' borderColor.\nThen, I divide this count by the total number of cards.\nThe `cards` table contains the `borderColor` column, which is suitable for this calculation.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_time": 0.05825066566467285,
        "orig_time": 0.05763053894042969,
        "time_ratio": 0.989354169310047,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "original_query": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe question asks for the budget_id with the most money allocated for specific categories.\nI need to filter the `budget` table by the `category` column for 'water', 'chips', or 'cookies'.\nThen, I need to find the `budget_id` associated with the maximum `amount` among these filtered budgets.\n\n-- SQL Query\nSELECT budget_id FROM budget WHERE category IN ('water', 'chips', 'cookies') ORDER BY amount DESC LIMIT 1;",
        "pred_query": "SELECT budget_id FROM budget WHERE category IN ('water', 'chips', 'cookies') ORDER BY amount DESC LIMIT 1;",
        "pred_time": 0.0007796287536621094,
        "orig_time": 0.0005009174346923828,
        "time_ratio": 0.6425076452599389,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "original_query": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the Patient and Laboratory tables to access patient sex and total protein (TP) levels.\nI will filter for female patients and then identify those whose TP is outside the normal range (inferred from previous examples as 6.0 to 8.5).\nFor each such patient, I will calculate the deviation by subtracting TP from the lower bound (6.0) if TP is below it, or subtracting the upper bound (8.5) from TP if TP is above it.\n\n-- SQL Query\nSELECT\n  T1.ID,\n  T1.SEX,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0\n    THEN 6.0 - T2.TP\n    WHEN T2.TP > 8.5\n    THEN T2.TP - 8.5\n    ELSE 0 -- Should not happen based on WHERE clause, but good for completeness\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'F' AND (\n    T2.TP < 6.0 OR T2.TP > 8.5\n  );",
        "pred_query": "SELECT\n  T1.ID,\n  T1.SEX,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0\n    THEN 6.0 - T2.TP\n    WHEN T2.TP > 8.5\n    THEN T2.TP - 8.5\n    ELSE 0 -- Should not happen based on WHERE clause, but good for completeness\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'F' AND (\n    T2.TP < 6.0 OR T2.TP > 8.5\n  );",
        "pred_time": 0.04240155220031738,
        "orig_time": 0.00773310661315918,
        "time_ratio": 0.18237791335151396,
        "check": false
    },
    {
        "id": "card_games",
        "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
        "original_query": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "llm_output": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor''s Chosen'",
        "pred_query": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor''s Chosen'",
        "pred_time": 0.06587433815002441,
        "orig_time": 0.05946040153503418,
        "time_ratio": 0.9026337600480642,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "original_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "llm_output": "ite\nSELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'\n",
        "pred_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "pred_time": 0.018482208251953125,
        "orig_time": 0.0010864734649658203,
        "time_ratio": 0.05878482972136223,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "original_query": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "llm_output": "-- Reasoning\nTo find the free rate for students aged 5-17, we need to access the `frpm` table for the `Percent (%) Eligible Free (Ages 5-17)` column.\nThe school is identified by the administrator's name, \"Kacey Gibson\", which is stored in the `schools` table (`AdmFName1`, `AdmLName1`).\nWe will join the `frpm` table with the `schools` table using the `CDSCode` to link the school information with its free meal data.\n\n-- SQL Query\nSELECT T1.`Percent (%) Eligible Free (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson';",
        "pred_query": "SELECT T1.`Percent (%) Eligible Free (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson';",
        "pred_time": 0.03160214424133301,
        "orig_time": 0.009078025817871094,
        "time_ratio": 0.2872598058076636,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "original_query": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "llm_output": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0;",
        "pred_query": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0;",
        "pred_time": 0.021844863891601562,
        "orig_time": 0.009070634841918945,
        "time_ratio": 0.41522963415698944,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What's Angela Sanders's major?",
        "original_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "llm_output": "-- Reasoning\nTo find Angela Sanders's major, I need to look up her record in the `member` table using her first and last name.\nThen, I will use the `link_to_major` from the `member` table to join with the `major` table on `major_id`.\nFinally, I will select the `major_name` from the `major` table.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_time": 0.0007917881011962891,
        "orig_time": 0.000492095947265625,
        "time_ratio": 0.6214995483288166,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "llm_output": "\nSELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = '-' AND T1.Admission = '+'\n",
        "pred_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = '-' AND T1.Admission = '+'",
        "pred_time": 0.012595176696777344,
        "orig_time": 0.005599260330200195,
        "time_ratio": 0.44455591731657457,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "original_query": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' THEN 1 ELSE NULL END) FROM cards",
        "llm_output": "-- Reasoning\nI need to count the number of unique artists.\nI will filter the `cards` table for entries where `borderColor` is 'black'.\nAdditionally, I will filter for cards where the `availability` column contains both 'arena' and 'mtgo' using LIKE operations.\n\n-- SQL Query\nSELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%';",
        "pred_query": "SELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%';",
        "pred_time": 0.06577849388122559,
        "orig_time": 0.055435895919799805,
        "time_ratio": 0.8427662697765455,
        "check": false
    },
    {
        "id": "superhero",
        "question": "What is the name of the superhero that has the most powers?",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `hero_power` table to link superheroes to their powers.\nThen, I will count the number of powers for each superhero using `GROUP BY` and `COUNT()`.\nFinally, I will order the results to find the superhero with the maximum number of powers and `LIMIT` to 1.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_time": 0.004094362258911133,
        "orig_time": 0.002957582473754883,
        "time_ratio": 0.7223548593722704,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to identify patients with normal anti-SSB from the Laboratory table.\nThen I need to find out which of these patients have 'Symptoms' recorded in the Examination table (meaning Symptoms is not NULL).\nFinally, I will count the distinct IDs of such patients.\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SSB IN ('negative', '0') AND T2.Symptoms IS NOT NULL;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SSB IN ('negative', '0') AND T2.Symptoms IS NOT NULL;",
        "pred_time": 0.0073511600494384766,
        "orig_time": 0.0015020370483398438,
        "time_ratio": 0.20432653325981903,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "original_query": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "llm_output": "-- Reasoning\nThe question asks to compare the number of male and female patients with creatinine levels not within the normal range.\nBased on the provided examples, a creatinine level of `CRE >= 1.5` is considered \"out of the normal range\".\nWe need to count distinct patient IDs for males and females separately under this condition, then compare the two counts to determine if the male count is greater than the female count.\n\n-- SQL Query\nSELECT\n  CASE\n    WHEN (\n      SELECT COUNT(DISTINCT T1.ID)\n      FROM Patient AS T1\n      INNER JOIN Laboratory AS T2\n        ON T1.ID = T2.ID\n      WHERE\n        T1.SEX = 'M' AND T2.CRE >= 1.5\n    ) > (\n      SELECT COUNT(DISTINCT T1.ID)\n      FROM Patient AS T1\n      INNER JOIN Laboratory AS T2\n        ON T1.ID = T2.ID\n      WHERE\n        T1.SEX = 'F' AND T2.CRE >= 1.5\n    )\n    THEN 'True'\n    ELSE 'False'\n  END;",
        "pred_query": "SELECT\n  CASE\n    WHEN (\n      SELECT COUNT(DISTINCT T1.ID)\n      FROM Patient AS T1\n      INNER JOIN Laboratory AS T2\n        ON T1.ID = T2.ID\n      WHERE\n        T1.SEX = 'M' AND T2.CRE >= 1.5\n    ) > (\n      SELECT COUNT(DISTINCT T1.ID)\n      FROM Patient AS T1\n      INNER JOIN Laboratory AS T2\n        ON T1.ID = T2.ID\n      WHERE\n        T1.SEX = 'F' AND T2.CRE >= 1.5\n    )\n    THEN 'True'\n    ELSE 'False'\n  END;",
        "pred_time": 0.005768537521362305,
        "orig_time": 0.0036559104919433594,
        "time_ratio": 0.6337673072948956,
        "check": false
    },
    {
        "id": "student_club",
        "question": "List the name of students that have attended more than 7 events.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "llm_output": "-- Reasoning\nI need to join the `member` table with the `attendance` table to link members to the events they attended.\nThen, I will group the results by member to count the number of events each member attended.\nFinally, I will filter for members who attended more than 7 events and select their first and last names.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_time": 0.007615566253662109,
        "orig_time": 0.0009465217590332031,
        "time_ratio": 0.12428777158599963,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many female customers have a junior credit card?",
        "original_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "llm_output": "-- Reasoning\nI need to join `client`, `disp`, and `card` tables.\nFilter clients by `gender = 'F'` and cards by `type = 'junior'`.\nFinally, count the distinct `client_id`s that satisfy both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior';",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior';",
        "pred_time": 0.0078067779541015625,
        "orig_time": 0.0011489391326904297,
        "time_ratio": 0.14717200097727828,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "original_query": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "llm_output": "-- Reasoning\nTo determine if a bond connects atoms of both 'chlorine' and 'carbon' elements, we first need to identify all atoms involved in the specified bond.\nThe `connected` table links `bond_id` to two atom IDs (`atom_id` and `atom_id2`).\nWe can use a `UNION ALL` subquery to gather all unique atom IDs associated with the bond 'TR001_1_8'.\nThen, we join these atom IDs with the `atom` table to retrieve their respective `element` types.\nFinally, we filter these elements to include only 'cl' and 'c' and count the distinct elements. If the count is 2, it means both 'chlorine' and 'carbon' are present.\n\n-- SQL Query\nSELECT\n  CASE\n    WHEN COUNT(DISTINCT T2.element) = 2\n    THEN 'Yes'\n    ELSE 'No'\n  END\nFROM (\n  SELECT\n    atom_id\n  FROM connected\n  WHERE\n    bond_id = 'TR001_1_8'\n  UNION ALL\n  SELECT\n    atom_id2\n  FROM connected\n  WHERE\n    bond_id = 'TR001_1_8'\n) AS T1\nINNER JOIN atom AS T2\n  ON T1.atom_id = T2.atom_id\nWHERE\n  T2.element IN ('cl', 'c');",
        "pred_query": "SELECT\n  CASE\n    WHEN COUNT(DISTINCT T2.element) = 2\n    THEN 'Yes'\n    ELSE 'No'\n  END\nFROM (\n  SELECT\n    atom_id\n  FROM connected\n  WHERE\n    bond_id = 'TR001_1_8'\n  UNION ALL\n  SELECT\n    atom_id2\n  FROM connected\n  WHERE\n    bond_id = 'TR001_1_8'\n) AS T1\nINNER JOIN atom AS T2\n  ON T1.atom_id = T2.atom_id\nWHERE\n  T2.element IN ('cl', 'c');",
        "pred_time": 0.01419973373413086,
        "orig_time": 0.0026619434356689453,
        "time_ratio": 0.18746432049430806,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to find patients with a normal Ig G level. Based on previous examples, `IGG < 900` is considered \"lower than normal\", so a \"normal Ig G level\" implies `IGG >= 900`.\nThen, I need to check how many of these patients have any recorded symptoms. Symptoms are in the `Examination` table.\nI will join `Laboratory` and `Examination` tables on `ID`, filter for `IGG >= 900` in `Laboratory`, and `Symptoms IS NOT NULL` in `Examination`, then count distinct patient IDs.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.IGG >= 900 AND T2.Symptoms IS NOT NULL;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.IGG >= 900 AND T2.Symptoms IS NOT NULL;",
        "pred_time": 0.005829572677612305,
        "orig_time": 0.0007548332214355469,
        "time_ratio": 0.12948345670933703,
        "check": false
    },
    {
        "id": "financial",
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "original_query": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.district_id = ( SELECT district_id FROM client ORDER BY birth_date DESC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe query needs to find the account_id of the client who is the youngest and is associated with a district having the highest average salary.\n1. Join `client` and `district` tables on `district_id` to access birth_date and average salary (A11).\n2. Join `client` with `disp` and then `disp` with `account` to link the client to their account_id.\n3. Order the results first by `birth_date` in descending order (youngest) and then by `A11` (average salary) in descending order (highest).\n4. Limit the result to 1 to get the top matching account.\n\n-- SQL Query\nSELECT T4.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T4 ON T3.account_id = T4.account_id ORDER BY T1.birth_date DESC, T2.A11 DESC LIMIT 1;",
        "pred_query": "SELECT T4.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T4 ON T3.account_id = T4.account_id ORDER BY T1.birth_date DESC, T2.A11 DESC LIMIT 1;",
        "pred_time": 0.012267589569091797,
        "orig_time": 0.0011696815490722656,
        "time_ratio": 0.09534730050141875,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
        "original_query": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
        "llm_output": "\nSELECT T1.name FROM circuits AS T1 JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year BETWEEN 1990 AND 2000 GROUP BY T1.circuitId HAVING COUNT(T2.raceId) = 4;\n",
        "pred_query": "SELECT T1.name FROM circuits AS T1 JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year BETWEEN 1990 AND 2000 GROUP BY T1.circuitId HAVING COUNT(T2.raceId) = 4;",
        "pred_time": 0.0012862682342529297,
        "orig_time": 0.0009739398956298828,
        "time_ratio": 0.7571825764596849,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to count the number of superheroes for 'DC Comics' and 'Marvel Comics' separately.\nThen, I will calculate the absolute difference between these two counts to determine which publisher has more superheroes and by how many.\nConditional aggregation with `SUM(CASE WHEN ... THEN 1 ELSE 0 END)` will be used to get the counts in a single pass.\n\n-- SQL Query\nSELECT\n  ABS(\n    SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) -\n    SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)\n  )\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_query": "SELECT\n  ABS(\n    SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) -\n    SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)\n  )\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_time": 0.0010492801666259766,
        "orig_time": 0.0006887912750244141,
        "time_ratio": 0.656441717791411,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Please list the names of the badges obtained by csgillespie.",
        "original_query": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "llm_output": "-- Reasoning\nTo find the names of badges obtained by 'csgillespie', I need to join the 'badges' table with the 'users' table.\nI will join them on `badges.UserId` = `users.Id`.\nThen I will filter the results where `users.DisplayName` is 'csgillespie'.\nFinally, I will select the `Name` column from the `badges` table.\n\n-- SQL Query\nSELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_query": "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_time": 0.24509906768798828,
        "orig_time": 0.06385922431945801,
        "time_ratio": 0.26054454193498183,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "original_query": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "llm_output": "\nSELECT T2.team_long_name FROM Match AS T1 INNER JOIN Team AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN League AS T3 ON T1.league_id = T3.id WHERE T3.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T2.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1\n",
        "pred_query": "SELECT T2.team_long_name FROM Match AS T1 INNER JOIN Team AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN League AS T3 ON T1.league_id = T3.id WHERE T3.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T2.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1",
        "pred_time": 0.6442241668701172,
        "orig_time": 0.05481386184692383,
        "time_ratio": 0.08508507545320776,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the bond type for atoms with element Tin?",
        "original_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "llm_output": "-- Reasoning\nI need to find the `bond_type` from the `bond` table.\nTo link bonds to atoms, I will join `bond` with `connected` on `bond_id`.\nThen, I will join `connected` with `atom` on `atom_id` (or `atom_id2`) to filter for atoms with `element` 'Tin'.\nFinally, I will select the distinct `bond_type`.\n\n-- SQL Query\nSELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Sn'",
        "pred_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Sn'",
        "pred_time": 0.03762459754943848,
        "orig_time": 0.014079570770263672,
        "time_ratio": 0.37421186370866044,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "original_query": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "llm_output": "\nSELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'\n",
        "pred_query": "SELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "pred_time": 1.1450388431549072,
        "orig_time": 0.3693392276763916,
        "time_ratio": 0.32255606862973935,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "llm_output": "-- Reasoning\nThe query needs to count examinations from the `Examination` table.\nTwo conditions must be met:\n1. The `Examination Date` must be after '1997-01-01'.\n2. The examination must have a \"result of an inactivated partial prothrombin time\". The `Examination` table has a `LAC` (Lupus Anticoagulant) column, which is often tested when \"inactivated partial prothrombin time\" is suspected. A positive `LAC` result typically indicates this condition. Assuming 'Positive' is the value for such a result in the `LAC` TEXT column.\n\n-- SQL Query\nSELECT COUNT(ID) FROM Examination WHERE `Examination Date` > '1997-01-01' AND LAC = 'Positive';",
        "pred_query": "SELECT COUNT(ID) FROM Examination WHERE `Examination Date` > '1997-01-01' AND LAC = 'Positive';",
        "pred_time": 0.0009608268737792969,
        "orig_time": 0.0036411285400390625,
        "time_ratio": 3.7895781637717123,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'Owner' AND T1.frequency = 'POPLATEK TYDNE'",
        "llm_output": "-- Reasoning\nI need to count unique clients based on two conditions: their account's frequency and their role in the account.\nI will join the `client`, `disp`, and `account` tables.\nFilter `account.frequency` for 'POPLATEK TYDNE' (weekly issuance) and `disp.type` for 'OWNER'.\nFinally, count the distinct `client_id` to get the number of customers.\n\n-- SQL Query\nSELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_time": 0.002260446548461914,
        "orig_time": 0.0008089542388916016,
        "time_ratio": 0.3578736420208839,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "How many users received commentator badges in 2014?",
        "original_query": "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'",
        "llm_output": "-- Reasoning\nI need to count the number of unique users.\nThese users must have received a badge named 'commentator'.\nThe badge receipt date must be in the year 2014.\nI will join the `badges` and `users` table to link user IDs, but `badges` table already has `UserId`.\nSo, I will filter the `badges` table by `Name` and `Date` and then count distinct `UserId`.\n\nSELECT COUNT(DISTINCT T1.UserId) FROM badges AS T1 WHERE T1.Name = 'commentator' AND STRFTIME('%Y', T1.Date) = '2014';",
        "pred_query": "SELECT COUNT(DISTINCT T1.UserId) FROM badges AS T1 WHERE T1.Name = 'commentator' AND STRFTIME('%Y', T1.Date) = '2014';",
        "pred_time": 0.009488344192504883,
        "orig_time": 0.009099245071411133,
        "time_ratio": 0.9589918838103375,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "How many users are awarded with more than 5 badges?",
        "original_query": "SELECT UserId FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "llm_output": "-- Reasoning\nI need to count users who have more than 5 badges.\nFirst, I will group the `badges` table by `UserId` and count the badges for each user.\nThen, I will filter these groups to include only those where the badge count is greater than 5 using a `HAVING` clause.\nFinally, I will count the number of distinct `UserId`s from the filtered results.\n\n-- SQL Query\nSELECT COUNT(T1.UserId) FROM badges AS T1 GROUP BY T1.UserId HAVING COUNT(T1.Id) > 5;",
        "pred_query": "SELECT COUNT(T1.UserId) FROM badges AS T1 GROUP BY T1.UserId HAVING COUNT(T1.Id) > 5;",
        "pred_time": 0.029435157775878906,
        "orig_time": 0.035888671875,
        "time_ratio": 1.2192450996274098,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "original_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "llm_output": "-- Reasoning\nI need to retrieve the `Title` from the `posts` table.\nThe posts are linked to users who edited them via the `LastEditorUserId` column in the `posts` table and the `Id` column in the `users` table.\nI will join `posts` and `users` tables on these columns and filter by the `DisplayName` 'Vebjorn Ljosa' in the `users` table.\n\n-- SQL Query\nSELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_time": 0.31700968742370605,
        "orig_time": 0.19586539268493652,
        "time_ratio": 0.6178530198137083,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What percentage of cards without power are in French?",
        "original_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power LIKE '%*%'",
        "llm_output": "-- Reasoning\nThe question asks for the percentage of cards without power that are in French.\nThis means we need two numbers:\n1. The total count of unique cards that do not have a power value. This can be obtained from the `cards` table.\n2. The count of unique cards that do not have a power value AND have at least one French translation. This requires joining `cards` and `foreign_data` tables.\n\nThe percentage will be (count of unique cards without power and in French) / (total count of unique cards without power) * 100.\nUsing subqueries is the most straightforward way to calculate these two distinct counts accurately.\n\n-- SQL Query\nSELECT CAST((SELECT COUNT(DISTINCT T1.uuid) FROM cards AS T1 JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL AND T2.language = 'French') AS REAL) * 100 / (SELECT COUNT(uuid) FROM cards WHERE power IS NULL);",
        "pred_query": "SELECT CAST((SELECT COUNT(DISTINCT T1.uuid) FROM cards AS T1 JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL AND T2.language = 'French') AS REAL) * 100 / (SELECT COUNT(uuid) FROM cards WHERE power IS NULL);",
        "pred_time": 2.299221992492676,
        "orig_time": 0.29742956161499023,
        "time_ratio": 0.1293609588748476,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "original_query": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "llm_output": "SELECT DISTINCT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high';",
        "pred_query": "SELECT DISTINCT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high';",
        "pred_time": 0.14325523376464844,
        "orig_time": 0.08078861236572266,
        "time_ratio": 0.5639487664265648,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "llm_output": "-- Reasoning\nI need to join the `member` table with the `attendance` table on `member_id` and `link_to_member`.\nThen, join the `attendance` table with the `event` table on `link_to_event` and `event_id`.\nFinally, filter the results where `event_name` is 'Laugh Out Loud' and select the `first_name` and `last_name` of the members.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud';",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud';",
        "pred_time": 0.0011534690856933594,
        "orig_time": 0.0006411075592041016,
        "time_ratio": 0.555808185200496,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "llm_output": "-- Reasoning\nTo answer this question, I need to first find the card \"Samite Pilgrim\" in the `cards` table to get its `setCode`.\nThen, I will join the `cards` table with the `sets` table using the `setCode` and `code` columns respectively.\nFinally, I will select the `type` column from the `sets` table.\n\n-- SQL Query\nSELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'",
        "pred_query": "SELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'",
        "pred_time": 0.06037783622741699,
        "orig_time": 0.05738425254821777,
        "time_ratio": 0.9504191626224614,
        "check": true
    },
    {
        "id": "card_games",
        "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
        "llm_output": "-- Reasoning\nThe question asks for a count of cards meeting three criteria:\n1.  \"color cards\": This refers to cards that have at least one color. In the `cards` table, the `colors` column stores the card's colors. Cards with no color (colorless) typically have a NULL or empty string in this column. So, \"color cards\" means `colors IS NOT NULL AND colors != ''`.\n2.  \"no borders\": This refers to cards that do not have a standard border color. The `borderColor` column is used for this. Given that values like 'black' and 'white' exist, a specific value like 'none' is a strong candidate to represent \"no borders\". If 'none' is not a valid value, `borderColor IS NULL` or `borderColor = ''` would be alternative interpretations, but 'none' is more explicit. We will assume `borderColor = 'none'`.\n3.  \"ranked higher than 12000 on EDHRec\": This directly maps to the `edhrecRank` column, so `edhrecRank > 12000`.\n\nAll these conditions will be combined using AND clauses, and we will count the `id` of the matching cards.\n\n-- SQL Query\nSELECT COUNT(id) FROM cards WHERE colors IS NOT NULL AND colors != '' AND borderColor = 'none' AND edhrecRank > 12000;",
        "pred_query": "SELECT COUNT(id) FROM cards WHERE colors IS NOT NULL AND colors != '' AND borderColor = 'none' AND edhrecRank > 12000;",
        "pred_time": 0.06325197219848633,
        "orig_time": 0.05267906188964844,
        "time_ratio": 0.8328445747800587,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Calculate the average height of all neutral superheroes.",
        "original_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "llm_output": "-- Reasoning\nTo find the average height of neutral superheroes, I need to join the `superhero` table with the `alignment` table.\nI will filter the results where the `alignment` column in the `alignment` table is 'Neutral'.\nThen, I will calculate the average of the `height_cm` column from the `superhero` table.\n\n-- SQL Query\nSELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_time": 0.0008704662322998047,
        "orig_time": 0.0006830692291259766,
        "time_ratio": 0.7847165160230074,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the date when the youngest user made his or her first post?",
        "original_query": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "llm_output": "-- Reasoning\nFirst, find the minimum age among all users.\nThen, select the IDs of all users who have this minimum age.\nFinally, find the minimum 'CreaionDate' (CreationDate, assuming typo) from the 'posts' table for posts owned by any of these youngest users.\n\n-- SQL Query\nSELECT MIN(T1.CreaionDate)\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  T2.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );",
        "pred_query": "SELECT MIN(T1.CreaionDate)\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  T2.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );",
        "pred_time": 0.22779130935668945,
        "orig_time": 0.21044492721557617,
        "time_ratio": 0.9238496754327389,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
        "original_query": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "llm_output": "\nSELECT name FROM cards WHERE isPromo = 1 AND isFullArt = 1 AND side IS NOT NULL\n",
        "pred_query": "SELECT name FROM cards WHERE isPromo = 1 AND isFullArt = 1 AND side IS NOT NULL",
        "pred_time": 0.056981801986694336,
        "orig_time": 0.056853532791137695,
        "time_ratio": 0.9977489445562534,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
        "llm_output": "-- Reasoning\nI need to retrieve information about patients based on their albumin levels.\nThe patient's ID, sex, and diagnosis are in the `Patient` table.\nThe albumin level (`ALB`) is in the `Laboratory` table.\nI will join `Patient` and `Laboratory` tables on `ID` to link patients with their lab results.\nThen, I will filter for records where `ALB` is less than 3.5.\nFinally, I will select the distinct `ID`, `SEX`, and `Diagnosis` from the `Patient` table.\n\n-- SQL Query\nSELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5;",
        "pred_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5;",
        "pred_time": 0.004583597183227539,
        "orig_time": 0.0039980411529541016,
        "time_ratio": 0.8722496749024707,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which foot is preferred by Abdou Diallo?",
        "original_query": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "llm_output": "-- Reasoning\nI need to find the 'player_name' 'Abdou Diallo' in the `Player` table.\nThen, I will join `Player` with `Player_Attributes` using `player_api_id` to retrieve the `preferred_foot` for that player.\n\n-- SQL Query\nSELECT T2.preferred_foot FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Abdou Diallo' LIMIT 1;",
        "pred_query": "SELECT T2.preferred_foot FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Abdou Diallo' LIMIT 1;",
        "pred_time": 0.001806020736694336,
        "orig_time": 0.09581375122070312,
        "time_ratio": 53.05240924092409,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "original_query": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "llm_output": "-- Reasoning\nI need to count the number of 'discount' gas stations in the Czech Republic.\nThen, I need to count the number of 'discount' gas stations in Slovakia.\nFinally, I will subtract the count from Slovakia from the count from the Czech Republic.\nAll the required information is in the `gasstations` table.\n\n-- SQL Query\nSELECT\n  SUM(CASE WHEN Country = 'CZE' THEN 1 ELSE 0 END) - SUM(CASE WHEN Country = 'SVK' THEN 1 ELSE 0 END)\nFROM gasstations\nWHERE\n  Segment = 'discount';",
        "pred_query": "SELECT\n  SUM(CASE WHEN Country = 'CZE' THEN 1 ELSE 0 END) - SUM(CASE WHEN Country = 'SVK' THEN 1 ELSE 0 END)\nFROM gasstations\nWHERE\n  Segment = 'discount';",
        "pred_time": 0.011461496353149414,
        "orig_time": 0.0010368824005126953,
        "time_ratio": 0.09046658207309717,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "original_query": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "\nSELECT T2.nationality FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 933 ORDER BY T1.fastestLapSpeed DESC LIMIT 1\n",
        "pred_query": "SELECT T2.nationality FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 933 ORDER BY T1.fastestLapSpeed DESC LIMIT 1",
        "pred_time": 0.02346062660217285,
        "orig_time": 0.002086162567138672,
        "time_ratio": 0.08892186055019766,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "llm_output": "-- Reasoning\nI need to retrieve superhero names from the 'superhero' table.\nTo filter by eye color and hair color, I will join the 'superhero' table with the 'colour' table twice, once for 'eye_colour_id' and once for 'hair_colour_id'.\nI will then filter the results where the eye color is 'Blue' and the hair color is 'Blond'.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_time": 0.0011718273162841797,
        "orig_time": 0.0009005069732666016,
        "time_ratio": 0.7684638860630723,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What is the highest amount of budget spend for an event?",
        "original_query": "SELECT MAX(spent) FROM budget",
        "llm_output": "SELECT MAX(spent) FROM budget;",
        "pred_query": "SELECT MAX(spent) FROM budget;",
        "pred_time": 0.0006806850433349609,
        "orig_time": 0.0003962516784667969,
        "time_ratio": 0.5821366024518388,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the owner's display name of the most popular post?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "llm_output": "-- Reasoning\nTo find the owner's display name of the most popular post, I need to identify the post with the highest popularity, which is typically indicated by the 'ViewCount' column in the 'posts' table.\nThen, I will join the 'posts' table with the 'users' table on 'OwnerUserId' to retrieve the 'DisplayName' of the owner.\nFinally, I will order by 'ViewCount' in descending order and limit the result to 1.\n\n-- SQL Query\nSELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.ViewCount DESC LIMIT 1;",
        "pred_query": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.ViewCount DESC LIMIT 1;",
        "pred_time": 0.19739699363708496,
        "orig_time": 0.10897994041442871,
        "time_ratio": 0.5520851073081118,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "original_query": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to first find the IDs of patients who had lab work done within the specified date range from the `Laboratory` table.\nThen, I will join these patient IDs with the `Patient` table to retrieve their diagnoses.\nFinally, I will count the occurrences of each diagnosis and select the one with the highest count.\n\n-- SQL Query\nSELECT T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.Date BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY\n  T1.Diagnosis\nORDER BY\n  COUNT(T1.Diagnosis) DESC\nLIMIT 1;",
        "pred_query": "SELECT T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.Date BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY\n  T1.Diagnosis\nORDER BY\n  COUNT(T1.Diagnosis) DESC\nLIMIT 1;",
        "pred_time": 0.004158973693847656,
        "orig_time": 0.0006690025329589844,
        "time_ratio": 0.16085760146755332,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "original_query": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find posts created in 2010 and then determine which one has the highest `FavoriteCount`.\nI will filter the `posts` table by `CreaionDate` for the year 2010.\nThen, I will order the results by `FavoriteCount` in descending order and take the top one.\nFinally, I will join with the `users` table to get the `DisplayName` of the owner for that post.\n\n-- SQL Query\nSELECT T1.Id, T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.CreaionDate LIKE '2010%' ORDER BY T1.FavoriteCount DESC LIMIT 1;",
        "pred_query": "SELECT T1.Id, T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.CreaionDate LIKE '2010%' ORDER BY T1.FavoriteCount DESC LIMIT 1;",
        "pred_time": 0.10342192649841309,
        "orig_time": 0.2172093391418457,
        "time_ratio": 2.100225227821284,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "llm_output": "-- Reasoning\nI need to find the `setCode` for the set \"Hauptset Zehnte Edition\" from the `set_translations` table.\nThen, I will use this `setCode` to filter the `cards` table and retrieve the `name` of the cards belonging to that set.\nA join between `cards` and `set_translations` on `setCode` is necessary, with a filter on the `translation` column.\n\n-- SQL Query\nSELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition';",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition';",
        "pred_time": 0.0921182632446289,
        "orig_time": 0.09096813201904297,
        "time_ratio": 0.9875146232128622,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What is the carcinogenic label for bond TR001_2_4?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
        "llm_output": "-- Reasoning\nThe question asks for the carcinogenic label of a specific bond.\nThe `bond` table contains `bond_id` and `molecule_id`.\nThe `molecule` table contains `molecule_id` and the `label` (carcinogenic label).\nWe need to join `bond` and `molecule` tables on `molecule_id` and filter by the given `bond_id` to find its corresponding label.\n\n-- SQL Query\nSELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_query": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_time": 0.0012755393981933594,
        "orig_time": 0.0013976097106933594,
        "time_ratio": 1.0957009345794393,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "original_query": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "llm_output": "SELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.`date`, 1, 10) = '2015-09-10';",
        "pred_query": "SELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.`date`, 1, 10) = '2015-09-10';",
        "pred_time": 0.002019643783569336,
        "orig_time": 0.0015745162963867188,
        "time_ratio": 0.779600991618463,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many positive comments are there on the list?",
        "original_query": "SELECT COUNT(id) FROM comments WHERE score > 60",
        "llm_output": "-- Reasoning\nTo find the number of positive comments, I need to query the `comments` table.\nThe `Score` column in the `comments` table indicates the score of a comment.\nA positive comment is defined as a comment with a `Score` greater than 0.\nTherefore, I will count the rows where `Score > 0`.\n\n-- SQL Query\nSELECT COUNT(Id) FROM comments WHERE Score > 0;",
        "pred_query": "SELECT COUNT(Id) FROM comments WHERE Score > 0;",
        "pred_time": 0.6454706192016602,
        "orig_time": 0.0463712215423584,
        "time_ratio": 0.07184094854652237,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 10?",
        "original_query": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 10 AND T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nTo find sets with an Italian translation, I will join `sets` with `set_translations` on `setCode`.\nThen, I will filter the results for `language = 'Italian'` and `baseSetSize < 10`.\nFinally, I will count the distinct set codes that meet these criteria.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_query": "SELECT COUNT(DISTINCT T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_time": 0.004269838333129883,
        "orig_time": 0.004172801971435547,
        "time_ratio": 0.9772739963147021,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were adult?",
        "original_query": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "llm_output": "-- Reasoning\nTo find the number of adult users, I need to count the users from the 'users' table.\nI will filter the users based on their 'Age' column.\nAssuming \"adult\" implies an age of 19 or more, based on the provided examples.\n\n-- SQL Query\nSELECT COUNT(Id) FROM users WHERE Age >= 19;",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Age >= 19;",
        "pred_time": 0.010736703872680664,
        "orig_time": 0.00906991958618164,
        "time_ratio": 0.8447582883663092,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "original_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "llm_output": "\nSELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1\n",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "pred_time": 0.07635068893432617,
        "orig_time": 0.07223749160766602,
        "time_ratio": 0.9461275676215815,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "original_query": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "llm_output": "SELECT AdmFName1, District FROM schools WHERE AdmFName1 IS NOT NULL GROUP BY AdmFName1, District ORDER BY COUNT(AdmFName1) DESC LIMIT 2;",
        "pred_query": "SELECT AdmFName1, District FROM schools WHERE AdmFName1 IS NOT NULL GROUP BY AdmFName1, District ORDER BY COUNT(AdmFName1) DESC LIMIT 2;",
        "pred_time": 0.01667928695678711,
        "orig_time": 0.02924060821533203,
        "time_ratio": 1.7531090082621001,
        "check": false
    },
    {
        "id": "financial",
        "question": "List the top ten districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "original_query": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 10",
        "llm_output": "-- Reasoning\nTo find the top ten districts with the highest number of female account holders, we need to first identify female clients. Then, we join the `client` table with the `disp` table to ensure that these clients actually hold an account. We group the results by `district_id` and count the distinct female clients for each district. Finally, we order the districts by this count in descending order and limit the output to the top 10.\n\n-- SQL Query\n\nSELECT\n  T1.district_id,\n  COUNT(DISTINCT T1.client_id) AS female_account_holders\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nWHERE\n  T1.gender = 'F'\nGROUP BY\n  T1.district_id\nORDER BY\n  female_account_holders DESC\nLIMIT 10;\n",
        "pred_query": "SELECT\n  T1.district_id,\n  COUNT(DISTINCT T1.client_id) AS female_account_holders\nFROM client AS T1\nINNER JOIN disp AS T2\n  ON T1.client_id = T2.client_id\nWHERE\n  T1.gender = 'F'\nGROUP BY\n  T1.district_id\nORDER BY\n  female_account_holders DESC\nLIMIT 10;",
        "pred_time": 0.0019228458404541016,
        "orig_time": 0.0016090869903564453,
        "time_ratio": 0.8368257904525729,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01'",
        "llm_output": "-- Reasoning\nI need to count distinct patients.\nPatients must have an IgA level between 80 and 500 (normal range based on example).\nPatients must have a `First Date` after '1990-01-01'.\nI will join the Patient and Laboratory tables on ID, filter by the IgA range and `First Date`, and then count the distinct IDs.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01';",
        "pred_time": 0.004074573516845703,
        "orig_time": 0.004254341125488281,
        "time_ratio": 1.0441193680514922,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "original_query": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "llm_output": "-- Reasoning\nThe question asks for the number of races in 2010 held outside Asia and Europe.\nThe `races` table contains the `year` and `circuitId`.\nThe `circuits` table contains the `country` where the circuit is located.\nTo answer the question, I need to join `races` and `circuits` on `circuitId`.\nThen, I will filter for races in `year = 2010`.\nFinally, I will filter the `circuits.country` to include only those countries that are outside Asia and Europe. Assuming common F1 race locations, these include countries in North America, South America, and Oceania (e.g., Australia, Brazil, Canada, Mexico, United States).\n\n-- SQL Query\nSELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.country IN ('Australia', 'Brazil', 'Canada', 'Mexico', 'United States');",
        "pred_query": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.country IN ('Australia', 'Brazil', 'Canada', 'Mexico', 'United States');",
        "pred_time": 0.0012750625610351562,
        "orig_time": 0.0007288455963134766,
        "time_ratio": 0.5716155572176514,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "original_query": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "llm_output": "\nSELECT T2.forename, T2.surname FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.milliseconds DESC LIMIT 10\n",
        "pred_query": "SELECT T2.forename, T2.surname FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.milliseconds DESC LIMIT 10",
        "pred_time": 0.40793490409851074,
        "orig_time": 0.007302522659301758,
        "time_ratio": 0.017901195965173644,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "llm_output": "-- Reasoning\nI need to retrieve the 'text' from the 'rulings' table.\nThe 'rulings' table is linked to the 'cards' table via the 'uuid' column.\nI will join 'cards' and 'rulings' on 'uuid' and filter by card name 'Condemn'.\n\n-- SQL Query\nSELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "pred_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "pred_time": 0.6387271881103516,
        "orig_time": 0.21608614921569824,
        "time_ratio": 0.33830742332259306,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Which customer paid the most in 2012/8/25?",
        "original_query": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the customer who has the maximum total `Price` on the specified `Date`.\nI will filter the `transactions_1k` table by the `Date` '2012-08-25'.\nThen, I will group the results by `CustomerID` and sum their `Price`.\nFinally, I will order by the total `Price` in descending order and take the top one.\n\n-- SQL Query\nSELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1;",
        "pred_query": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1;",
        "pred_time": 0.002881765365600586,
        "orig_time": 0.0007765293121337891,
        "time_ratio": 0.26946305948539756,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with severe thrombosis have a normal prothrombin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.PT < 14 AND T3.Thrombosis < 3 AND T3.Thrombosis > 0",
        "llm_output": "-- Reasoning\nTo find patients with severe thrombosis, we need to filter the `Examination` table where `Thrombosis` = 1 (based on few-shot examples).\nTo find patients with a normal prothrombin time, we need to filter the `Laboratory` table where `PT` < 14 (based on few-shot examples).\nWe need to join the `Examination` and `Laboratory` tables on their common `ID` column to link patient examinations with laboratory results.\nFinally, we count the distinct `ID`s to get the number of unique patients satisfying both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Thrombosis = 1 AND T2.PT < 14;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Thrombosis = 1 AND T2.PT < 14;",
        "pred_time": 0.0015077590942382812,
        "orig_time": 0.0007717609405517578,
        "time_ratio": 0.5118595825426945,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "original_query": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "llm_output": "-- Reasoning\nTo find the last names of students who majored in 'Law and Constitutional Studies', I need to join the 'member' table with the 'major' table.\nThe join condition will be `member.link_to_major = major.major_id`.\nThen, I will filter the results where `major.major_name` is 'Law and Constitutional Studies'.\nFinally, I will select the `last_name` from the 'member' table.\n\nSELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';",
        "pred_query": "select the `last_name` from the 'member' table.\n\nSELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';",
        "pred_time": null,
        "orig_time": 0.0007159709930419922,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "financial",
        "question": "What is the average loan amount by male borrowers?",
        "original_query": "SELECT AVG(T3.amount) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M'",
        "llm_output": "-- Reasoning\nTo find the average loan amount for male borrowers, I need to link the `loan` table to the `client` table.\nI will join `loan` with `account` on `account_id`, then `account` with `disp` on `account_id`, and finally `disp` with `client` on `client_id`.\nAfter joining, I will filter for `client.gender = 'M'` and calculate the average of `loan.amount`.\n\n-- SQL Query\nSELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M';",
        "pred_query": "SELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T3.account_id = T2.account_id INNER JOIN client AS T4 ON T4.client_id = T3.client_id WHERE T4.gender = 'M';",
        "pred_time": 0.009426355361938477,
        "orig_time": 0.0052242279052734375,
        "time_ratio": 0.55421503907732,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "List out of players whose preferred foot is left.",
        "original_query": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "llm_output": "-- Reasoning\nI need to find players whose preferred foot is 'left'.\nThe `preferred_foot` attribute is in the `Player_Attributes` table.\nThe player name is in the `Player` table.\nI will join `Player` and `Player_Attributes` tables on `player_api_id`.\nThen I will filter by `preferred_foot` = 'left' and select the `player_name`.\n\n-- SQL Query\nSELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot = 'left'",
        "pred_query": "SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot = 'left'",
        "pred_time": 0.10266542434692383,
        "orig_time": 0.0926980972290039,
        "time_ratio": 0.9029144701702236,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many white bordered cards are powerful?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "llm_output": "-- Reasoning\nThe question asks for the count of cards that have a white border and are considered \"powerful\".\n\"White bordered\" directly maps to the `borderColor` column with a value of 'white'.\n\"Powerful\" implies that the `power` attribute of the card is a positive numerical value.\nSince the `power` column is of type TEXT, we need to convert it to an integer for comparison. SQLite's `CAST` function converts non-numeric text to 0 when casting to INTEGER. Therefore, `CAST(power AS INTEGER) > 0` will correctly identify cards with a positive numerical power, while excluding non-numeric values (like '*', 'X') and zero power.\n\n-- SQL Query\nSELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND CAST(power AS INTEGER) > 0;",
        "pred_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND CAST(power AS INTEGER) > 0;",
        "pred_time": 0.06205248832702637,
        "orig_time": 0.05425453186035156,
        "time_ratio": 0.8743328966023353,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
        "original_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
        "llm_output": "-- Reasoning\nTo find the students, I need to join the `member` table with the `zip_code` table using the `zip` and `zip_code` columns, respectively.\nThen, I will filter the results by `city`, `state`, and `zip_code` as specified in the question.\nFinally, I will select the `first_name`, `last_name`, and `position` of the matching members.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092;",
        "pred_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092;",
        "pred_time": 0.0010726451873779297,
        "orig_time": 0.0007038116455078125,
        "time_ratio": 0.65614581018004,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Give the eye colour of Blackwulf.",
        "original_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf'",
        "llm_output": "-- Reasoning\nTo find the eye colour of 'Blackwulf', I need to join the `superhero` table with the `colour` table.\nThe join condition will be `superhero.eye_colour_id = colour.id`.\nFinally, I will filter by `superhero.superhero_name = 'Blackwulf'` and select the `colour` name.\n\n-- SQL Query\nSELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_time": 0.0007271766662597656,
        "orig_time": 0.0004558563232421875,
        "time_ratio": 0.6268852459016393,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal anti-SSA came to the hospital before 1990?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '1990'",
        "llm_output": "-- Reasoning\nI need to count distinct patients.\nPatients are identified by their `ID` in the `Patient` table.\nThe condition \"normal anti-SSA\" requires checking the `SSA` column in the `Laboratory` table for 'negative' or '0'.\nThe condition \"came to the hospital before 1990\" requires checking the `First Date` column in the `Patient` table.\nI will join `Patient` and `Laboratory` tables on `ID`.\n\n\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND T1.`First Date` < '1990-01-01';\n",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND T1.`First Date` < '1990-01-01';",
        "pred_time": 0.0020902156829833984,
        "orig_time": 0.0037229061126708984,
        "time_ratio": 1.7811109843732178,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "State the racing year which has the fastest lap time?",
        "original_query": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "llm_output": "-- Reasoning\nTo find the racing year with the fastest lap time, I need to look at the `lapTimes` table.\nThe `lapTimes` table contains `milliseconds` for each lap. I should find the minimum `milliseconds` from this table.\nThen, I need to join `lapTimes` with `races` table on `raceId` to get the `year` corresponding to that fastest lap.\n\n-- SQL Query\nSELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId ORDER BY T1.milliseconds ASC LIMIT 1;",
        "pred_query": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId ORDER BY T1.milliseconds ASC LIMIT 1;",
        "pred_time": 0.039476633071899414,
        "orig_time": 0.005780458450317383,
        "time_ratio": 0.1464273419617459,
        "check": false
    },
    {
        "id": "superhero",
        "question": "How many green-skinned villains are there in the superhero universe?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "llm_output": "-- Reasoning\nTo find green-skinned villains, I need to join the `superhero` table with the `colour` table for skin color and the `alignment` table for alignment.\nI will filter for 'Green' skin colour and 'Bad' alignment, then count the distinct superheroes.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_time": 0.0011229515075683594,
        "orig_time": 0.0006000995635986328,
        "time_ratio": 0.5343949044585987,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "original_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to query the `Player_Attributes` table to find player ratings.\nTo get the player with the highest overall rating, I will sort the results by `overall_rating` in descending order.\nThen I will limit the result to 1 to get only the top player.\nFinally, I will select the `player_api_id` for this player.\n\n-- SQL Query\nSELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "pred_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "pred_time": 0.06908226013183594,
        "orig_time": 0.06599020957946777,
        "time_ratio": 0.9552410337115879,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "original_query": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "llm_output": "-- Reasoning\nThe query needs to retrieve event names.\nIt requires joining the `event` and `budget` tables on `event_id` and `link_to_event` to access both event details and budget status/category.\nFilter conditions include `event_status` being 'Closed', `category` being 'game', and the `event_date` (extracted as YYYY-MM-DD) falling between '2019-03-15' and '2020-03-20'.\n\n-- SQL Query\nSELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.event_status = 'Closed' AND T2.category = 'game' AND SUBSTR(T1.event_date, 1, 10) BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_query": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.event_status = 'Closed' AND T2.category = 'game' AND SUBSTR(T1.event_date, 1, 10) BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_time": 0.0009806156158447266,
        "orig_time": 0.0005700588226318359,
        "time_ratio": 0.5813274981765135,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List down top 5 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "original_query": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 5",
        "llm_output": "-- Reasoning\nI need to join the `drivers` table with the `pitStops` table.\nFilter `drivers` by `nationality = 'German'` and birth year between 1980 and 1985.\nCalculate the average `milliseconds` from `pitStops` for each qualifying driver.\nOrder the results by this average in ascending order and take the top 5.\nDisplay the driver's forename and surname.\n\nSELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds) ASC\nLIMIT 5;",
        "pred_query": "SELECT\n  T1.forename,\n  T1.surname\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds) ASC\nLIMIT 5;",
        "pred_time": 0.002623319625854492,
        "orig_time": 0.002747774124145508,
        "time_ratio": 1.0474416068344996,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "original_query": "SELECT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "llm_output": "\nSELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'\n",
        "pred_query": "SELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "pred_time": 0.0018031597137451172,
        "orig_time": 0.0014801025390625,
        "time_ratio": 0.8208382916831946,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Count the fastest superheroes.",
        "original_query": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' ORDER BY T1.attribute_value DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the fastest superheroes, we first need to identify the maximum 'Speed' attribute value from the `hero_attribute` table.\nThen, we count all superheroes from `hero_attribute` whose 'Speed' attribute value matches this maximum value.\nThis involves joining `hero_attribute` with `attribute` to filter by 'Speed' and using a subquery to find the maximum speed.\n\n-- SQL Query\nSELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Speed' AND T1.attribute_value = (SELECT MAX(T3.attribute_value) FROM hero_attribute AS T3 INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed');",
        "pred_query": "SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Speed' AND T1.attribute_value = (SELECT MAX(T3.attribute_value) FROM hero_attribute AS T3 INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed');",
        "pred_time": 0.0027616024017333984,
        "orig_time": 0.000942230224609375,
        "time_ratio": 0.34118967452300786,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "original_query": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "llm_output": "-- Reasoning\nThe query needs to list the `frameVersion` and `name` for all cards where the `artist` is 'Allen Williams'.\nAdditionally, it must identify if any of these cards are banned.\nA `LEFT JOIN` with the `legalities` table is used to include all cards by 'Allen Williams', regardless of their legality status.\nThe `ON` clause for the `LEFT JOIN` is crucial: `T1.uuid = T2.uuid AND T2.status = 'Banned'` ensures that only 'Banned' legalities are joined. If a card is not banned, or its legality status is not 'Banned', the `T2.format` and `T2.status` columns will be `NULL` for that row, correctly indicating it's not banned.\n\n-- SQL Query\nSELECT\n  T1.frameVersion,\n  T1.name,\n  T2.format,\n  T2.status\nFROM cards AS T1\nLEFT JOIN legalities AS T2\n  ON T1.uuid = T2.uuid AND T2.status = 'Banned'\nWHERE\n  T1.artist = 'Allen Williams';",
        "pred_query": "SELECT\n  T1.frameVersion,\n  T1.name,\n  T2.format,\n  T2.status\nFROM cards AS T1\nLEFT JOIN legalities AS T2\n  ON T1.uuid = T2.uuid AND T2.status = 'Banned'\nWHERE\n  T1.artist = 'Allen Williams';",
        "pred_time": 0.09755945205688477,
        "orig_time": 0.3117482662200928,
        "time_ratio": 3.1954696305419925,
        "check": false
    },
    {
        "id": "student_club",
        "question": "State the name of major that Phillip Cullen has joined.",
        "original_query": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "llm_output": "-- Reasoning\nI need to find the major name for a specific member.\nThe member's first name is 'Phillip' and last name is 'Cullen'.\nThe `member` table contains `first_name`, `last_name`, and `link_to_major`.\nThe `major` table contains `major_id` and `major_name`.\nI will join `member` and `major` tables on `member.link_to_major = major.major_id` and filter by the member's name.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_time": 0.0009946823120117188,
        "orig_time": 0.0004801750183105469,
        "time_ratio": 0.4827420901246405,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
        "original_query": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
        "llm_output": "-- Reasoning\nTo answer this question, I need to first find the `district_id` associated with `account_id = 532` from the `account` table.\nThen, I will use this `district_id` to query the `district` table and retrieve the value of `A15`, which represents the number of crimes committed in 1995.\n\n-- SQL Query\nSELECT T1.A15 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532;",
        "pred_query": "SELECT T1.A15 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532;",
        "pred_time": 0.0009694099426269531,
        "orig_time": 0.00047206878662109375,
        "time_ratio": 0.4869650762420069,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "llm_output": "-- Reasoning\n1. The request involves patient demographics (ID, sex, birthday) and laboratory results (LDH), necessitating a join between the `Patient` and `Laboratory` tables on the `ID` column.\n2. The condition \"LDH beyond normal range\" requires filtering `LDH` values. As specific normal range values are not provided in the schema or question, a commonly accepted adult normal range for LDH (approximately 140-280 U/L) is assumed.\n3. Therefore, patients with `LDH` values less than 140 or greater than 280 are considered to be \"beyond normal range\".\n4. `DISTINCT` is applied to the selected columns to ensure each patient's information appears only once, as a patient may have multiple laboratory entries.\n\n-- SQL Query\nSELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH < 140 OR T2.LDH > 280;",
        "pred_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH < 140 OR T2.LDH > 280;",
        "pred_time": 0.0060045719146728516,
        "orig_time": 0.003792285919189453,
        "time_ratio": 0.6315664085765337,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "original_query": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "llm_output": "-- Reasoning\nThe user is asking for `bond_id`s.\nThe condition is based on `atom_id2`.\nThe `connected` table contains both `bond_id` and `atom_id2`.\nTherefore, I need to select `bond_id` from the `connected` table and filter by `atom_id2` = 'TR000_2'.\n\n-- SQL Query\nSELECT T1.bond_id FROM connected AS T1 WHERE T1.atom_id2 = 'TR000_2';",
        "pred_query": "SELECT T1.bond_id FROM connected AS T1 WHERE T1.atom_id2 = 'TR000_2';",
        "pred_time": 0.0036444664001464844,
        "orig_time": 0.0025267601013183594,
        "time_ratio": 0.6933141436608662,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "original_query": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "llm_output": "-- Reasoning\nTo find the 'Percent (%) Eligible Free (K-12)' and 'District Code', we need to query the `frpm` table.\nTo filter by the administrator's first name, we need to join `frpm` with the `schools` table on `CDSCode`.\nThen, we will filter the `schools` table for `AdmFName1`, `AdmFName2`, or `AdmFName3` being 'Alusine'.\n\n-- SQL Query\nSELECT\n  T1.`Percent (%) Eligible Free (K-12)`,\n  T1.`District Code`\nFROM frpm AS T1\nINNER JOIN schools AS T2\n  ON T1.CDSCode = T2.CDSCode\nWHERE\n  T2.AdmFName1 = 'Alusine' OR T2.AdmFName2 = 'Alusine' OR T2.AdmFName3 = 'Alusine';",
        "pred_query": "SELECT\n  T1.`Percent (%) Eligible Free (K-12)`,\n  T1.`District Code`\nFROM frpm AS T1\nINNER JOIN schools AS T2\n  ON T1.CDSCode = T2.CDSCode\nWHERE\n  T2.AdmFName1 = 'Alusine' OR T2.AdmFName2 = 'Alusine' OR T2.AdmFName3 = 'Alusine';",
        "pred_time": 0.06732773780822754,
        "orig_time": 0.009060144424438477,
        "time_ratio": 0.1345677831957591,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "original_query": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "llm_output": "-- Reasoning\nI need to find races associated with the 'Silverstone Circuit'.\nFirst, I will find the `circuitId` for 'Silverstone Circuit' from the `circuits` table.\nThen, I will join the `circuits` table with the `races` table using `circuitId` to filter for races at Silverstone.\nFinally, I will select all relevant columns from the `races` table to provide \"more information\".\n\nSELECT T2.raceId, T2.year, T2.round, T2.name, T2.date, T2.time, T2.url FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Silverstone Circuit';",
        "pred_query": "select all relevant columns from the `races` table to provide \"more information\".\n\nSELECT T2.raceId, T2.year, T2.round, T2.name, T2.date, T2.time, T2.url FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Silverstone Circuit';",
        "pred_time": null,
        "orig_time": 0.0008871555328369141,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Give the only one comment text of the post with parent id 107829.",
        "original_query": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "llm_output": "-- Reasoning\nI need to find the `Text` from the `comments` table.\nThe comments are linked to posts by `PostId`.\nThe posts must have a `ParentId` of `107829`.\nSo, I will join `comments` and `posts` on `comments.PostId = posts.Id` and filter for `posts.ParentId = 107829`.\n\n-- SQL Query\nSELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ParentId = 107829;",
        "pred_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ParentId = 107829;",
        "pred_time": 0.19859099388122559,
        "orig_time": 0.19666790962219238,
        "time_ratio": 0.9903163571446579,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
        "original_query": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
        "llm_output": "-- Reasoning\nTo find the Italian name of the set, I need to first identify the `setCode` for the card \"Ancestor's Chosen\" from the `cards` table.\nThen, I will join the `cards` table with the `sets` table using the `setCode`.\nFinally, I will join with the `set_translations` table on `setCode` and filter for `language = 'Italian'` to get the translated name.\n\n-- SQL Query\nSELECT T3.translation FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code INNER JOIN set_translations AS T3 ON T2.code = T3.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T3.language = 'Italian';",
        "pred_query": "SELECT T3.translation FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code INNER JOIN set_translations AS T3 ON T2.code = T3.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T3.language = 'Italian';",
        "pred_time": 0.06566309928894043,
        "orig_time": 0.05854296684265137,
        "time_ratio": 0.8915656963592594,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many translations of the name of the set \"Salvat 2011\"?",
        "original_query": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Salvat 2011' AND T2.translation IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to find the set code for \"Salvat 2011\" from the `sets` table.\nThen, I will use this set code to query the `set_translations` table.\nFinally, I will count the number of distinct translations for that set code.\n\nSELECT COUNT(T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.name = 'Salvat 2011';",
        "pred_query": "SELECT COUNT(T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.name = 'Salvat 2011';",
        "pred_time": 0.011012077331542969,
        "orig_time": 0.004474163055419922,
        "time_ratio": 0.40629600762102713,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "original_query": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
        "llm_output": "-- Reasoning\nI need to join the `member` table with the `attendance` table and the `event` table.\nI will filter the results based on the `event_name` being 'Women''s Soccer' from the `event` table.\nAdditionally, I will filter for `t_shirt_size` being 'Medium' from the `member` table.\nFinally, I will count the distinct `member_id`s that satisfy both conditions.\n\n-- SQL Query\nSELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';",
        "pred_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';",
        "pred_time": 0.0011665821075439453,
        "orig_time": 0.0006167888641357422,
        "time_ratio": 0.5287144900878806,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "original_query": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "llm_output": "-- Reasoning\nThe query needs to calculate the average of the 'A15' column (crimes in 1995) from the 'district' table.\nThe conditions for including a district in this average are:\n1. The value of 'A15' for that district must be greater than 4000.\n2. The district must have at least one account opened in or after the year 1997.\nTo fulfill the second condition, a subquery or a join can be used to check for 'account' entries with a 'date' in 1997 or later for each district. An `IN` clause with a subquery selecting distinct `district_id`s from the `account` table, filtered by the date condition, is an effective way to implement this.\n\n-- SQL Query\nSELECT AVG(T1.A15) FROM district AS T1 WHERE T1.A15 > 4000 AND T1.district_id IN (SELECT T2.district_id FROM account AS T2 WHERE STRFTIME('%Y', T2.date) >= '1997');",
        "pred_query": "SELECT AVG(T1.A15) FROM district AS T1 WHERE T1.A15 > 4000 AND T1.district_id IN (SELECT T2.district_id FROM account AS T2 WHERE STRFTIME('%Y', T2.date) >= '1997');",
        "pred_time": 0.002461671829223633,
        "orig_time": 0.0018520355224609375,
        "time_ratio": 0.7523486682808717,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "original_query": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "llm_output": "-- Reasoning\nTo find the top five schools by enrollment, I need to access the `frpm` table for enrollment data and the `schools` table for the school name and NCES identification number.\nI will join these two tables on their common `CDSCode` column.\nThen, I will order the results by `Enrollment (Ages 5-17)` in descending order and select the top 5.\n\n-- SQL Query\nSELECT T2.School, T2.NCESSchool FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_query": "SELECT T2.School, T2.NCESSchool FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_time": 0.00901484489440918,
        "orig_time": 0.025659799575805664,
        "time_ratio": 2.8463939065351354,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level?",
        "original_query": "SELECT T2.ANA FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 ORDER BY T2.ANA DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo answer this question, we need to join the `Examination` and `Laboratory` tables using the common `ID` column.\nWe will filter for patients with a normal creatinine level, which is defined as `CRE < 1.5` based on the few-shot examples.\nFinally, we will find the maximum `ANA` (anti-nucleus antibody concentration) from the filtered results.\n\n-- SQL Query\nSELECT MAX(T1.ANA) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE < 1.5;",
        "pred_query": "SELECT MAX(T1.ANA) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE < 1.5;",
        "pred_time": 0.0021982192993164062,
        "orig_time": 0.001226186752319336,
        "time_ratio": 0.5578091106290672,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many male patients have elevated total bilirubin count?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "llm_output": "-- Reasoning\nI need to join the Patient and Laboratory tables using the common `ID` column.\nThen, I will filter for male patients (SEX = 'M') and those with an elevated total bilirubin count (`T-BIL` >= 2.0, based on previous examples where 2.0 was used as the upper normal limit).\nFinally, I will count the distinct IDs to get the number of such patients.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` >= 2.0;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` >= 2.0;",
        "pred_time": 0.002485990524291992,
        "orig_time": 0.0015492439270019531,
        "time_ratio": 0.6231897957226431,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "original_query": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "llm_output": "-- Reasoning\nThe question asks to count players who meet two conditions: their preferred foot is 'left' and they \"would remain in his position when the team attacked\".\nThe 'preferred_foot' attribute is directly available in the `Player_Attributes` table.\nThe phrase \"remain in his position when the team attacked\" is best interpreted by the `attacking_work_rate` attribute in the `Player_Attributes` table. A 'Low' attacking work rate suggests that a player tends to stay in their designated position rather than constantly moving forward to join the attack.\nTherefore, we need to filter `Player_Attributes` for `preferred_foot = 'left'` and `attacking_work_rate = 'Low'`, and then count the distinct players.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.player_api_id) FROM Player_Attributes AS T1 WHERE T1.preferred_foot = 'left' AND T1.attacking_work_rate = 'Low';",
        "pred_query": "SELECT COUNT(DISTINCT T1.player_api_id) FROM Player_Attributes AS T1 WHERE T1.preferred_foot = 'left' AND T1.attacking_work_rate = 'Low';",
        "pred_time": 0.06441974639892578,
        "orig_time": 0.06131887435913086,
        "time_ratio": 0.9518645723844913,
        "check": false
    },
    {
        "id": "card_games",
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "original_query": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "llm_output": "ite\nSELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy'\n",
        "pred_query": "SELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy'",
        "pred_time": 0.06842541694641113,
        "orig_time": 0.05814814567565918,
        "time_ratio": 0.8498033080485162,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which SME customer consumed the least in June 2012?",
        "original_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the SME customer with the least consumption in June 2012, I need to join the `customers` and `yearmonth` tables.\nI will filter for `Segment = 'SME'` in the `customers` table and `Date = '201206'` in the `yearmonth` table.\nThen, I will order the results by `Consumption` in ascending order and select the `CustomerID` of the top entry.\n\n-- SQL Query\nSELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date = '201206' ORDER BY T2.Consumption ASC LIMIT 1;",
        "pred_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date = '201206' ORDER BY T2.Consumption ASC LIMIT 1;",
        "pred_time": 0.2960042953491211,
        "orig_time": 0.020433902740478516,
        "time_ratio": 0.06903245345266977,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the region of the client with the id 3541 from?",
        "original_query": "SELECT T2.district_id, T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
        "llm_output": "-- Reasoning\nTo find the region of a client, we first need to locate the client in the `client` table using their `client_id`.\nThe `client` table contains a `district_id`, which links to the `district` table.\nThe `district` table contains geographical information, and the `A3` column typically represents the region/city.\nTherefore, we join `client` and `district` tables on `district_id` and filter by `client_id`.\n\n-- SQL Query\nSELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541;",
        "pred_query": "SELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541;",
        "pred_time": 0.0010380744934082031,
        "orig_time": 0.0004878044128417969,
        "time_ratio": 0.46991272393201655,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the score and the link type ID for post ID 395?",
        "original_query": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395",
        "llm_output": "-- Reasoning\nTo get the score, we need to query the 'posts' table and filter by the given PostId.\nTo get the link type ID, we need to query the 'postLinks' table and filter by the given PostId.\nBoth pieces of information can be retrieved by joining the 'posts' and 'postLinks' tables on their respective PostId columns and then applying a WHERE clause for PostId 395.\n\n-- SQL Query\nSELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T1.Id = 395;",
        "pred_query": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T1.Id = 395;",
        "pred_time": 0.008918285369873047,
        "orig_time": 0.0013680458068847656,
        "time_ratio": 0.15339785061220126,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many French constructors have a lap number of over 50?",
        "original_query": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "llm_output": "-- Reasoning\nI need to find constructors with 'French' nationality.\nThen I need to link constructors to races and drivers through the `results` table.\nFinally, I need to link the races and drivers to `lapTimes` to check for laps over 50.\nI will count the distinct constructor IDs that satisfy these conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.constructorId) FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId INNER JOIN lapTimes AS T3 ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId WHERE T1.nationality = 'French' AND T3.lap > 50;",
        "pred_query": "SELECT COUNT(DISTINCT T1.constructorId) FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId INNER JOIN lapTimes AS T3 ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId WHERE T1.nationality = 'French' AND T3.lap > 50;",
        "pred_time": 0.06897497177124023,
        "orig_time": 0.004525661468505859,
        "time_ratio": 0.0656130963491438,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "original_query": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA > 6.5 AND T1.SEX = 'F') OR (T2.UA > 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "llm_output": "-- Reasoning\nThe question asks for the average uric acid (UA) index for patients with \"normal uric acid\" based on their latest laboratory examination result.\n1.  **Identify Latest Examination:** For each patient, we need to find their most recent `Laboratory` record. This can be achieved by joining `Patient` and `Laboratory` tables and filtering `Laboratory` records to only include those where the `Date` is the maximum `Date` for that specific `Patient.ID`.\n2.  **Define \"Normal Uric Acid\":** The provided few-shot examples give conflicting definitions for \"normal uric acid\".\n    *   Example 1 states `UA > 6.5` is \"beyond the normal range\" for females. This implies `UA <= 6.5` is considered within the normal range (or at least not high) for females.\n    *   Example 5's query for \"uric acid within a normal range\" includes `(T1.SEX = 'M' AND T2.UA < 8.0)`. This suggests `UA < 8.0` is considered within the normal range for males.\n    *   Example 3 states `UA <= 6.5` is \"below the normal range\" (general context). This directly conflicts with the interpretation from Example 1 if applied to females.\n    Given this inconsistency, I will prioritize the explicit definitions for sex-specific abnormal ranges (Ex1 for females) and infer from Ex5 for males to define \"normal\" as *not exceeding* typical upper bounds derived from the examples.\n    Therefore, for this query, \"normal uric acid\" is interpreted as:\n    *   For females (`SEX = 'F'`): `UA <= 6.5`\n    *   For males (`SEX = 'M'`): `UA < 8.0`\n3.  **Calculate Average:** Finally, calculate the `AVG(UA)` for the filtered patients.\n\n-- SQL Query\nSELECT\n  AVG(L.UA)\nFROM Patient AS P\nJOIN Laboratory AS L\n  ON P.ID = L.ID\nWHERE\n  L.Date = (\n    SELECT\n      MAX(Date)\n    FROM Laboratory\n    WHERE\n      ID = P.ID\n  ) AND (\n    (\n      P.SEX = 'F' AND L.UA <= 6.5\n    ) OR (\n      P.SEX = 'M' AND L.UA < 8.0\n    )\n  );",
        "pred_query": "SELECT\n  AVG(L.UA)\nFROM Patient AS P\nJOIN Laboratory AS L\n  ON P.ID = L.ID\nWHERE\n  L.Date = (\n    SELECT\n      MAX(Date)\n    FROM Laboratory\n    WHERE\n      ID = P.ID\n  ) AND (\n    (\n      P.SEX = 'F' AND L.UA <= 6.5\n    ) OR (\n      P.SEX = 'M' AND L.UA < 8.0\n    )\n  );",
        "pred_time": 0.007807016372680664,
        "orig_time": 0.0037043094635009766,
        "time_ratio": 0.4744846541456711,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "original_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "llm_output": "-- Reasoning\nI need to find the circuit name for a specific race.\nI will join the `races` table with the `circuits` table using `circuitId`.\nThen, I will filter the results for the race named 'Spanish Grand Prix' in the year 2009.\nFinally, I will select the `name` of the circuit.\n\n-- SQL Query\nSELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Spanish Grand Prix' AND T2.year = 2009;",
        "pred_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Spanish Grand Prix' AND T2.year = 2009;",
        "pred_time": 0.0013117790222167969,
        "orig_time": 0.0006766319274902344,
        "time_ratio": 0.5158124318429662,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the molecule id of bond id TR001_1_7?",
        "original_query": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "llm_output": "-- Reasoning\nThe question asks for the `molecule_id` given a `bond_id`.\nThe `bond` table contains both `bond_id` and `molecule_id`.\nI will query the `bond` table and filter by the given `bond_id` to retrieve the corresponding `molecule_id`.\n\n-- SQL Query\nSELECT T.molecule_id FROM bond AS T WHERE T.bond_id = 'TR001_1_7';",
        "pred_query": "SELECT T.molecule_id FROM bond AS T WHERE T.bond_id = 'TR001_1_7';",
        "pred_time": 0.0009984970092773438,
        "orig_time": 0.0027396678924560547,
        "time_ratio": 2.743791786055396,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "original_query": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "llm_output": "-- Reasoning\nI need to retrieve the overall ratings for 'Landon Donovan' and 'Jordan Bowery' from the Player_Attributes table, filtered by the date '2013-07-12'.\nThen, I will calculate the percentage difference using the formula: ((Donovan's rating - Bowery's rating) * 100.0 / Bowery's rating).\nI will use subqueries to get each player's rating and then perform the calculation.\n\n-- SQL Query\nSELECT CAST((SUM(CASE WHEN T1.player_name = 'Landon Donovan' THEN T2.overall_rating ELSE 0 END) - SUM(CASE WHEN T1.player_name = 'Jordan Bowery' THEN T2.overall_rating ELSE 0 END)) AS REAL) * 100.0 / SUM(CASE WHEN T1.player_name = 'Jordan Bowery' THEN T2.overall_rating ELSE 0 END) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name IN ('Landon Donovan', 'Jordan Bowery') AND T2.date = '2013-07-12';",
        "pred_query": "SELECT CAST((SUM(CASE WHEN T1.player_name = 'Landon Donovan' THEN T2.overall_rating ELSE 0 END) - SUM(CASE WHEN T1.player_name = 'Jordan Bowery' THEN T2.overall_rating ELSE 0 END)) AS REAL) * 100.0 / SUM(CASE WHEN T1.player_name = 'Jordan Bowery' THEN T2.overall_rating ELSE 0 END) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name IN ('Landon Donovan', 'Jordan Bowery') AND T2.date = '2013-07-12';",
        "pred_time": 0.06901359558105469,
        "orig_time": 0.06759953498840332,
        "time_ratio": 0.9795104054390184,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "original_query": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe query needs to find the patient with the highest hemoglobin count.\nIt will join the `Patient` and `Laboratory` tables on `ID`.\nThen it will order the results by `HGB` in descending order and pick the top one.\nFinally, it will calculate the age using `STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)` and select the `Diagnosis` from the `Patient` table.\n\n-- SQL Query\nSELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1;",
        "pred_query": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1;",
        "pred_time": 0.006968021392822266,
        "orig_time": 0.006519794464111328,
        "time_ratio": 0.9356737151851091,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "original_query": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "llm_output": "SELECT\n  T2.forename,\n  T2.surname,\n  T1.duration\nFROM pitStops AS T1\nINNER JOIN drivers AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T1.raceId = T3.raceId\nWHERE\n  T3.name = 'Australian Grand Prix' AND T3.year = 2011;",
        "pred_query": "SELECT\n  T2.forename,\n  T2.surname,\n  T1.duration\nFROM pitStops AS T1\nINNER JOIN drivers AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T1.raceId = T3.raceId\nWHERE\n  T3.name = 'Australian Grand Prix' AND T3.year = 2011;",
        "pred_time": 0.002514362335205078,
        "orig_time": 0.007686614990234375,
        "time_ratio": 3.057083254314432,
        "check": false
    },
    {
        "id": "financial",
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "original_query": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "llm_output": "-- Reasoning\nI need to find the number of accounts opened in 1993 from the 'Decin' district and divide it by the total number of accounts opened in 1993, then multiply by 100 to get the percentage.\nI will join `account` and `district` tables to filter by district name and year of account opening.\nI will use `STRFTIME('%Y', date)` to extract the year from the account opening date.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993';",
        "pred_query": "SELECT CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993';",
        "pred_time": 0.002579927444458008,
        "orig_time": 0.001913309097290039,
        "time_ratio": 0.7416135292486831,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Please list the product description of the products consumed in September, 2013.",
        "original_query": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "llm_output": "-- Reasoning\nI need to retrieve the product descriptions.\nThese descriptions are stored in the `products` table.\nThe question specifies products consumed in September 2013. Consumption information (including `ProductID` and `Date`) is in the `transactions_1k` table.\nI will filter `transactions_1k` for dates in September 2013, then join with the `products` table on `ProductID` to get the `Description`. I'll ensure distinct descriptions are returned.\n\n-- SQL Query\nSELECT DISTINCT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Date LIKE '2013-09%';",
        "pred_query": "SELECT DISTINCT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Date LIKE '2013-09%';",
        "pred_time": 0.0012407302856445312,
        "orig_time": 0.023636341094970703,
        "time_ratio": 19.050345887778633,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the elements for bond id TR001_10_11?",
        "original_query": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
        "llm_output": "-- Reasoning\nThe user wants to find the chemical elements of the atoms involved in a specific bond.\nThe `connected` table links `bond_id` to two atoms: `atom_id` and `atom_id2`.\nThe `atom` table contains the `element` for each `atom_id`.\nTherefore, for the given `bond_id`, we need to find the element for both `connected.atom_id` and `connected.atom_id2`.\nA `UNION` query is appropriate to combine the elements from both sides of the bond, ensuring distinct elements are returned.\n\n-- SQL Query\nSELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_10_11' UNION SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 WHERE T2.bond_id = 'TR001_10_11';",
        "pred_query": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_10_11' UNION SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 WHERE T2.bond_id = 'TR001_10_11';",
        "pred_time": 0.004006624221801758,
        "orig_time": 0.0023648738861083984,
        "time_ratio": 0.5902409997024695,
        "check": true
    },
    {
        "id": "card_games",
        "question": "List the edhrecRank for cards with frame version 2015.",
        "original_query": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "llm_output": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_query": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "original_query": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "llm_output": "\nSELECT COUNT(player_api_id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990' AND player_name LIKE 'Aaron%';\n",
        "pred_query": "SELECT COUNT(player_api_id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990' AND player_name LIKE 'Aaron%';",
        "pred_time": 0.007069587707519531,
        "orig_time": 0.0038688182830810547,
        "time_ratio": 0.5472480777013355,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "original_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
        "llm_output": "-- Reasoning\nTo find the driver who finished second in the San Marino Grand Prix in 2006, I will join the 'races' table with the 'results' table on 'raceId' and with the 'drivers' table on 'driverId'.\nI will filter the 'races' table for the specific race name and year.\nThen, I will filter the 'results' table for the second position.\nFinally, I will select the forename and surname from the 'drivers' table.\n\n-- SQL Query\nSELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;",
        "pred_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;",
        "pred_time": 0.0035698413848876953,
        "orig_time": 0.0031785964965820312,
        "time_ratio": 0.8904027249048287,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which college do most of the members go to?",
        "original_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to count the number of members for each college.\nThis requires joining the `member` table with the `major` table on `link_to_major` and `major_id`.\nThen, I will group by `college` and count the members.\nFinally, I will order by the count in descending order and select the top one.\n\n-- SQL Query\nSELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_time": 0.0007922649383544922,
        "orig_time": 0.0005223751068115234,
        "time_ratio": 0.6593439662955161,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were from New York?",
        "original_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "llm_output": "-- Reasoning\nI need to count the number of users from the `users` table.\nThe location information is stored in the `Location` column.\nI will filter the `users` table where `Location` is 'New York' and then count the distinct user IDs.\n\n-- SQL Query\nSELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_time": 0.009488344192504883,
        "orig_time": 0.00813746452331543,
        "time_ratio": 0.8576274593562329,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which country is the Belgium Jupiler League from?",
        "original_query": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "llm_output": "\nSELECT T2.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League';\n",
        "pred_query": "SELECT T2.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League';",
        "pred_time": 0.0011107921600341797,
        "orig_time": 0.0007054805755615234,
        "time_ratio": 0.6351148315089075,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "original_query": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "llm_output": "-- Reasoning\nI need to join the Patient and Laboratory tables using their common ID.\nI will filter patients born in the year 1982 using the 'Birthday' column in the Patient table.\nThen, I will use a CASE statement to check if the 'ALB' value from the Laboratory table is within the normal range (3.5 to 5.5) and label it 'normal' or 'abNormal'.\n\nSELECT\n  T1.ID,\n  CASE\n    WHEN T2.ALB BETWEEN 3.5 AND 5.5\n    THEN 'normal'\n    ELSE 'abNormal'\n  END\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  STRFTIME('%Y', T1.Birthday) = '1982';",
        "pred_query": "SELECT\n  T1.ID,\n  CASE\n    WHEN T2.ALB BETWEEN 3.5 AND 5.5\n    THEN 'normal'\n    ELSE 'abNormal'\n  END\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  STRFTIME('%Y', T1.Birthday) = '1982';",
        "pred_time": 0.007378339767456055,
        "orig_time": 0.006268024444580078,
        "time_ratio": 0.8495169160177077,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "original_query": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "llm_output": "SELECT T1.name, COUNT(T3.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode INNER JOIN cards AS T3 ON T1.code = T3.setCode WHERE T2.language = 'Italian' GROUP BY T1.name",
        "pred_query": "SELECT T1.name, COUNT(T3.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode INNER JOIN cards AS T3 ON T1.code = T3.setCode WHERE T2.language = 'Italian' GROUP BY T1.name",
        "pred_time": 0.08254528045654297,
        "orig_time": 0.004133462905883789,
        "time_ratio": 0.050075096759286,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many clients who choose statement of weekly issuance are User?",
        "original_query": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'USER'",
        "llm_output": "-- Reasoning\nWe need to count clients (`client.client_id`) who meet two criteria:\n1. Their associated `account.frequency` is 'POPLATEK TYDNE' (weekly issuance).\n2. Their `disp.type` is 'OWNER' (assuming 'User' refers to the primary owner of the account, as 'DISPONENT' is for 'Disponent' based on examples).\nWe will join `client`, `disp`, and `account` tables to link these attributes.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_time": 0.002435922622680664,
        "orig_time": 0.0008251667022705078,
        "time_ratio": 0.33874914358422237,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "original_query": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "llm_output": "-- Reasoning\nTo find the badge names for a user, I need to join the `users` table with the `badges` table using `users.Id = badges.UserId`.\nThen, I will filter the results by the user's `DisplayName` being 'Pierre' and select the `Name` from the `badges` table.\n\n-- SQL Query\nSELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "pred_query": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "pred_time": 0.06547951698303223,
        "orig_time": 0.060832977294921875,
        "time_ratio": 0.9290382717802513,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients whose C-reactive protein level is abnormal, how many of them aren't 18 yet?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP != '-' AND T2.CRP != '+-') AND T2.CRP >= 1.0 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < '18'",
        "llm_output": "-- Reasoning\nThe question requires counting patients who meet two criteria: having an abnormal C-reactive protein (CRP) level and being under 18 years old.\n1. Identify abnormal CRP: Based on previous examples, normal CRP is `'-'`, `'+-'`, or `CRP < 1.0`. Therefore, abnormal CRP is when the value is not `'-'`, not `'+-'`, and numerically greater than or equal to `1.0`. We need to use `CAST` for numerical comparison.\n2. Identify patients under 18: This can be determined by comparing the patient's `Birthday` from the `Patient` table with the date 18 years ago from the current date using `DATE('now', '-18 years')`. A patient is under 18 if their `Birthday` is greater than this calculated date.\n3. Join the `Patient` and `Laboratory` tables on `ID` to combine information.\n4. Use `COUNT(DISTINCT Patient.ID)` to count unique patients satisfying both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  (\n    T2.CRP NOT IN ('-', '+-') AND CAST(T2.CRP AS REAL) >= 1.0\n  ) AND T1.Birthday > DATE('now', '-18 years');",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  (\n    T2.CRP NOT IN ('-', '+-') AND CAST(T2.CRP AS REAL) >= 1.0\n  ) AND T1.Birthday > DATE('now', '-18 years');",
        "pred_time": 0.012404441833496094,
        "orig_time": 0.010434627532958984,
        "time_ratio": 0.8412008918274775,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "original_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "llm_output": "-- Reasoning\nTo answer the question, I need to first find the `setCode` for the set \"Hauptset Zehnte Edition\" from the `set_translations` table.\nThen, I will use this `setCode` to filter the `cards` table and simultaneously filter by the `artist` 'Adam Rex'.\nFinally, I will count the number of cards that satisfy both conditions.\n\nSELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_time": 0.05513882637023926,
        "orig_time": 0.052793025970458984,
        "time_ratio": 0.9574564684415119,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patient who first came to the hospital on 1991/6/13 who was diagnosed with SJS, what is the total number of his/her Laboratory tests in 1995?",
        "original_query": "SELECT COUNT(*) FROM Laboratory WHERE ID = ( SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS' ) AND STRFTIME('%Y', Date) = '1995'",
        "llm_output": "-- Reasoning\nThe query needs to identify a specific patient based on their 'First Date' and 'Diagnosis' from the `Patient` table.\nThen, it needs to count the number of entries in the `Laboratory` table for that patient, specifically for the year 1995.\nThis requires joining `Patient` and `Laboratory` tables on `ID`, filtering by the patient's criteria, and then filtering by the year of the laboratory test date.\n\n-- SQL Query\nSELECT COUNT(T2.Date) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` = '1991-06-13' AND T1.Diagnosis = 'SJS' AND STRFTIME('%Y', T2.Date) = '1995';",
        "pred_query": "SELECT COUNT(T2.Date) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` = '1991-06-13' AND T1.Diagnosis = 'SJS' AND STRFTIME('%Y', T2.Date) = '1995';",
        "pred_time": 0.0012712478637695312,
        "orig_time": 0.0006327629089355469,
        "time_ratio": 0.49774943735933985,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "original_query": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the display name of the user who acquired the first 'Autobiographer' badge, I need to join the `badges` table with the `users` table.\nI will filter for badges named 'Autobiographer', order them by their `Date` in ascending order, and then select the `DisplayName` of the user associated with the earliest badge.\nFinally, I will limit the result to 1 to get only the very first one.\n\n-- SQL Query\nSELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Autobiographer' ORDER BY T1.Date ASC LIMIT 1;",
        "pred_query": "SELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Autobiographer' ORDER BY T1.Date ASC LIMIT 1;",
        "pred_time": 0.017787933349609375,
        "orig_time": 0.013005971908569336,
        "time_ratio": 0.7311682393309028,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Identify the total number of posts with views above average.",
        "original_query": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "llm_output": "-- Reasoning\nFirst, I need to calculate the average `ViewCount` from the `posts` table.\nThen, I will filter the `posts` table to include only those posts where `ViewCount` is greater than this calculated average.\nFinally, I will count the number of posts that satisfy this condition.\n\n-- SQL Query\nSELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_query": "SELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_time": 0.1943652629852295,
        "orig_time": 0.1966395378112793,
        "time_ratio": 1.0117010354171292,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "llm_output": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.types LIKE '%Artifact%' AND T1.colors LIKE '%Black%';",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.types LIKE '%Artifact%' AND T1.colors LIKE '%Black%';",
        "pred_time": 0.2947525978088379,
        "orig_time": 0.27765703201293945,
        "time_ratio": 0.9420002879601903,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "original_query": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "llm_output": "SELECT DISTINCT T1.ID FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T2.GPT > 30 AND T2.ALB < 4;",
        "pred_query": "SELECT DISTINCT T1.ID FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T2.GPT > 30 AND T2.ALB < 4;",
        "pred_time": 0.001963376998901367,
        "orig_time": 0.004787921905517578,
        "time_ratio": 2.438615664845173,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the labels for TR000, TR001 and TR002?",
        "original_query": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
        "llm_output": "-- Reasoning\nThe question asks for the labels associated with specific molecule IDs: 'TR000', 'TR001', and 'TR002'.\nThe `molecule` table contains both `molecule_id` and `label`.\nI need to select the `label` column from the `molecule` table and filter the rows where `molecule_id` is one of the specified values.\n\n-- SQL Query\nSELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_query": "SELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_time": 0.0010790824890136719,
        "orig_time": 0.0004565715789794922,
        "time_ratio": 0.42311091471498014,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin?",
        "original_query": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "llm_output": "\nSELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin';\n",
        "pred_query": "SELECT COUNT(*) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin';",
        "pred_time": 0.010188102722167969,
        "orig_time": 0.008213996887207031,
        "time_ratio": 0.806234203875316,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "original_query": "SELECT CAST(SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTRING(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "llm_output": "-- Reasoning\nFirst, identify the CustomerID from the transactions_1k table based on the given date and price.\nThen, calculate the total consumption for this specific customer for the year 2012 and the year 2013 from the yearmonth table.\nFinally, compute the decrease rate using the formula (Consumption_2012 - Consumption_2013) / Consumption_2012.\n\n-- SQL Query\nSELECT (SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2013' THEN T2.Consumption ELSE 0 END)) * 1.0 / SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8;",
        "pred_query": "SELECT (SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2013' THEN T2.Consumption ELSE 0 END)) * 1.0 / SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8;",
        "pred_time": 0.13347816467285156,
        "orig_time": 0.02231454849243164,
        "time_ratio": 0.16717751961246624,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Identify the heaviest superhero in DC Comics.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the heaviest superhero in DC Comics, I need to join the `superhero` table with the `publisher` table.\nThen, I will filter the results for 'DC Comics' from the `publisher_name` column.\nFinally, I will order the filtered superheroes by `weight_kg` in descending order and select the `superhero_name` of the top entry.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1;",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1;",
        "pred_time": 0.0011522769927978516,
        "orig_time": 0.0005846023559570312,
        "time_ratio": 0.5073453341609766,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Please list the diseases of the patients born after 1995-1-1 and have a normal Rhuematoid Factor.",
        "original_query": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > 1995-01-01",
        "llm_output": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday > '1995-01-01' AND T2.RA = '-'",
        "pred_query": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday > '1995-01-01' AND T2.RA = '-'",
        "pred_time": 0.005405902862548828,
        "orig_time": 0.004870414733886719,
        "time_ratio": 0.9009438122960218,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the name of user with the ID of 30?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = 30",
        "llm_output": "-- Reasoning\nTo find the name of the user with ID 30, I need to query the `users` table.\nThe `users` table contains the `DisplayName` column which stores the user's name, and the `Id` column for user identification.\nI will filter the results by `Id = 30` and select the `DisplayName`.\n\n-- SQL Query\nSELECT DisplayName FROM users WHERE Id = 30;",
        "pred_query": "SELECT DisplayName FROM users WHERE Id = 30;",
        "pred_time": 0.0012476444244384766,
        "orig_time": 0.0005128383636474609,
        "time_ratio": 0.4110452895088859,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "original_query": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "llm_output": "\nSELECT T1.time FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Sepang International Circuit'\n",
        "pred_query": "SELECT T1.time FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Sepang International Circuit'",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the names of the races held on the circuits in Spain.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "llm_output": "\nSELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain'\n",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain'",
        "pred_time": 0.0011813640594482422,
        "orig_time": 0.0007777214050292969,
        "time_ratio": 0.6583249243188698,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
        "original_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
        "llm_output": "-- Reasoning\nI need to find `atom_id`s from the `atom` table.\nThe conditions are that the molecule associated with the atom must be carcinogenic (from `molecule` table where `label = '+'`) and the atom's element must be 'o' (oxygen).\nI will join `atom` and `molecule` tables on `molecule_id` and apply the filters.\n\n-- SQL Query\nSELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'o';",
        "pred_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'o';",
        "pred_time": 0.009558677673339844,
        "orig_time": 0.0014989376068115234,
        "time_ratio": 0.15681432704779008,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "llm_output": "-- Reasoning\nTo find accounts in Prague, I will join the `account` table with the `district` table.\nThen, I will filter these accounts for those where the district's A3 column (region name) is 'Prague'.\nFinally, to determine which of these accounts are \"eligible for loans\" (interpreted as having a loan), I will join with the `loan` table and count the distinct `account_id`s.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = 'Prague';",
        "pred_query": "SELECT COUNT(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = 'Prague';",
        "pred_time": 0.0016167163848876953,
        "orig_time": 0.0008032321929931641,
        "time_ratio": 0.49682937619820083,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Is molecule TR124 carcinogenic?",
        "original_query": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
        "llm_output": "-- Reasoning\nThe question asks whether a specific molecule (TR124) is carcinogenic.\nThe `molecule` table contains information about molecules, including their `label`, which indicates carcinogenicity.\nTo answer the question, I need to retrieve the `label` for the `molecule_id` 'TR124' from the `molecule` table.\n\n-- SQL Query\nSELECT T1.label FROM molecule AS T1 WHERE T1.molecule_id = 'TR124';",
        "pred_query": "SELECT T1.label FROM molecule AS T1 WHERE T1.molecule_id = 'TR124';",
        "pred_time": 0.0009963512420654297,
        "orig_time": 0.00042939186096191406,
        "time_ratio": 0.43096434553720986,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the anti Cardiolipin antibody concentration of the female patient with the highest uric acid level in the normal range?",
        "original_query": "SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T1.SEX = 'F' AND T2.UA > 6.5 ORDER BY T2.UA DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe query needs to identify a female patient with a uric acid (UA) level within the normal range, specifically the one with the highest UA among them.\nBased on the few-shot examples, a UA level <= 6.5 is considered normal for females.\nOnce this patient is identified, their anti Cardiolipin antibody concentration (`aCL IgA`) needs to be retrieved from the `Examination` table.\nThe `Patient` table identifies the sex, the `Laboratory` table contains uric acid levels, and the `Examination` table contains `aCL IgA`. All tables can be joined by `ID`.\n\n-- SQL Query\nSELECT T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.SEX = 'F' AND T2.UA <= 6.5 ORDER BY T2.UA DESC LIMIT 1;",
        "pred_query": "SELECT T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.SEX = 'F' AND T2.UA <= 6.5 ORDER BY T2.UA DESC LIMIT 1;",
        "pred_time": 0.001956939697265625,
        "orig_time": 0.001131296157836914,
        "time_ratio": 0.5780945419103314,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Calculate the ratio of votes in 2010 and 2011.",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
        "llm_output": "-- Reasoning\nTo calculate the ratio, we need to count the total votes for each year, 2010 and 2011.\nWe can use the `votes` table and filter by `CreationDate` to extract the year.\nThen, we'll cast the count of 2010 votes to REAL and divide it by the count of 2011 votes to get the ratio.\n\n-- SQL Query\nSELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes;",
        "pred_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes;",
        "pred_time": 0.027750492095947266,
        "orig_time": 0.01868605613708496,
        "time_ratio": 0.6733594515181195,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Calculate the difference in view count from post posted by mornington and view count from posts posted by Amos.",
        "original_query": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "llm_output": "-- Reasoning\nI need to find the total view count for posts made by the user 'mornington' and the total view count for posts made by the user 'Amos'.\nI will join the 'posts' table with the 'users' table on 'OwnerUserId' and 'Id' respectively.\nThen, I'll filter by 'DisplayName' and calculate the sum of 'ViewCount' for each user.\nFinally, I will subtract Amos's total view count from mornington's total view count.\n\n-- SQL Query\nSELECT\n  SUM(CASE WHEN T2.DisplayName = 'mornington' THEN T1.ViewCount ELSE 0 END) -\n  SUM(CASE WHEN T2.DisplayName = 'Amos' THEN T1.ViewCount ELSE 0 END)\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  T2.DisplayName IN ('mornington', 'Amos');",
        "pred_query": "SELECT\n  SUM(CASE WHEN T2.DisplayName = 'mornington' THEN T1.ViewCount ELSE 0 END) -\n  SUM(CASE WHEN T2.DisplayName = 'Amos' THEN T1.ViewCount ELSE 0 END)\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  T2.DisplayName IN ('mornington', 'Amos');",
        "pred_time": 0.1970052719116211,
        "orig_time": 1.4658401012420654,
        "time_ratio": 7.440613578603413,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "original_query": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "llm_output": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CreaionDate = '2010-07-19 19:19:56.0';",
        "pred_query": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CreaionDate = '2010-07-19 19:19:56.0';",
        "pred_time": 0.19861483573913574,
        "orig_time": 0.05027627944946289,
        "time_ratio": 0.2531345619896021,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "original_query": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "llm_output": "\nSELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';\n",
        "pred_query": "SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "pred_time": 0.06973028182983398,
        "orig_time": 0.06186032295227051,
        "time_ratio": 0.8871371422710022,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "original_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find transactions that occurred on '2012-08-25'.\nFrom these transactions, I will find the one with the earliest time.\nThen, I will join with the `gasstations` table to retrieve the country associated with that gas station ID.\n\n-- SQL Query\nSELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time ASC LIMIT 1;",
        "pred_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time ASC LIMIT 1;",
        "pred_time": 0.001367330551147461,
        "orig_time": 0.0007402896881103516,
        "time_ratio": 0.5414123801220575,
        "check": true
    },
    {
        "id": "student_club",
        "question": "When did the member, Casey Mason, received the income?",
        "original_query": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "llm_output": "-- Reasoning\nI need to find the `date_received` from the `income` table.\nThis information is linked to a `member` via `link_to_member`.\nI will join `member` and `income` tables on `member_id` and `link_to_member`.\nThen I will filter by the `first_name` 'Casey' and `last_name` 'Mason' to find the specific member.\n\n-- SQL Query\nSELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_query": "SELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_time": 0.0010292530059814453,
        "orig_time": 0.0004930496215820312,
        "time_ratio": 0.4790363678480426,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "llm_output": "-- Reasoning\nI need to join the Patient table with the Laboratory table using the ID column.\nFilter patients born in the year 1937 using the Birthday column in the Patient table.\nFilter laboratory results where `T-CHO` is 250 or greater, which is considered beyond the normal range based on previous examples.\nSelect the distinct ID of these patients.\n\n-- SQL Query\nSELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250;",
        "pred_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250;",
        "pred_time": 0.0017919540405273438,
        "orig_time": 0.0010137557983398438,
        "time_ratio": 0.5657264502394891,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "original_query": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "llm_output": "-- Reasoning\nI need to join `customers` and `yearmonth` tables on `CustomerID`.\nThen, I will filter for customers with `Segment = 'LAM'`.\nI will count customers whose `Consumption` is greater than 46.73 and divide by the total count of LAM customers, then multiply by 100 to get the percentage.\nI should use `COUNT(DISTINCT T1.CustomerID)` to ensure each customer is counted only once, even if they have multiple entries in `yearmonth`.\n\n-- SQL Query\nSELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS REAL) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM';",
        "pred_query": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS REAL) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM';",
        "pred_time": 0.04591727256774902,
        "orig_time": 0.03672027587890625,
        "time_ratio": 0.7997050744842698,
        "check": true
    },
    {
        "id": "superhero",
        "question": "What is the gender of Agent 13 hero?",
        "original_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'",
        "llm_output": "-- Reasoning\nTo find the gender of 'Agent 13', I need to join the `superhero` table with the `gender` table.\nI will filter the `superhero` table by `superhero_name` = 'Agent 13'.\nFinally, I will select the `gender` from the `gender` table for the matched hero.\n\n-- SQL Query\nSELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_time": 0.001089334487915039,
        "orig_time": 0.0005280971527099609,
        "time_ratio": 0.4847887940468374,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please give the full name of the tallest hero published by Marvel Comics.",
        "original_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the `full_name` from the `superhero` table.\nI will join `superhero` with the `publisher` table to filter by `publisher_name`.\nThen, I will filter for 'Marvel Comics' and order the results by `height_cm` in descending order to find the tallest, finally limiting to 1.\n\n-- SQL Query\nSELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_time": 0.0011112689971923828,
        "orig_time": 0.0005869865417480469,
        "time_ratio": 0.5282128298648359,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "original_query": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "llm_output": "-- Reasoning\nTo find the artists who illustrated cards with 'Phyrexian' foreign data, I need to join the `cards` table with the `foreign_data` table.\nI will filter the `foreign_data` table where the `language` column is 'Phyrexian'.\nFinally, I will select the distinct `artist` names from the `cards` table.\n\n-- SQL Query\nSELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian';",
        "pred_query": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian';",
        "pred_time": 0.0804908275604248,
        "orig_time": 0.07425236701965332,
        "time_ratio": 0.9224947645607414,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "original_query": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "llm_output": "-- Reasoning\nTo find the user who added a bounty, we need to look at the `votes` table which contains `UserId` and `BountyAmount`, and also `PostId`.\nWe then need to filter these votes by `BountyAmount = 50`.\nThe `PostId` from these filtered votes must correspond to a post whose `Title` mentions 'variance' in the `posts` table.\nFinally, we join with the `users` table using `UserId` to retrieve the `DisplayName` of the user.\n\n-- SQL Query\nSELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_query": "SELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_time": 0.005044698715209961,
        "orig_time": 0.0034973621368408203,
        "time_ratio": 0.6932747294295571,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Write down the ruling of Beacon of Immortality.",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "llm_output": "\nSELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality';\n",
        "pred_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality';",
        "pred_time": 0.15761232376098633,
        "orig_time": 0.15509510040283203,
        "time_ratio": 0.9840290194441167,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "original_query": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "llm_output": "-- Reasoning\nI need to first identify all `molecule_id`s that have at least one bond with `bond_type` equal to '#'.\nThen, I will use these `molecule_id`s to find all `element`s associated with them in the `atom` table.\nFinally, I will select distinct elements.\n\n-- SQL Query\nSELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN bond AS T2\n  ON T1.molecule_id = T2.molecule_id\nWHERE\n  T2.bond_type = '#';",
        "pred_query": "SELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN bond AS T2\n  ON T1.molecule_id = T2.molecule_id\nWHERE\n  T2.bond_type = '#';",
        "pred_time": 0.012345075607299805,
        "orig_time": 0.006449699401855469,
        "time_ratio": 0.5224511867745611,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "original_query": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "llm_output": "-- Reasoning\nI need to join the `users` and `badges` tables to link users with their badges.\nThen, I will filter for users who have the 'Organizer' badge.\nAmong these users, I will count how many are teenagers (Age between 13 and 18).\nFinally, I will divide the count of teenage organizers by the total count of organizers and multiply by 100 to get the percentage.\n\nSELECT\n  CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id)\nFROM users AS T1\nINNER JOIN badges AS T2\n  ON T1.Id = T2.UserId\nWHERE\n  T2.Name = 'Organizer';",
        "pred_query": "SELECT\n  CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id)\nFROM users AS T1\nINNER JOIN badges AS T2\n  ON T1.Id = T2.UserId\nWHERE\n  T2.Name = 'Organizer';",
        "pred_time": 0.011009931564331055,
        "orig_time": 0.008926153182983398,
        "time_ratio": 0.8107364819506703,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to first count the number of superheroes for 'DC Comics' and 'Marvel Comics' separately.\nThen, I will compare these two counts to determine which publisher has more superheroes.\nFinally, I will calculate the absolute difference between these two counts.\nI will use Common Table Expressions (CTEs) to calculate the counts for each publisher, and then combine them to find the difference and the publisher with more heroes.\n\n-- SQL Query\nSELECT\n  CASE\n    WHEN DC_Count.dc_heroes > Marvel_Count.marvel_heroes THEN 'DC Comics'\n    ELSE 'Marvel Comics'\n  END AS Publisher_With_More_Superheroes,\n  ABS(DC_Count.dc_heroes - Marvel_Count.marvel_heroes) AS Difference_In_Superheroes\nFROM (\n  SELECT\n    COUNT(T1.id) AS dc_heroes\n  FROM superhero AS T1\n  INNER JOIN publisher AS T2\n    ON T1.publisher_id = T2.id\n  WHERE\n    T2.publisher_name = 'DC Comics'\n) AS DC_Count, (\n  SELECT\n    COUNT(T1.id) AS marvel_heroes\n  FROM superhero AS T1\n  INNER JOIN publisher AS T2\n    ON T1.publisher_id = T2.id\n  WHERE\n    T2.publisher_name = 'Marvel Comics'\n) AS Marvel_Count;",
        "pred_query": "SELECT\n  CASE\n    WHEN DC_Count.dc_heroes > Marvel_Count.marvel_heroes THEN 'DC Comics'\n    ELSE 'Marvel Comics'\n  END AS Publisher_With_More_Superheroes,\n  ABS(DC_Count.dc_heroes - Marvel_Count.marvel_heroes) AS Difference_In_Superheroes\nFROM (\n  SELECT\n    COUNT(T1.id) AS dc_heroes\n  FROM superhero AS T1\n  INNER JOIN publisher AS T2\n    ON T1.publisher_id = T2.id\n  WHERE\n    T2.publisher_name = 'DC Comics'\n) AS DC_Count, (\n  SELECT\n    COUNT(T1.id) AS marvel_heroes\n  FROM superhero AS T1\n  INNER JOIN publisher AS T2\n    ON T1.publisher_id = T2.id\n  WHERE\n    T2.publisher_name = 'Marvel Comics'\n) AS Marvel_Count;",
        "pred_time": 0.0012047290802001953,
        "orig_time": 0.0006208419799804688,
        "time_ratio": 0.5153374233128835,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "original_query": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "llm_output": "-- Reasoning\nThe query needs to find the user who created a specific post.\nThis requires joining the `posts` table with the `users` table on `OwnerUserId` and `Id`.\nThen, filter the results by the `Title` of the post.\nFinally, select the `DisplayName` and `Reputation` of the owner from the `users` table.\n\n-- SQL Query\nSELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_query": "SELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_time": 0.10499978065490723,
        "orig_time": 0.10315704345703125,
        "time_ratio": 0.9824500852632033,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "original_query": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "llm_output": "\nSELECT DISTINCT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.name = 'Archenemy' AND T1.code = 'ARC';\n",
        "pred_query": "SELECT DISTINCT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.name = 'Archenemy' AND T1.code = 'ARC';",
        "pred_time": 0.010467767715454102,
        "orig_time": 0.0039033889770507812,
        "time_ratio": 0.37289602550962303,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "llm_output": "-- Reasoning\nTo find patients with a normal proteinuria level and an SLE diagnosis, we need to join the `Patient` and `Laboratory` tables on `ID`.\nWe will filter for `Patient.Diagnosis` = 'SLE'.\nFor normal proteinuria, based on the examples provided (`U-PRO` > 0 AND `U-PRO` < 30), we will filter `Laboratory.U-PRO` after casting it to a real number.\nFinally, we select the distinct `ID` of these patients.\n\n-- SQL Query\nSELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND CAST(T2.`U-PRO` AS REAL) > 0 AND CAST(T2.`U-PRO` AS REAL) < 30;",
        "pred_query": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND CAST(T2.`U-PRO` AS REAL) > 0 AND CAST(T2.`U-PRO` AS REAL) < 30;",
        "pred_time": 0.0031118392944335938,
        "orig_time": 0.0020160675048828125,
        "time_ratio": 0.647870058228624,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What type of label is not on molecules with atoms with tin?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "llm_output": "-- Reasoning\nI need to find labels from the `molecule` table.\nFirst, I will identify all `molecule_id`s that contain atoms with the element 'sn'.\nThen, I will get the labels associated with these `molecule_id`s.\nFinally, I will select all labels from the `molecule` table that are NOT in the set of labels found in the previous step.\n\n-- SQL Query\nSELECT T1.label\nFROM molecule AS T1\nWHERE T1.label NOT IN (\n  SELECT T2.label\n  FROM atom AS T3\n  INNER JOIN molecule AS T2\n  ON T3.molecule_id = T2.molecule_id\n  WHERE T3.element = 'sn'\n);",
        "pred_query": "SELECT T1.label\nFROM molecule AS T1\nWHERE T1.label NOT IN (\n  SELECT T2.label\n  FROM atom AS T3\n  INNER JOIN molecule AS T2\n  ON T3.molecule_id = T2.molecule_id\n  WHERE T3.element = 'sn'\n);",
        "pred_time": 0.0018033981323242188,
        "orig_time": 0.0031549930572509766,
        "time_ratio": 1.7494711792702273,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "original_query": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "llm_output": "SELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.q2 LIKE '1:40%' AND T1.raceId = 355;",
        "pred_query": "SELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.q2 LIKE '1:40%' AND T1.raceId = 355;",
        "pred_time": 0.0016338825225830078,
        "orig_time": 0.0012063980102539062,
        "time_ratio": 0.7383627608346709,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "original_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nTo find the Italian flavor text, I need to look into the `foreign_data` table which contains localized information including `flavorText` and `language`.\nI will join `foreign_data` with `cards` using the `uuid` column to identify the specific card by its `name`.\nThen, I will filter the results by `language` = 'Italian' and `name` = 'Ancestor''s Chosen'.\n\n-- SQL Query\nSELECT T1.flavorText FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Ancestor''s Chosen' AND T1.language = 'Italian'",
        "pred_query": "SELECT T1.flavorText FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Ancestor''s Chosen' AND T1.language = 'Italian'",
        "pred_time": 0.19270062446594238,
        "orig_time": 0.1881115436553955,
        "time_ratio": 0.9761854388211495,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "original_query": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "llm_output": "-- Reasoning\nI need to retrieve the expense descriptions.\nThese descriptions are in the 'expense' table.\nI also need to filter by member's t-shirt size, which is in the 'member' table.\nTherefore, I will join 'expense' and 'member' tables on `link_to_member` and `member_id` respectively, and filter for `t_shirt_size = 'X-Large'`.\n\n-- SQL Query\nSELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';",
        "pred_query": "SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';",
        "pred_time": 0.0010013580322265625,
        "orig_time": 0.0005102157592773438,
        "time_ratio": 0.5095238095238095,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "original_query": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "llm_output": "-- Reasoning\nThe question asks for `driverId` and `code` of drivers born in 1971 who achieved the fastest lap time on the race.\n\"Fastest lap time\" implies finding the minimum lap time recorded. The `results` table has `milliseconds` and `fastestLapTime` columns. `milliseconds` is an integer and is more reliable for numerical comparison of \"fastest\" than the `fastestLapTime` text field.\nI will first find the minimum `milliseconds` value from the `results` table.\nThen, I will join `drivers` and `results` tables on `driverId`.\nI'll filter the `drivers` based on their `dob` year being 1971 using `strftime('%Y', dob)`.\nFinally, I'll filter the joined results to include only those records where the `milliseconds` matches the overall minimum found.\n\n-- SQL Query\nSELECT T1.driverId, T1.code FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE strftime('%Y', T1.dob) = '1971' AND T2.milliseconds = (SELECT MIN(milliseconds) FROM results WHERE milliseconds IS NOT NULL);",
        "pred_query": "SELECT T1.driverId, T1.code FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE strftime('%Y', T1.dob) = '1971' AND T2.milliseconds = (SELECT MIN(milliseconds) FROM results WHERE milliseconds IS NOT NULL);",
        "pred_time": 0.005010128021240234,
        "orig_time": 0.004948616027832031,
        "time_ratio": 0.9877224707337965,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the average age of patients examined in the laboratory for the October of the year 1991?",
        "original_query": "SELECT AVG('1999' - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "llm_output": "-- Reasoning\nTo find the average age, we need to join the `Patient` table with the `Laboratory` table on `ID`.\nWe will filter the `Laboratory` records for the month of October and year 1991 using `STRFTIME`.\nThen, for each relevant record, we calculate the patient's age by subtracting the birth year from the examination year.\nFinally, we compute the average of these calculated ages.\n\n-- SQL Query\nSELECT AVG(STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.Date) = '1991' AND STRFTIME('%m', T2.Date) = '10';",
        "pred_query": "SELECT AVG(STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.Date) = '1991' AND STRFTIME('%m', T2.Date) = '10';",
        "pred_time": 0.00453495979309082,
        "orig_time": 0.0020723342895507812,
        "time_ratio": 0.4569686136375585,
        "check": false
    },
    {
        "id": "financial",
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "original_query": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "llm_output": "-- Reasoning\nI need to find the `district_id` associated with a particular `order_id`.\nThe `order` table contains `order_id` and `account_id`.\nThe `account` table contains `account_id` and `district_id`.\nI will join `order` and `account` tables on `account_id` and then filter by `order_id = 33333` to retrieve the `district_id`.\n\n-- SQL Query\nSELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_query": "SELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_time": 0.0011205673217773438,
        "orig_time": 0.0007035732269287109,
        "time_ratio": 0.6278723404255319,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "original_query": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "llm_output": "-- Reasoning\nI need to calculate a percentage, which means dividing a count of specific players by a total count of relevant players and multiplying by 100.\nThe specific players are those who prefer their left foot AND were born between 1987 and 1992.\nThe total relevant players are those born between 1987 and 1992 who also have entries in Player_Attributes (to ensure 'preferred_foot' data exists).\nI will join the `Player` table (for birthday) with the `Player_Attributes` table (for preferred_foot) on `player_api_id`.\nI will use `STRFTIME('%Y', birthday)` to extract the birth year and filter for the range '1987' to '1992'.\nTo get distinct players, I will use `COUNT(DISTINCT T1.player_api_id)` in subqueries for both the numerator and the denominator.\n\n-- SQL Query\nSELECT CAST(COUNT(DISTINCT T1.player_api_id) FILTER (WHERE T2.preferred_foot = 'left') AS REAL) * 100 / COUNT(DISTINCT T1.player_api_id)\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992';",
        "pred_query": "SELECT CAST(COUNT(DISTINCT T1.player_api_id) FILTER (WHERE T2.preferred_foot = 'left') AS REAL) * 100 / COUNT(DISTINCT T1.player_api_id)\nFROM Player AS T1\nINNER JOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992';",
        "pred_time": 0.16310620307922363,
        "orig_time": 0.10680532455444336,
        "time_ratio": 0.6548207397272688,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What is the least common element of all carcinogenic molecules?",
        "original_query": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "llm_output": "-- Reasoning\nI need to first filter for carcinogenic molecules using the `label` column in the `molecule` table.\nThen, I will join with the `atom` table to get all elements present in these molecules.\nNext, I will count the number of distinct carcinogenic molecules each element appears in.\nFinally, I will order these counts in ascending order and pick the element with the lowest count.\n\n-- SQL Query\nSELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1;",
        "pred_query": "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1;",
        "pred_time": 0.0044252872467041016,
        "orig_time": 0.0036287307739257812,
        "time_ratio": 0.8199989224718496,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "llm_output": "-- Reasoning\nI need to calculate the percentage of drivers meeting specific criteria: born before 1985 and having lap numbers over 50, within races from 2000 to 2005.\nFirst, I'll identify the set of drivers who participated in races between 2000 and 2005 and had at least one lap over 50. This will be the denominator.\nThen, from this set, I'll filter further to include only drivers born before 1985. This will be the numerator.\nFinally, I will divide the numerator by the denominator and multiply by 100 to get the percentage.\n\n-- SQL Query\nSELECT CAST(COUNT(DISTINCT T3.driverId) AS REAL) * 100 / (\n  SELECT COUNT(DISTINCT T2.driverId)\n  FROM races AS T1\n  INNER JOIN lapTimes AS T2\n    ON T1.raceId = T2.raceId\n  WHERE\n    T1.year BETWEEN 2000 AND 2005 AND T2.lap > 50\n)\nFROM races AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.raceId = T2.raceId\nINNER JOIN drivers AS T3\n  ON T2.driverId = T3.driverId\nWHERE\n  T1.year BETWEEN 2000 AND 2005 AND T2.lap > 50 AND STRFTIME('%Y', T3.dob) < '1985';",
        "pred_query": "SELECT CAST(COUNT(DISTINCT T3.driverId) AS REAL) * 100 / (\n  SELECT COUNT(DISTINCT T2.driverId)\n  FROM races AS T1\n  INNER JOIN lapTimes AS T2\n    ON T1.raceId = T2.raceId\n  WHERE\n    T1.year BETWEEN 2000 AND 2005 AND T2.lap > 50\n)\nFROM races AS T1\nINNER JOIN lapTimes AS T2\n  ON T1.raceId = T2.raceId\nINNER JOIN drivers AS T3\n  ON T2.driverId = T3.driverId\nWHERE\n  T1.year BETWEEN 2000 AND 2005 AND T2.lap > 50 AND STRFTIME('%Y', T3.dob) < '1985';",
        "pred_time": 0.15833449363708496,
        "orig_time": 0.0037665367126464844,
        "time_ratio": 0.0237884785944349,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "llm_output": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_time": 0.0009005069732666016,
        "orig_time": 0.0006480216979980469,
        "time_ratio": 0.7196187450357426,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "original_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to find the `setCode` for the card \"Fellwar Stone\" from the `cards` table.\nThen, using this `setCode`, I need to find the Japanese translation of the set name from the `set_translations` table.\nThis requires joining `cards` and `set_translations` tables.\n\n-- SQL Query\nSELECT T3.translation FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code INNER JOIN set_translations AS T3 ON T2.code = T3.setCode WHERE T1.name = 'Fellwar Stone' AND T3.language = 'Japanese'",
        "pred_query": "SELECT T3.translation FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code INNER JOIN set_translations AS T3 ON T2.code = T3.setCode WHERE T1.name = 'Fellwar Stone' AND T3.language = 'Japanese'",
        "pred_time": null,
        "orig_time": 0.060333251953125,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Provide the name of superhero with superhero ID 294.",
        "original_query": "SELECT superhero_name FROM superhero WHERE id = 294",
        "llm_output": "-- Reasoning\nThe question asks for the name of a superhero given their ID.\nThe `superhero` table contains the `superhero_name` and `id` columns.\nI need to select the `superhero_name` from the `superhero` table where the `id` matches the given value 294.\n\n-- SQL Query\nSELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_query": "SELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_time": 0.0012664794921875,
        "orig_time": 0.0004975795745849609,
        "time_ratio": 0.3928840361445783,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Mention the category of events which were held at MU 215.",
        "original_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "llm_output": "\nSELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';\n",
        "pred_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215';",
        "pred_time": 0.0007836818695068359,
        "orig_time": 0.0005145072937011719,
        "time_ratio": 0.6565257073319136,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Which group does superhero A-Bomb belong to?",
        "original_query": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'",
        "llm_output": "-- Reasoning\nTo find which group a superhero belongs to, I need to look at the `publisher` table.\nI will join the `superhero` table with the `publisher` table on `publisher_id`.\nThen, I will filter the results for the superhero named 'A-Bomb' and select the `publisher_name`.\n\n-- SQL Query\nSELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';",
        "pred_query": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';",
        "pred_time": 0.0011639595031738281,
        "orig_time": 0.0005288124084472656,
        "time_ratio": 0.4543219991806637,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which year has the most number of races?",
        "original_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to count the number of races for each year.\nThe `races` table contains both the `year` and `raceId`.\nI will group the races by `year` and use `COUNT(raceId)` to get the number of races per year.\nFinally, I will order the results by this count in descending order and limit to 1 to get the year with the most races.\n\n-- SQL Query\nSELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_time": 0.0014247894287109375,
        "orig_time": 0.0008685588836669922,
        "time_ratio": 0.6096050870147256,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many posts were created by Daniel Vassallo?",
        "original_query": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "llm_output": "-- Reasoning\nI need to count the posts owned by a specific user.\nI will join the `posts` table with the `users` table using `posts.OwnerUserId = users.Id`.\nThen I will filter by the `DisplayName` in the `users` table for 'Daniel Vassallo'.\nFinally, I will count the distinct post IDs.\n\n-- SQL Query\nSELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_query": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_time": 0.18799185752868652,
        "orig_time": 0.3515126705169678,
        "time_ratio": 1.8698292316374867,
        "check": false
    },
    {
        "id": "financial",
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "original_query": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "llm_output": "-- Reasoning\nI need to join the `client`, `disp`, and `account` tables to link clients to their account statement frequencies.\nFirst, filter for male clients.\nThen, count distinct male clients who have an account with 'weekly issuance' frequency.\nFinally, divide this count by the total count of distinct male clients and multiply by 100 to get the percentage.\n\n\nSELECT CAST(COUNT(DISTINCT T1.client_id) AS REAL) * 100 / (SELECT COUNT(DISTINCT client_id) FROM client WHERE gender = 'M') FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M' AND T3.frequency = 'weekly issuance';\n",
        "pred_query": "SELECT CAST(COUNT(DISTINCT T1.client_id) AS REAL) * 100 / (SELECT COUNT(DISTINCT client_id) FROM client WHERE gender = 'M') FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M' AND T3.frequency = 'weekly issuance';",
        "pred_time": 0.002624034881591797,
        "orig_time": 0.006981372833251953,
        "time_ratio": 2.6605487915682353,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "original_query": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `frpm` table with the `schools` table using the `CDSCode` column to link school information with meal eligibility data.\nThen, I will filter the results to include only schools located in 'Alameda' County.\nFinally, I will select the maximum value of `Percent (%) Eligible Free (K-12)` from the filtered data.\n\n-- SQL Query\nSELECT MAX(T1.`Percent (%) Eligible Free (K-12)`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Alameda';",
        "pred_query": "SELECT MAX(T1.`Percent (%) Eligible Free (K-12)`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Alameda';",
        "pred_time": 0.010008811950683594,
        "orig_time": 0.0033812522888183594,
        "time_ratio": 0.33782753692234396,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "original_query": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "llm_output": "-- Reasoning\nTo find the reputation of the owner of post 65041, I first need to retrieve the `OwnerUserId` from the `posts` table where the `Id` is 65041.\nThen, I will join the `posts` table with the `users` table on `OwnerUserId` and `Id` respectively.\nFinally, I will select the `Reputation` from the `users` table for that specific owner.\n\n-- SQL Query\nSELECT T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 65041;",
        "pred_query": "SELECT T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 65041;",
        "pred_time": 0.0011301040649414062,
        "orig_time": 0.0005159378051757812,
        "time_ratio": 0.45654008438818566,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "original_query": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "\nSELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';\n",
        "pred_query": "SELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_time": 0.0037539005279541016,
        "orig_time": 0.0032439231872558594,
        "time_ratio": 0.8641473483645602,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many high-level credit cards have \"disponent\" type of disposition?",
        "original_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'DISPONENT'",
        "llm_output": "-- Reasoning\nTo find the number of high-level credit cards with a \"disponent\" disposition, I need to join the `card` table with the `disp` table on `disp_id`.\nThen, I will filter the results where `card.type` is 'high-level' and `disp.type` is 'Disponent'.\nFinally, I will count the distinct `card_id`s from the filtered records.\n\n-- SQL Query\nSELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'high-level' AND T2.type = 'Disponent';",
        "pred_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'high-level' AND T2.type = 'Disponent';",
        "pred_time": 0.0008862018585205078,
        "orig_time": 0.0006518363952636719,
        "time_ratio": 0.7355394135055152,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List all of the College of Humanities and Social Sciences' departments.",
        "original_query": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "llm_output": "-- Reasoning\nI need to retrieve the 'department' column from the 'major' table.\nThe condition is that the 'college' column must be 'College of Humanities and Social Sciences'.\nI should use a WHERE clause to filter by the specified college.\nTo avoid duplicate department names, I should use DISTINCT.\n\n-- SQL Query\nSELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "pred_query": "SELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "pred_time": 0.001039743423461914,
        "orig_time": 0.0004947185516357422,
        "time_ratio": 0.47580830084842923,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List the expansion type of the set \"Huiti\u00c3\u00a8me \u00c3\u00a9dition\".",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition' )",
        "llm_output": "\nSELECT type FROM sets WHERE name = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';\n",
        "pred_query": "SELECT type FROM sets WHERE name = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';",
        "pred_time": 0.004819631576538086,
        "orig_time": 0.004415750503540039,
        "time_ratio": 0.9162008409596833,
        "check": true
    },
    {
        "id": "student_club",
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "original_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
        "llm_output": "-- Reasoning\nTo find the number of members with a specific major, I need to join the `member` table with the `major` table.\nI will join `member` and `major` on `member.link_to_major = major.major_id`.\nThen, I will filter the results where `major.major_name` is 'Environmental Engineering'.\nFinally, I will count the `member_id` from the filtered results.\n\n-- SQL Query\nSELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';",
        "pred_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';",
        "pred_time": 0.0009143352508544922,
        "orig_time": 0.0005309581756591797,
        "time_ratio": 0.5807040417209909,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List down at least five superpowers of male superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
        "llm_output": "SELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN hero_power AS T4 ON T1.id = T4.hero_id INNER JOIN superpower AS T3 ON T4.power_id = T3.id WHERE T2.gender = 'Male' LIMIT 5",
        "pred_query": "SELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN hero_power AS T4 ON T1.id = T4.hero_id INNER JOIN superpower AS T3 ON T4.power_id = T3.id WHERE T2.gender = 'Male' LIMIT 5",
        "pred_time": 0.0010204315185546875,
        "orig_time": 0.0004851818084716797,
        "time_ratio": 0.47546728971962615,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "For the race happened in 2015/11/29, how many drivers finished the game?",
        "original_query": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to find the number of drivers who finished a race on a specific date.\nI will join the `races` table with the `results` table on `raceId`.\nThen, I will filter the `races` table by the given `date`.\nFinally, I will count the distinct `driverId` from the `results` table where the `time` column is not NULL, indicating a finished race.\n\n-- SQL Query\nSELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;",
        "pred_query": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;",
        "pred_time": 0.0038547515869140625,
        "orig_time": 0.0032842159271240234,
        "time_ratio": 0.8519915883226126,
        "check": true
    },
    {
        "id": "superhero",
        "question": "How many superheroes are published by Marvel Comics?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "llm_output": "-- Reasoning\nTo find the number of superheroes published by Marvel Comics, I need to join the `superhero` table with the `publisher` table.\nI will filter the results where the `publisher_name` is 'Marvel Comics'.\nFinally, I will count the `id` from the `superhero` table.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_time": 0.0011966228485107422,
        "orig_time": 0.0005800724029541016,
        "time_ratio": 0.4847579199043634,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "original_query": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "llm_output": "SELECT MIN(milliseconds) FROM lapTimes;",
        "pred_query": "SELECT MIN(milliseconds) FROM lapTimes;",
        "pred_time": 0.02848529815673828,
        "orig_time": 0.26621198654174805,
        "time_ratio": 9.345592420235027,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Give the publisher ID of Star Trek.",
        "original_query": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
        "llm_output": "-- Reasoning\nThe question asks for the publisher ID of 'Star Trek'.\nThe `superhero` table contains `superhero_name` and `publisher_id`.\nI need to filter the `superhero` table by `superhero_name = 'Star Trek'` and select the `publisher_id`.\n\n-- SQL Query\nSELECT publisher_id FROM superhero WHERE superhero_name = 'Star Trek';",
        "pred_query": "SELECT publisher_id FROM superhero WHERE superhero_name = 'Star Trek';",
        "pred_time": 0.0011131763458251953,
        "orig_time": 0.000492095947265625,
        "time_ratio": 0.4420646819447419,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the name of the race held on the circuits in Germany.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "llm_output": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany';",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany';",
        "pred_time": 0.0013723373413085938,
        "orig_time": 0.0008263587951660156,
        "time_ratio": 0.6021542738012509,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "original_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'",
        "llm_output": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_time": 0.19645047187805176,
        "orig_time": 0.1960282325744629,
        "time_ratio": 0.9978506577278624,
        "check": true
    },
    {
        "id": "financial",
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "original_query": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "llm_output": "\nSELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993' AND T1.frequency = 'POPLATEK PO OBRATU';\n",
        "pred_query": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) = '1993' AND T1.frequency = 'POPLATEK PO OBRATU';",
        "pred_time": 0.0025625228881835938,
        "orig_time": 0.0009760856628417969,
        "time_ratio": 0.3809080759211016,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Which website should I go to if I want to know more about Anthony Davidson?",
        "original_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
        "llm_output": "-- Reasoning\nI need to find the URL for the driver 'Anthony Davidson'.\nThe `drivers` table contains driver information, including their `forename`, `surname`, and `url`.\nI will select the `url` from the `drivers` table where the `forename` is 'Anthony' and the `surname` is 'Davidson'.\n\n-- SQL Query\nSELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "pred_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "pred_time": 0.007584571838378906,
        "orig_time": 0.0008194446563720703,
        "time_ratio": 0.10804099082107381,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
        "original_query": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
        "llm_output": "-- Reasoning\nI need to first identify carcinogenic molecules from the `molecule` table (label is not '-').\nThen, I will join this with the `bond` table to count the number of double bonds (`bond_type` = '=') for each carcinogenic molecule.\nFinally, I will order these molecules by the count of double bonds in descending order and select the `molecule_id` of the top one.\n\n-- SQL Query\nSELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label != '-' AND T2.bond_type = '=' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_type) DESC LIMIT 1;",
        "pred_query": "SELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label != '-' AND T2.bond_type = '=' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_type) DESC LIMIT 1;",
        "pred_time": 0.00220489501953125,
        "orig_time": 0.001741647720336914,
        "time_ratio": 0.7899005190311419,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
        "original_query": "SELECT NCESDist FROM schools WHERE SOC = 31",
        "llm_output": "-- Reasoning\nThe user is asking for the `NCESDist` from the `schools` table.\nThe condition is that the `SOCType` column should be 'State Special Schools'.\nI will select the `NCESDist` column and filter the `schools` table by `SOCType`.\n\n-- SQL Query\nSELECT NCESDist FROM schools WHERE SOCType = 'State Special Schools';",
        "pred_query": "SELECT NCESDist FROM schools WHERE SOCType = 'State Special Schools';",
        "pred_time": 0.010164499282836914,
        "orig_time": 0.007905721664428711,
        "time_ratio": 0.7777777777777778,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List the power of superheroes with height greater than 80% of the average height of all superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm * 100 > ( SELECT AVG(height_cm) FROM superhero ) * 80",
        "llm_output": "-- Reasoning\nI need to first calculate the average height of all superheroes from the `superhero` table.\nThen, I will calculate 80% of this average height.\nNext, I will select superheroes whose height is greater than this 80% threshold.\nFinally, I will join with `hero_power` and `superpower` tables to retrieve the distinct power names for these specific superheroes.\n\n-- SQL Query\nSELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm > (SELECT AVG(height_cm) FROM superhero) * 0.8;",
        "pred_query": "SELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm > (SELECT AVG(height_cm) FROM superhero) * 0.8;",
        "pred_time": 0.0017986297607421875,
        "orig_time": 0.001470327377319336,
        "time_ratio": 0.8174708377518558,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "original_query": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
        "llm_output": "SELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';",
        "pred_query": "SELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';",
        "pred_time": 0.0975484848022461,
        "orig_time": 0.09362101554870605,
        "time_ratio": 0.9597382854126135,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What are the card layout of cards with keyword of flying?",
        "original_query": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "llm_output": "\nSELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%'\n",
        "pred_query": "SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%'",
        "pred_time": 0.059617042541503906,
        "orig_time": 0.058232784271240234,
        "time_ratio": 0.9767808295874458,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "original_query": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "llm_output": "\nSELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\n",
        "pred_query": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "pred_time": 0.006795167922973633,
        "orig_time": 0.0053594112396240234,
        "time_ratio": 0.788709168099365,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "original_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "llm_output": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_time": 0.010504007339477539,
        "orig_time": 0.00853586196899414,
        "time_ratio": 0.8126290941280614,
        "check": true
    }
]