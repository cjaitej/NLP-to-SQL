[
    {
        "id": "european_football_2",
        "question": "Please list all team names which the speed class is fast.",
        "original_query": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "llm_output": "\nSELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast';\n",
        "pred_query": "SELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast';",
        "pred_time": 0.003284454345703125,
        "orig_time": 0.002357959747314453,
        "time_ratio": 0.7179152148664344,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "How many circuits are there in Melbourne, Australia?",
        "original_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia'",
        "llm_output": "\nSELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';\n",
        "pred_query": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';",
        "pred_time": 0.0016758441925048828,
        "orig_time": 0.0012664794921875,
        "time_ratio": 0.7557262768530374,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many Formula_1 races took place on the circuits in Italy?",
        "original_query": "SELECT COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Italy'",
        "llm_output": "\nSELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';\n",
        "pred_query": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy';",
        "pred_time": 0.0017666816711425781,
        "orig_time": 0.0021605491638183594,
        "time_ratio": 1.2229419703103914,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "original_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "llm_output": "-- Reasoning\nI need to count cards that are textless (`isTextless = 1`) and have a 'normal' layout.\nThen, I need to count all cards that have a 'normal' layout.\nFinally, I will divide the count of textless normal-layout cards by the total count of normal-layout cards to get the proportion.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN isTextless = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE layout = 'normal';",
        "pred_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE layout = 'normal';",
        "pred_time": 0.11325645446777344,
        "orig_time": 0.11324191093444824,
        "time_ratio": 0.9998715875983092,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What's the magic card market name for the set which was released on 2017/6/9?",
        "original_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "llm_output": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "pred_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "pred_time": 0.014843940734863281,
        "orig_time": 0.0063402652740478516,
        "time_ratio": 0.4271281721811757,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the percentage of molecules that are carcinogenic?",
        "original_query": "SELECT CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id) FROM molecule t",
        "llm_output": "-- Reasoning\nTo find the percentage of carcinogenic molecules, we need to count the molecules with a '+' label and divide by the total number of molecules.\nBoth counts can be obtained from the `molecule` table.\nWe will cast the count to REAL for accurate percentage calculation.\n\n-- SQL Query\nSELECT CAST(COUNT(CASE WHEN T1.label = '+' THEN T1.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.molecule_id) FROM molecule AS T1;",
        "pred_query": "SELECT CAST(COUNT(CASE WHEN T1.label = '+' THEN T1.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.molecule_id) FROM molecule AS T1;",
        "pred_time": 0.0015287399291992188,
        "orig_time": 0.007910728454589844,
        "time_ratio": 5.17467248908297,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What is the percentage of borderless cards?",
        "original_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
        "llm_output": "-- Reasoning\nTo find the percentage, I need to count all cards and count borderless cards.\nThe `borderColor` column in the `cards` table indicates if a card is 'borderless'.\nI will calculate (count of borderless cards * 100.0) / (total count of cards).\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards;",
        "pred_time": 0.11204218864440918,
        "orig_time": 0.0959327220916748,
        "time_ratio": 0.8562196370167192,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "original_query": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe question asks for the `budget_id` that allocated the most money for specific categories.\nI need to filter the `budget` table by `category` for 'water', 'chips', or 'cookies'.\nThen, I will find the budget with the maximum `amount` among these filtered budgets and return its `budget_id`.\n\n-- SQL Query\nSELECT budget_id FROM budget WHERE category IN ('water', 'chips', 'cookies') ORDER BY amount DESC LIMIT 1;",
        "pred_query": "SELECT budget_id FROM budget WHERE category IN ('water', 'chips', 'cookies') ORDER BY amount DESC LIMIT 1;",
        "pred_time": 0.0016286373138427734,
        "orig_time": 0.0007088184356689453,
        "time_ratio": 0.43522178304787,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "original_query": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "llm_output": "-- Reasoning\nI need to join the Patient and Laboratory tables to get patient sex and TP values.\nThen, I will filter for female patients whose TP is outside the normal range (6.0 to 8.5).\nFinally, I will calculate the deviation using a CASE statement: `6.0 - TP` if TP is below 6.0, and `TP - 8.5` if TP is above 8.5.\n\n-- SQL Query\nSELECT\n  T1.ID,\n  T1.SEX,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0\n    THEN 6.0 - T2.TP\n    WHEN T2.TP > 8.5\n    THEN T2.TP - 8.5\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'F' AND (\n    T2.TP < 6.0 OR T2.TP > 8.5\n  );",
        "pred_query": "SELECT\n  T1.ID,\n  T1.SEX,\n  T2.TP,\n  CASE\n    WHEN T2.TP < 6.0\n    THEN 6.0 - T2.TP\n    WHEN T2.TP > 8.5\n    THEN T2.TP - 8.5\n  END AS TP_Deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T1.SEX = 'F' AND (\n    T2.TP < 6.0 OR T2.TP > 8.5\n  );",
        "pred_time": 0.009371519088745117,
        "orig_time": 0.006507396697998047,
        "time_ratio": 0.6943801358536648,
        "check": false
    },
    {
        "id": "card_games",
        "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
        "original_query": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "llm_output": "-- Reasoning\nTo find the release date of the set containing \"Ancestor's Chosen\", I first need to identify the `setCode` for this card from the `cards` table.\nThen, I will join the `cards` table with the `sets` table using the `setCode` from `cards` and the `code` from `sets`.\nFinally, I will select the `releaseDate` from the `sets` table for the card named \"Ancestor's Chosen\".\n\n-- SQL Query\nSELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor''s Chosen'",
        "pred_query": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor''s Chosen'",
        "pred_time": 0.13648009300231934,
        "orig_time": 0.12632060050964355,
        "time_ratio": 0.9255606274205636,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "original_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
        "llm_output": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Bruno' AND T2.surname = 'Senna' AND T1.raceId = 354;",
        "pred_query": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Bruno' AND T2.surname = 'Senna' AND T1.raceId = 354;",
        "pred_time": 0.01054239273071289,
        "orig_time": 0.0020508766174316406,
        "time_ratio": 0.1945361617440861,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "original_query": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "llm_output": "-- Reasoning\nTo find the free rate for students aged 5-17, I need to query the `frpm` table for the `Percent (%) Eligible Free (Ages 5-17)` column.\nThe school is identified by the administrator's name, which is stored in the `schools` table.\nI will join `frpm` and `schools` tables using their common `CDSCode` column.\nFinally, I'll filter the results based on `AdmFName1` and `AdmLName1` in the `schools` table.\n\n-- SQL Query\nSELECT T1.`Percent (%) Eligible Free (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson';",
        "pred_query": "SELECT T1.`Percent (%) Eligible Free (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Kacey' AND T2.AdmLName1 = 'Gibson';",
        "pred_time": 0.020687103271484375,
        "orig_time": 0.020687580108642578,
        "time_ratio": 1.00002304997234,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "original_query": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "llm_output": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "pred_query": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "pred_time": 0.021913528442382812,
        "orig_time": 0.019019603729248047,
        "time_ratio": 0.8679388980764209,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What's Angela Sanders's major?",
        "original_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
        "llm_output": "-- Reasoning\nTo find Angela Sanders's major, I need to look up her information in the `member` table.\nThen, I will use the `link_to_major` column from the `member` table to join with the `major` table.\nFinally, I will select the `major_name` from the `major` table.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders';",
        "pred_time": 0.0012235641479492188,
        "orig_time": 0.0006735324859619141,
        "time_ratio": 0.5504676539360873,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "llm_output": "-- Reasoning\nTo find patients with normal RNP and hospital admission, I will join `Patient` and `Laboratory` tables on `ID`.\nI will filter `Laboratory.RNP` for values that are not '-' and not '+-', assuming these indicate abnormal levels, thus other values are normal.\nI will filter `Patient.Admission` for non-NULL values to identify admitted patients.\nFinally, I will count distinct patient IDs to get the number of unique patients satisfying both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP NOT IN ('-', '+-') AND T1.Admission IS NOT NULL;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP NOT IN ('-', '+-') AND T1.Admission IS NOT NULL;",
        "pred_time": 0.023439407348632812,
        "orig_time": 0.009439706802368164,
        "time_ratio": 0.40272804947514035,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "original_query": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' THEN 1 ELSE NULL END) FROM cards",
        "llm_output": "-- Reasoning\nI need to count the distinct artists from the 'cards' table.\nThe conditions are that the card must have 'black' as its `borderColor`.\nAdditionally, the card's `availability` must include both 'arena' and 'mtgo'. This implies using LIKE with wildcards for both conditions on the `availability` column.\n\n-- SQL Query\nSELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%';",
        "pred_query": "SELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%';",
        "pred_time": 0.1136319637298584,
        "orig_time": 0.09462118148803711,
        "time_ratio": 0.8326986385009033,
        "check": false
    },
    {
        "id": "superhero",
        "question": "What is the name of the superhero that has the most powers?",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to count the number of powers for each superhero.\nThis requires joining the `superhero` and `hero_power` tables.\nThen, I will group by superhero name and count the powers.\nFinally, I will order by the power count in descending order and take the top one.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.power_id) DESC LIMIT 1;",
        "pred_time": 0.003602266311645508,
        "orig_time": 0.003129243850708008,
        "time_ratio": 0.8686875372294659,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patients whose anti-SSB are normal, how many of them have other symptoms observed in their examination?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Symptoms IS NOT NULL",
        "llm_output": "SELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SSB IN ('negative', '0') AND T2.Symptoms IS NOT NULL AND T2.Symptoms != ''",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SSB IN ('negative', '0') AND T2.Symptoms IS NOT NULL AND T2.Symptoms != ''",
        "pred_time": 0.009292125701904297,
        "orig_time": 0.002095937728881836,
        "time_ratio": 0.22556063016369887,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "original_query": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "llm_output": "-- Reasoning\nTo answer the question, we need to count the number of male and female patients whose creatinine (CRE) levels are not within the normal range.\nBased on the provided few-shot example, `CRE >= 1.5` is considered \"out of the normal range\". We will use this condition.\nWe will count distinct patient IDs for males and females satisfying this condition, and then compare the two counts.\n\n-- SQL Query\nSELECT\n  CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.CRE >= 1.5;",
        "pred_query": "SELECT\n  CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.CRE >= 1.5;",
        "pred_time": 0.006272554397583008,
        "orig_time": 0.005346536636352539,
        "time_ratio": 0.8523699114371508,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the name of students that have attended more than 7 events.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T2.link_to_member HAVING COUNT(T2.link_to_event) > 7",
        "llm_output": "-- Reasoning\nI need to join the `member` table with the `attendance` table to link members to the events they attended.\nThen, I will group the results by member to count the number of events each member attended.\nFinally, I will use a HAVING clause to filter for members who attended more than 7 events and select their names.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7;",
        "pred_time": 0.001975536346435547,
        "orig_time": 0.0010211467742919922,
        "time_ratio": 0.5168959691045136,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many female customers have a junior credit card?",
        "original_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "llm_output": "-- Reasoning\nI need to join the `client`, `disp`, and `card` tables.\nFilter `client` for gender 'F' and `card` for type 'junior'.\nThen, count the distinct `client_id`s to get the number of unique female customers.\n\nSELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior';",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior';",
        "pred_time": 0.001999378204345703,
        "orig_time": 0.0010488033294677734,
        "time_ratio": 0.5245647507751013,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
        "original_query": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
        "llm_output": "-- Reasoning\nThe question asks whether a specific bond (TR001_1_8) connects atoms that include both chlorine ('cl') and carbon ('c') elements.\nA bond connects two specific atoms, which are identified by `atom_id` and `atom_id2` in the `connected` table.\nWe need to join the `connected` table with the `atom` table twice to get the elements for both connected atoms.\nThen, we filter for the given `bond_id` and check if one atom has the element 'cl' and the other has the element 'c'.\nA `CASE` statement with `EXISTS` can be used to return a boolean-like result (1 for true, 0 for false).\n\n-- SQL Query\nSELECT\n  CASE\n    WHEN EXISTS (\n      SELECT\n        1\n      FROM\n        connected AS T1\n        INNER JOIN atom AS A1 ON T1.atom_id = A1.atom_id\n        INNER JOIN atom AS A2 ON T1.atom_id2 = A2.atom_id\n      WHERE\n        T1.bond_id = 'TR001_1_8'\n        AND (\n          (A1.element = 'cl' AND A2.element = 'c')\n          OR (A1.element = 'c' AND A2.element = 'cl')\n        )\n    ) THEN 1\n    ELSE 0\n  END;",
        "pred_query": "SELECT\n  CASE\n    WHEN EXISTS (\n      SELECT\n        1\n      FROM\n        connected AS T1\n        INNER JOIN atom AS A1 ON T1.atom_id = A1.atom_id\n        INNER JOIN atom AS A2 ON T1.atom_id2 = A2.atom_id\n      WHERE\n        T1.bond_id = 'TR001_1_8'\n        AND (\n          (A1.element = 'cl' AND A2.element = 'c')\n          OR (A1.element = 'c' AND A2.element = 'cl')\n        )\n    ) THEN 1\n    ELSE 0\n  END;",
        "pred_time": 0.0042514801025390625,
        "orig_time": 0.0031774044036865234,
        "time_ratio": 0.7473642889187977,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients with a normal Ig G level, how many of them have symptoms?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T2.IGG BETWEEN 900 AND 2000 AND T3.Symptoms IS NOT NULL",
        "llm_output": "-- Reasoning\n-- 1. We need to count distinct patients.\n-- 2. Patients must have a \"normal Ig G level\". Since no specific range for \"normal\" Ig G is provided, we assume \"normal\" refers to any recorded (non-NULL) Ig G value.\n-- 3. Patients must \"have symptoms\". This means the `Symptoms` column in the `Examination` table must not be NULL.\n-- 4. We will join the Patient, Laboratory, and Examination tables on their common ID to apply these filters and count distinct patient IDs.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.IGG IS NOT NULL AND T3.Symptoms IS NOT NULL;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.IGG IS NOT NULL AND T3.Symptoms IS NOT NULL;",
        "pred_time": 0.011660337448120117,
        "orig_time": 0.0016791820526123047,
        "time_ratio": 0.14400801521254625,
        "check": false
    },
    {
        "id": "financial",
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "original_query": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.district_id = ( SELECT district_id FROM client ORDER BY birth_date DESC LIMIT 1 ) ORDER BY T2.A11 DESC LIMIT 1",
        "llm_output": "SELECT T3.account_id FROM client AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id JOIN disp AS T4 ON T1.client_id = T4.client_id JOIN account AS T3 ON T4.account_id = T3.account_id WHERE T1.birth_date = ( SELECT MAX(birth_date) FROM client ) AND T2.A11 = ( SELECT MAX(A11) FROM district );",
        "pred_query": "SELECT T3.account_id FROM client AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id JOIN disp AS T4 ON T1.client_id = T4.client_id JOIN account AS T3 ON T4.account_id = T3.account_id WHERE T1.birth_date = ( SELECT MAX(birth_date) FROM client ) AND T2.A11 = ( SELECT MAX(A11) FROM district );",
        "pred_time": 0.002954244613647461,
        "orig_time": 0.001592874526977539,
        "time_ratio": 0.5391816641110483,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List circuits which host 4 f1 races from year 1990 to 2000.",
        "original_query": "SELECT DISTINCT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.name HAVING COUNT(T2.raceId) = 4",
        "llm_output": "-- Reasoning\nI need to count the number of races for each circuit within the specified year range (1990-2000).\nFirst, I will filter the `races` table for years between 1990 and 2000.\nThen, I will group these races by `circuitId` and count them.\nFinally, I will filter these groups to find circuits with exactly 4 races and retrieve their names from the `circuits` table.\n\n-- SQL Query\nSELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year >= 1990 AND T2.year <= 2000 GROUP BY T1.circuitId HAVING COUNT(T2.raceId) = 4;",
        "pred_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year >= 1990 AND T2.year <= 2000 GROUP BY T1.circuitId HAVING COUNT(T2.raceId) = 4;",
        "pred_time": 0.0024428367614746094,
        "orig_time": 0.0015354156494140625,
        "time_ratio": 0.628537966035526,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to count the number of superheroes for 'DC Comics' and 'Marvel Comics' separately.\nThen, I will calculate the difference between these two counts to determine which publisher has more superheroes and by how many.\nThe query will involve joining the `superhero` table with the `publisher` table and using subqueries or conditional aggregation to get the counts.\n\n-- SQL Query\nSELECT\n  SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) -\n  SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_query": "SELECT\n  SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) -\n  SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)\nFROM superhero AS T1\nINNER JOIN publisher AS T2\n  ON T1.publisher_id = T2.id\nWHERE\n  T2.publisher_name IN ('DC Comics', 'Marvel Comics');",
        "pred_time": 0.002077817916870117,
        "orig_time": 0.0015382766723632812,
        "time_ratio": 0.740332759609868,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Please list the names of the badges obtained by csgillespie.",
        "original_query": "SELECT T1.`Name` FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "llm_output": "-- Reasoning\nI need to retrieve badge names (`Name` from `badges` table).\nThe badges are associated with users via the `UserId` column in the `badges` table and the `Id` column in the `users` table.\nI will join `badges` and `users` tables and filter by the `DisplayName` 'csgillespie' from the `users` table.\n\nSELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_query": "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie';",
        "pred_time": 0.13720440864562988,
        "orig_time": 0.11488175392150879,
        "time_ratio": 0.8373036628744502,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "original_query": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "llm_output": "\nSELECT T2.team_long_name FROM Match AS T1 INNER JOIN Team AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN League AS T3 ON T1.league_id = T3.id WHERE T3.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T2.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1;\n",
        "pred_query": "SELECT T2.team_long_name FROM Match AS T1 INNER JOIN Team AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN League AS T3 ON T1.league_id = T3.id WHERE T3.name = 'Scotland Premier League' AND T1.season = '2010/2011' AND T1.away_team_goal > T1.home_team_goal GROUP BY T2.team_long_name ORDER BY COUNT(T1.id) DESC LIMIT 1;",
        "pred_time": 0.09252548217773438,
        "orig_time": 0.09346151351928711,
        "time_ratio": 1.0101164708307566,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the bond type for atoms with element Tin?",
        "original_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "llm_output": "-- Reasoning\nI need to find the bond types connected to atoms with the element 'Tin'.\nFirst, I will filter the `atom` table for atoms where the `element` is 'Tin'.\nThen, I will join `atom` with `connected` on `atom_id` to identify the bonds these Tin atoms are part of.\nFinally, I will join `connected` with `bond` on `bond_id` to retrieve the `bond_type` and ensure distinct results.\n\n-- SQL Query\nSELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Tin';",
        "pred_query": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 'Tin';",
        "pred_time": 0.025613069534301758,
        "orig_time": 0.02557682991027832,
        "time_ratio": 0.9985851120274786,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "original_query": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "llm_output": "SELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "pred_query": "SELECT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "pred_time": 0.7541329860687256,
        "orig_time": 0.6846201419830322,
        "time_ratio": 0.9078241565217007,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "llm_output": "-- Reasoning\nThe question asks for a count of examinations.\nI need to filter the `Examination` table based on two conditions:\n1. The `Examination Date` column should be after '1997-01-01'.\n2. The `KCT` column, which represents the \"inactivated partial prothrombin time\" result, should not be NULL.\nFinally, I will count the number of rows that satisfy these conditions.\n\n-- SQL Query\nSELECT COUNT(ID) FROM Examination WHERE `Examination Date` > '1997-01-01' AND KCT IS NOT NULL;",
        "pred_query": "SELECT COUNT(ID) FROM Examination WHERE `Examination Date` > '1997-01-01' AND KCT IS NOT NULL;",
        "pred_time": 0.001210927963256836,
        "orig_time": 0.005898237228393555,
        "time_ratio": 4.870840716676511,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'Owner' AND T1.frequency = 'POPLATEK TYDNE'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the `client`, `disp`, and `account` tables.\nI will filter the `account` table for 'POPLATEK TYDNE' frequency and the `disp` table for 'OWNER' type.\nFinally, I will count the distinct `client_id` to get the number of matching customers.\n\n-- SQL Query\nSELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_query": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER';",
        "pred_time": 0.003520965576171875,
        "orig_time": 0.0011310577392578125,
        "time_ratio": 0.32123510292524377,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "How many users received commentator badges in 2014?",
        "original_query": "SELECT COUNT(Id) FROM badges WHERE Name = 'Commentator' AND STRFTIME('%Y', Date) = '2014'",
        "llm_output": "-- Reasoning\nI need to count the number of unique users from the `badges` table.\nThe `badges` table contains information about badges, including the `UserId`, `Name`, and `Date`.\nI will filter for badges with `Name` equal to 'commentator' and `Date` within the year 2014.\nFinally, I will count the distinct `UserId` values that satisfy these conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'commentator' AND STRFTIME('%Y', Date) = '2014';",
        "pred_query": "SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'commentator' AND STRFTIME('%Y', Date) = '2014';",
        "pred_time": 0.013443470001220703,
        "orig_time": 0.01267099380493164,
        "time_ratio": 0.9425389281027206,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "How many users are awarded with more than 5 badges?",
        "original_query": "SELECT UserId FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "llm_output": "-- Reasoning\nI need to count the badges per user.\nI will group the `badges` table by `UserId` and count the `Id`s.\nThen, I will filter these groups to include only those where the count is greater than 5.\nFinally, I will count the number of distinct `UserId`s that satisfy this condition.\n\n-- SQL Query\nSELECT COUNT(T1.UserId) FROM badges AS T1 GROUP BY T1.UserId HAVING COUNT(T1.Id) > 5;",
        "pred_query": "SELECT COUNT(T1.UserId) FROM badges AS T1 GROUP BY T1.UserId HAVING COUNT(T1.Id) > 5;",
        "pred_time": 0.05384993553161621,
        "orig_time": 0.05586123466491699,
        "time_ratio": 1.0373500750454923,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "original_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "llm_output": "-- Reasoning\nI need to find posts that were edited by a specific user.\nThe `posts` table contains `LastEditorUserId` which refers to the `Id` in the `users` table.\nI will join `posts` and `users` on these columns and filter by the `DisplayName` of the user.\n\n-- SQL Query\nSELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_query": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa';",
        "pred_time": 0.2603919506072998,
        "orig_time": 0.3490180969238281,
        "time_ratio": 1.340356704997331,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What percentage of cards without power are in French?",
        "original_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power LIKE '%*%'",
        "llm_output": "-- Reasoning\nThe question asks for the percentage of cards that meet two criteria:\n1. They do not have a 'power' value (interpreted as `power IS NULL` in the `cards` table).\n2. They are available in French (meaning an entry exists in the `foreign_data` table with `language = 'French'` for that card's `uuid`).\n\nTo calculate this percentage, we need:\n- The count of unique cards that satisfy both conditions (numerator).\n- The total count of unique cards (denominator).\n\nWe will join the `cards` table with a subquery that identifies unique `uuid`s for cards available in French. Then, we use conditional aggregation to count cards meeting the combined criteria and divide by the total number of cards.\n\n-- SQL Query\nSELECT\n  CAST(SUM(CASE WHEN T1.power IS NULL AND T2_french.uuid IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100\n  / COUNT(T1.uuid)\nFROM cards AS T1\nLEFT JOIN (SELECT DISTINCT uuid FROM foreign_data WHERE language = 'French') AS T2_french\n  ON T1.uuid = T2_french.uuid;",
        "pred_query": "SELECT\n  CAST(SUM(CASE WHEN T1.power IS NULL AND T2_french.uuid IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100\n  / COUNT(T1.uuid)\nFROM cards AS T1\nLEFT JOIN (SELECT DISTINCT uuid FROM foreign_data WHERE language = 'French') AS T2_french\n  ON T1.uuid = T2_french.uuid;",
        "pred_time": 0.4339566230773926,
        "orig_time": 0.5849530696868896,
        "time_ratio": 1.3479528565290917,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "original_query": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "llm_output": "-- Reasoning\nTo find players who tend to be attacking, I need to look at the `Player_Attributes` table and filter by `attacking_work_rate`.\nAn 'attacking' work rate is typically represented by 'high'.\nI will join `Player_Attributes` with the `Player` table on `player_api_id` to retrieve the `player_name`.\nI will use `DISTINCT` to ensure each player's name is listed only once.\n\n-- SQL Query\nSELECT DISTINCT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high';",
        "pred_query": "SELECT DISTINCT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high';",
        "pred_time": 0.18644046783447266,
        "orig_time": 0.18822383880615234,
        "time_ratio": 1.0095653641743862,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "llm_output": "-- Reasoning\nI need to join the `event` table with the `attendance` table to find the members who attended a specific event.\nThen, I will join the result with the `member` table to retrieve the full names of those members.\nFinally, I will filter for the event named 'Laugh Out Loud' and concatenate the first and last names.\n\n-- SQL Query\nSELECT T3.first_name || ' ' || T3.last_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Laugh Out Loud';",
        "pred_query": "SELECT T3.first_name || ' ' || T3.last_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Laugh Out Loud';",
        "pred_time": 0.0014562606811523438,
        "orig_time": 0.0008654594421386719,
        "time_ratio": 0.5943025540275049,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "llm_output": "-- Reasoning\nTo find the expansion type for the set containing \"Samite Pilgrim\", I first need to locate the card in the 'cards' table to get its 'setCode'.\nThen, I will use this 'setCode' to join with the 'sets' table.\nFinally, I will select the 'type' column from the 'sets' table, which represents the expansion type.\n\n-- SQL Query\nSELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'",
        "pred_query": "SELECT T2.type FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Samite Pilgrim'",
        "pred_time": 0.11428999900817871,
        "orig_time": 0.10344648361206055,
        "time_ratio": 0.9051227973556795,
        "check": true
    },
    {
        "id": "card_games",
        "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
        "llm_output": "-- Reasoning\nThe user wants to count cards based on three criteria from the 'cards' table.\n1. \"color cards\": Filter for cards where the 'colors' column is not empty or null.\n2. \"no borders\": Filter for cards where the 'borderColor' is 'borderless'.\n3. \"ranked higher than 12000 on EDHRec\": Filter for cards where 'edhrecRank' is less than 12000 (a lower number indicates a higher rank).\n\n-- SQL Query\nSELECT COUNT(id) FROM cards WHERE colors IS NOT NULL AND colors != '' AND borderColor = 'borderless' AND edhrecRank IS NOT NULL AND edhrecRank < 12000;",
        "pred_query": "SELECT COUNT(id) FROM cards WHERE colors IS NOT NULL AND colors != '' AND borderColor = 'borderless' AND edhrecRank IS NOT NULL AND edhrecRank < 12000;",
        "pred_time": 0.11643242835998535,
        "orig_time": 0.09668159484863281,
        "time_ratio": 0.8303665586164106,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Calculate the average height of all neutral superheroes.",
        "original_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `alignment` table on their respective ID columns.\nThen, I will filter the results to include only those superheroes where the alignment is 'Neutral'.\nFinally, I will calculate the average of the `height_cm` column for these filtered superheroes.\n\n-- SQL Query\nSELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_query": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral';",
        "pred_time": 0.001936197280883789,
        "orig_time": 0.0008673667907714844,
        "time_ratio": 0.44797438739071543,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the date when the youngest user made his or her first post?",
        "original_query": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "llm_output": "-- Reasoning\nFirst, identify the Id of the youngest user by finding the minimum age in the `users` table.\nThen, use this UserId to filter posts in the `posts` table.\nFinally, from the filtered posts, find the minimum `CreaionDate` to determine their first post date.\n\n-- SQL Query\nSELECT MIN(T1.CreaionDate)\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  T2.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );",
        "pred_query": "SELECT MIN(T1.CreaionDate)\nFROM posts AS T1\nINNER JOIN users AS T2\n  ON T1.OwnerUserId = T2.Id\nWHERE\n  T2.Age = (\n    SELECT\n      MIN(Age)\n    FROM users\n  );",
        "pred_time": 0.3738586902618408,
        "orig_time": 0.34320902824401855,
        "time_ratio": 0.9180180565112555,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
        "original_query": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
        "llm_output": "-- Reasoning\nTo find cards that are promotional paintings, I need to filter `cards` where `isPromo` is 1.\nTo identify cards with multiple faces on the same card, I need to check where the `side` column is not NULL.\nFinally, I will select the `name` column from the filtered results.\n\nSELECT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL;",
        "pred_query": "select the `name` column from the filtered results.\n\nSELECT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL;",
        "pred_time": null,
        "orig_time": 0.11661601066589355,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
        "llm_output": "-- Reasoning\nTo answer this question, I need to retrieve information from both the `Patient` and `Laboratory` tables.\nThe `Patient` table contains `ID`, `SEX`, and `Diagnosis`.\nThe `Laboratory` table contains `ALB` (albumin level) and `ID`.\nI will join these two tables on their common `ID` column and then filter for records where `ALB` is less than 3.5.\n\n-- SQL Query\nSELECT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5;",
        "pred_query": "SELECT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5;",
        "pred_time": 0.014227867126464844,
        "orig_time": 0.01101827621459961,
        "time_ratio": 0.7744151752798445,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Which foot is preferred by Abdou Diallo?",
        "original_query": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "llm_output": "-- Reasoning\nTo find the preferred foot of 'Abdou Diallo', I need to join the 'Player' table (to get the player's name) with the 'Player_Attributes' table (to get the preferred foot).\nI will join these tables using `player_api_id`.\nFinally, I will filter the results by `player_name` = 'Abdou Diallo' and select the `preferred_foot`.\n\n-- SQL Query\nSELECT T2.preferred_foot FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Abdou Diallo' LIMIT 1;",
        "pred_query": "SELECT T2.preferred_foot FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Abdou Diallo' LIMIT 1;",
        "pred_time": 0.0029218196868896484,
        "orig_time": 0.20317530632019043,
        "time_ratio": 69.53725010199918,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "original_query": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "llm_output": "-- Reasoning\nI need to count the number of 'discount' gas stations in the Czech Republic.\nThen, I need to count the number of 'discount' gas stations in Slovakia.\nFinally, I will subtract the count for Slovakia from the count for the Czech Republic to find the difference.\n\n-- SQL Query\nSELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'discount';",
        "pred_query": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'discount';",
        "pred_time": 0.0020787715911865234,
        "orig_time": 0.0012309551239013672,
        "time_ratio": 0.5921550636540888,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "original_query": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "ite\nSELECT T2.nationality FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 933 AND T1.fastestLapSpeed IS NOT NULL ORDER BY T1.fastestLapSpeed DESC LIMIT 1\n",
        "pred_query": "SELECT T2.nationality FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 933 AND T1.fastestLapSpeed IS NOT NULL ORDER BY T1.fastestLapSpeed DESC LIMIT 1",
        "pred_time": 0.004350900650024414,
        "orig_time": 0.0029850006103515625,
        "time_ratio": 0.6860649898624582,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "llm_output": "-- Reasoning\nI need to select the superhero names from the 'superhero' table.\nTo filter by eye and hair colour, I must join the 'superhero' table with the 'colour' table twice, once for 'eye_colour_id' and once for 'hair_colour_id'.\nFinally, I will apply conditions to filter for 'Blue' eyes and 'Blond' hair.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond';",
        "pred_time": 0.0026140213012695312,
        "orig_time": 0.001451253890991211,
        "time_ratio": 0.5551805910251733,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What is the highest amount of budget spend for an event?",
        "original_query": "SELECT MAX(spent) FROM budget",
        "llm_output": "\nSELECT MAX(spent) FROM budget;\n",
        "pred_query": "SELECT MAX(spent) FROM budget;",
        "pred_time": 0.0013506412506103516,
        "orig_time": 0.0006618499755859375,
        "time_ratio": 0.49002647837599295,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the owner's display name of the most popular post?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = ( SELECT OwnerUserId FROM posts ORDER BY ViewCount DESC LIMIT 1 )",
        "llm_output": "-- Reasoning\nThe most popular post can be identified by the highest `ViewCount` in the `posts` table.\nOnce the post with the maximum `ViewCount` is found, its `OwnerUserId` can be retrieved.\nFinally, join the `posts` table with the `users` table on `OwnerUserId` to get the `DisplayName` of the owner.\n\n-- SQL Query\nSELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.ViewCount DESC LIMIT 1;",
        "pred_query": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY T1.ViewCount DESC LIMIT 1;",
        "pred_time": 0.40262389183044434,
        "orig_time": 0.24512720108032227,
        "time_ratio": 0.6088242800642141,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "original_query": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to first identify patients who had lab work done within the specified date range (1985-01-01 to 1995-12-31) using the `Laboratory` table.\nThen, I will join these patient IDs with the `Examination` table to retrieve their diagnoses.\nFinally, I will count the occurrences of each diagnosis and find the one with the highest count.\n\nSELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1;",
        "pred_query": "SELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1;",
        "pred_time": 0.0023288726806640625,
        "orig_time": 0.001165628433227539,
        "time_ratio": 0.5005118755118755,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which is the most valuable post in 2010? Please give its id and the owner's display name.",
        "original_query": "SELECT T2.OwnerUserId, T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T1.CreationDate) = '2010' ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find posts created in 2010 and determine the one with the highest `FavoriteCount`.\nThen, I will select its `Id` from the `posts` table and join with the `users` table on `OwnerUserId` to get the `DisplayName`.\nI will order by `FavoriteCount` in descending order and limit to 1 to get the most valuable post.\n\n-- SQL Query\nSELECT T1.Id, T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE STRFTIME('%Y', T1.CreaionDate) = '2010' ORDER BY T1.FavoriteCount DESC LIMIT 1;",
        "pred_query": "SELECT T1.Id, T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE STRFTIME('%Y', T1.CreaionDate) = '2010' ORDER BY T1.FavoriteCount DESC LIMIT 1;",
        "pred_time": 0.22830772399902344,
        "orig_time": 0.374802827835083,
        "time_ratio": 1.6416563630439687,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "llm_output": "\nSELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition';\n",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition';",
        "pred_time": 0.14785242080688477,
        "orig_time": 0.1510303020477295,
        "time_ratio": 1.0214936030367434,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What is the carcinogenic label for bond TR001_2_4?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
        "llm_output": "-- Reasoning\nThe question asks for the carcinogenic label related to a specific bond.\nI need to join the `bond` table with the `molecule` table using `molecule_id`.\nThen, I will filter for the given `bond_id` and select the `label` from the `molecule` table.\n\n-- SQL Query\nSELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_query": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4';",
        "pred_time": 0.0013341903686523438,
        "orig_time": 0.002090930938720703,
        "time_ratio": 1.567190850607577,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "How was the build up play dribbling class for \"LEI\" on 2015/9/10?",
        "original_query": "SELECT t2.buildUpPlayDribblingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'LEI' AND SUBSTR(t2.`date`, 1, 10) = '2015-09-10'",
        "llm_output": "\nSELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.`date`, 1, 10) = '2015-09-10';\n",
        "pred_query": "SELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND SUBSTR(T2.`date`, 1, 10) = '2015-09-10';",
        "pred_time": 0.0033223628997802734,
        "orig_time": 0.002190113067626953,
        "time_ratio": 0.6592034445640473,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many positive comments are there on the list?",
        "original_query": "SELECT COUNT(id) FROM comments WHERE score > 60",
        "llm_output": "-- Reasoning\nTo find the number of positive comments, I need to query the `comments` table.\nThe `Score` column in the `comments` table indicates the score of a comment.\nA \"positive comment\" can be interpreted as a comment with a `Score` greater than 0.\nI will count the rows in the `comments` table where `Score` is greater than 0.\n\n-- SQL Query\nSELECT COUNT(Id) FROM comments WHERE Score > 0;",
        "pred_query": "SELECT COUNT(Id) FROM comments WHERE Score > 0;",
        "pred_time": 0.08947300910949707,
        "orig_time": 0.07341241836547852,
        "time_ratio": 0.8204979255323401,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 10?",
        "original_query": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 10 AND T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nI need to count the number of distinct sets.\nA set is considered if it has an Italian translation, which requires joining `sets` with `set_translations` and filtering by `language = 'Italian'`.\nAdditionally, the set's `baseSetSize` must be less than 10.\nAfter applying these filters, I will count the distinct `setCode` from the `sets` table.\n\n-- SQL Query\nSELECT COUNT(T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_query": "SELECT COUNT(T1.code) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian' AND T1.baseSetSize < 10;",
        "pred_time": 0.002281665802001953,
        "orig_time": 0.0014650821685791016,
        "time_ratio": 0.642110762800418,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were adult?",
        "original_query": "SELECT COUNT(id) FROM users WHERE Age BETWEEN 19 AND 65",
        "llm_output": "-- Reasoning\nThe question asks to count the number of users who are adults.\nThe `users` table contains the `Age` column for each user.\nAn adult is generally defined as someone with an age of 18 or greater.\nI need to filter the `users` table for `Age >= 18` and then count the resulting rows.\n\n-- SQL Query\nSELECT COUNT(Id) FROM users WHERE Age >= 18;",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Age >= 18;",
        "pred_time": 0.014705657958984375,
        "orig_time": 0.012813568115234375,
        "time_ratio": 0.8713359273670558,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "original_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find cards that belong to the set named 'Coldsnap'.\nI will join the 'cards' table with the 'sets' table using `setCode` and `code`.\nThen, I will filter the results for `sets.name` = 'Coldsnap'.\nFinally, I will order the results by `convertedManaCost` in descending order and take the `name` of the top card(s).\n\n-- SQL Query\nSELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1;",
        "pred_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1;",
        "pred_time": 0.1225433349609375,
        "orig_time": 0.11630582809448242,
        "time_ratio": 0.9490995828663927,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "original_query": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "llm_output": "SELECT T1.AdmFName, T1.District FROM (SELECT AdmFName1 AS AdmFName, District FROM schools UNION ALL SELECT AdmFName2 AS AdmFName, District FROM schools UNION ALL SELECT AdmFName3 AS AdmFName, District FROM schools) AS T1 WHERE T1.AdmFName IS NOT NULL AND T1.AdmFName != '' GROUP BY T1.AdmFName, T1.District ORDER BY COUNT(*) DESC LIMIT 2;",
        "pred_query": "SELECT T1.AdmFName, T1.District FROM (SELECT AdmFName1 AS AdmFName, District FROM schools UNION ALL SELECT AdmFName2 AS AdmFName, District FROM schools UNION ALL SELECT AdmFName3 AS AdmFName, District FROM schools) AS T1 WHERE T1.AdmFName IS NOT NULL AND T1.AdmFName != '' GROUP BY T1.AdmFName, T1.District ORDER BY COUNT(*) DESC LIMIT 2;",
        "pred_time": 0.05413532257080078,
        "orig_time": 0.04964590072631836,
        "time_ratio": 0.9170703778736897,
        "check": false
    },
    {
        "id": "financial",
        "question": "List the top ten districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "original_query": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 10",
        "llm_output": "-- Reasoning\nI need to count the number of female clients per district.\nI will filter the `client` table for `gender = 'F'`.\nThen, I will group the results by `district_id` and count the female clients.\nFinally, I will order by this count in descending order and limit to the top 10.\n\n-- SQL Query\nSELECT district_id, COUNT(client_id) AS female_account_holders\nFROM client\nWHERE gender = 'F'\nGROUP BY district_id\nORDER BY female_account_holders DESC\nLIMIT 10;",
        "pred_query": "SELECT district_id, COUNT(client_id) AS female_account_holders\nFROM client\nWHERE gender = 'F'\nGROUP BY district_id\nORDER BY female_account_holders DESC\nLIMIT 10;",
        "pred_time": 0.002908468246459961,
        "orig_time": 0.002797842025756836,
        "time_ratio": 0.9619640954176572,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01'",
        "llm_output": "-- Reasoning\nI need to count distinct patients.\nPatients should have an IgA level between 80 and 500 (inclusive, based on the first few-shot example's context of \"normal range\").\nPatients' first admission date should be after '1990-01-01'.\nI will join Patient and Laboratory tables on ID.\n\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND T1.`First Date` > '1990-01-01';",
        "pred_time": 0.006525754928588867,
        "orig_time": 0.005738258361816406,
        "time_ratio": 0.8793248328522889,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "original_query": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "llm_output": "\nSELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.country NOT IN ('Asia', 'Europe');\n",
        "pred_query": "SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.country NOT IN ('Asia', 'Europe');",
        "pred_time": 0.001661062240600586,
        "orig_time": 0.000986337661743164,
        "time_ratio": 0.5937993397445098,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List out top 10 Spanish drivers who were born before 1982 and have the latest lap time.",
        "original_query": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'Spanish' AND STRFTIME('%Y', T2.dob) < '1982' ORDER BY T1.time DESC LIMIT 10",
        "llm_output": "\nSELECT T1.driverId FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId WHERE T1.nationality = 'Spanish' AND STRFTIME('%Y', T1.dob) < '1982' ORDER BY T2.milliseconds DESC LIMIT 10\n",
        "pred_query": "SELECT T1.driverId FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId WHERE T1.nationality = 'Spanish' AND STRFTIME('%Y', T1.dob) < '1982' ORDER BY T2.milliseconds DESC LIMIT 10",
        "pred_time": 0.5225796699523926,
        "orig_time": 0.009760379791259766,
        "time_ratio": 0.018677304825403834,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "llm_output": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "pred_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "pred_time": 0.9141819477081299,
        "orig_time": 0.26741766929626465,
        "time_ratio": 0.2925212754054982,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Which customer paid the most in 2012/8/25?",
        "original_query": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the customer who paid the most on '2012-08-25'.\nI will join `transactions_1k` with `customers` to get customer details, though only `CustomerID` is needed from `transactions_1k`.\nI will filter the transactions by the given date, then group by CustomerID and sum the prices.\nFinally, I will order the results by the total price in descending order and pick the top one.\n\n-- SQL Query\nSELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1;",
        "pred_query": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1;",
        "pred_time": 0.0034356117248535156,
        "orig_time": 0.0010962486267089844,
        "time_ratio": 0.3190839694656489,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with severe thrombosis have a normal prothrombin time?",
        "original_query": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.PT < 14 AND T3.Thrombosis < 3 AND T3.Thrombosis > 0",
        "llm_output": "-- Reasoning\nTo answer this question, I need to combine information from the `Examination` and `Laboratory` tables using the common `ID` column.\nI need to filter for patients with `Thrombosis = 5` (assuming 5 represents severe thrombosis based on common scaling where 3 was 'mild' in examples) from the `Examination` table.\nI also need to filter for patients with `PT < 14` (normal prothrombin time based on examples) from the `Laboratory` table.\nFinally, I will count the distinct patient IDs that satisfy both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Thrombosis = 5 AND T2.PT < 14;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Thrombosis = 5 AND T2.PT < 14;",
        "pred_time": 0.001565694808959961,
        "orig_time": 0.001901388168334961,
        "time_ratio": 1.2144053601340032,
        "check": false
    },
    {
        "id": "student_club",
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "original_query": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "llm_output": "-- Reasoning\nI need to retrieve the last names of members.\nMembers are linked to majors via `link_to_major` in the `member` table and `major_id` in the `major` table.\nI will join `member` and `major` tables and filter by `major_name` = 'Law and Constitutional Studies'.\n\n-- SQL Query\nSELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';",
        "pred_query": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies';",
        "pred_time": 0.0018041133880615234,
        "orig_time": 0.00762629508972168,
        "time_ratio": 4.227170609224263,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the average loan amount by male borrowers?",
        "original_query": "SELECT AVG(T3.amount) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M'",
        "llm_output": "-- Reasoning\nI need to find the average of the 'amount' from the `loan` table.\nTo filter by male borrowers, I must link `loan` to `client` via `account` and `disp` tables.\nI will join `loan` with `disp` on `account_id`, and then `disp` with `client` on `client_id`, and finally filter by `gender = 'M'`.\n\n-- SQL Query\nSELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.gender = 'M';",
        "pred_query": "SELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.gender = 'M';",
        "pred_time": 0.018899917602539062,
        "orig_time": 0.009260416030883789,
        "time_ratio": 0.489971238268241,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "List out of players whose preferred foot is left.",
        "original_query": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "llm_output": "-- Reasoning\nThe question asks for the names of players whose preferred foot is 'left'.\nThe `Player` table contains `player_name` and `player_api_id`.\nThe `Player_Attributes` table contains `preferred_foot` and `player_api_id`.\nI need to join these two tables on `player_api_id` and filter for `preferred_foot = 'left'`, then select the player names.\n\n-- SQL Query\nSELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot = 'left';",
        "pred_query": "SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot = 'left';",
        "pred_time": 0.16648507118225098,
        "orig_time": 0.1394517421722412,
        "time_ratio": 0.8376231044739356,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many white bordered cards are powerful?",
        "original_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to count cards from the `cards` table.\nThe conditions are that the `borderColor` must be 'white'.\nA card is considered 'powerful' if its `power` attribute is not NULL and does not contain a '*' character (which typically denotes unknown or variable power).\n\n-- SQL Query\nSELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND power IS NOT NULL AND power NOT LIKE '%*%';",
        "pred_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND power IS NOT NULL AND power NOT LIKE '%*%';",
        "pred_time": 0.10904788970947266,
        "orig_time": 0.10012364387512207,
        "time_ratio": 0.9181621408894136,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Which student has the hometown of Lincolnton, North Carolina with the zip code of 28092? List their full name and position.",
        "original_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092",
        "llm_output": "-- Reasoning\nThe question asks for the full name and position of a student based on their hometown and zip code.\nI need to join the `member` table with the `zip_code` table using the `zip` and `zip_code` columns, respectively.\nThen, I will filter the results by `city` = 'Lincolnton', `state` = 'North Carolina', and `zip_code` = 28092 from the `zip_code` table.\nFinally, I will select the `first_name`, `last_name`, and `position` from the `member` table.\n\n-- SQL Query\nSELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092;",
        "pred_query": "SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092;",
        "pred_time": 0.0023996829986572266,
        "orig_time": 0.0011348724365234375,
        "time_ratio": 0.47292598112270245,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Give the eye colour of Blackwulf.",
        "original_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf'",
        "llm_output": "-- Reasoning\nTo find the eye colour of Blackwulf, I need to retrieve the `superhero_name` from the `superhero` table and join it with the `colour` table on `eye_colour_id`.\nFinally, I will filter the results where `superhero_name` is 'Blackwulf' and select the `colour`.\n\n-- SQL Query\nSELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_query": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf';",
        "pred_time": 0.0014374256134033203,
        "orig_time": 0.0013606548309326172,
        "time_ratio": 0.9465914745397247,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients with a normal anti-SSA came to the hospital before 1990?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND STRFTIME('%Y', T2.Date) < '1990'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the Patient and Laboratory tables using their common ID.\nI will filter for patients whose anti-SSA result is considered 'normal' (negative or 0) in the Laboratory table.\nThen, I will filter for patients whose 'First Date' in the Patient table is before '1990-01-01'.\nFinally, I will count the distinct patient IDs that satisfy both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND T1.`First Date` < '1990-01-01';",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('negative', '0') AND T1.`First Date` < '1990-01-01';",
        "pred_time": 0.003556966781616211,
        "orig_time": 0.00803828239440918,
        "time_ratio": 2.259869964474831,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "State the racing year which has the fastest lap time?",
        "original_query": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "llm_output": "-- Reasoning\nI need to find the fastest lap time from the `lapTimes` table, which is indicated by the minimum `milliseconds`.\nThen I need to join `lapTimes` with the `races` table on `raceId` to get the `year` of that race.\nFinally, I will select the `year` for the race that has the minimum `milliseconds` value.\n\nSELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId ORDER BY T1.milliseconds ASC LIMIT 1",
        "pred_query": "select the `year` for the race that has the minimum `milliseconds` value.\n\nSELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId ORDER BY T1.milliseconds ASC LIMIT 1",
        "pred_time": null,
        "orig_time": 0.009618043899536133,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "superhero",
        "question": "How many green-skinned villains are there in the superhero universe?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "llm_output": "-- Reasoning\nTo find the number of green-skinned villains, I need to join the `superhero` table with the `colour` table on `skin_colour_id` and with the `alignment` table on `alignment_id`.\nThen, I will filter the results where the `colour` is 'Green' and the `alignment` is 'Bad'.\nFinally, I will count the distinct superhero IDs that satisfy these conditions.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.colour = 'Green' AND T3.alignment = 'Bad';",
        "pred_time": 0.0015859603881835938,
        "orig_time": 0.000850677490234375,
        "time_ratio": 0.5363800360793747,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "original_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
        "llm_output": "\nSELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;\n",
        "pred_query": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;",
        "pred_time": 0.10799026489257812,
        "orig_time": 0.10438847541809082,
        "time_ratio": 0.9666470910311209,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "original_query": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "llm_output": "-- Reasoning\nThe query needs to retrieve `event_name` from the `event` table.\nIt must filter events where the `status` is 'Closed'.\nIt also needs to filter where `event_name` contains \"game\".\nFinally, the `event_date` must fall within the specified range, which requires parsing the date string to 'YYYY-MM-DD' format for comparison.\n\n-- SQL Query\nSELECT event_name FROM event WHERE status = 'Closed' AND event_name LIKE '%game%' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_query": "SELECT event_name FROM event WHERE status = 'Closed' AND event_name LIKE '%game%' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20';",
        "pred_time": 0.0015790462493896484,
        "orig_time": 0.0010004043579101562,
        "time_ratio": 0.6335497508681867,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "List down top 5 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "original_query": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 5",
        "llm_output": "-- Reasoning\nI need to join the `drivers` table with the `pitStops` table.\nFilter drivers by `nationality = 'German'` and `dob` year between 1980 and 1985.\nCalculate the average `milliseconds` from the `pitStops` table for each filtered driver.\nOrder the results by this average duration in ascending order and take the top 5.\n\nSELECT\n  T1.driverRef\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds)\nLIMIT 5;",
        "pred_query": "SELECT\n  T1.driverRef\nFROM drivers AS T1\nINNER JOIN pitStops AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  T1.nationality = 'German' AND STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1985'\nGROUP BY\n  T1.driverId\nORDER BY\n  AVG(T2.milliseconds)\nLIMIT 5;",
        "pred_time": 0.0035278797149658203,
        "orig_time": 0.002690553665161133,
        "time_ratio": 0.7626545921470569,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "original_query": "SELECT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "llm_output": "-- Reasoning\nI need to find the `CustomerID` from the `transactions_1k` table based on the provided `Date` and `Time`.\nThen, I will join `transactions_1k` with the `customers` table using `CustomerID` to retrieve the `Currency`.\n\n-- SQL Query\nSELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00';",
        "pred_query": "SELECT T2.Currency FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00';",
        "pred_time": 0.008502721786499023,
        "orig_time": 0.0025386810302734375,
        "time_ratio": 0.29857275046967446,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Count the fastest superheroes.",
        "original_query": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' ORDER BY T1.attribute_value DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the fastest superheroes, I need to identify the 'Speed' attribute and its maximum value.\nI will join `superhero`, `hero_attribute`, and `attribute` tables.\nThen, I will filter for attribute_name 'Speed' and find the maximum attribute_value.\nFinally, I will count the superheroes that possess this maximum 'Speed' attribute value.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' AND T2.attribute_value = (SELECT MAX(T2.attribute_value) FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed');",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' AND T2.attribute_value = (SELECT MAX(T2.attribute_value) FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed');",
        "pred_time": 0.003926992416381836,
        "orig_time": 0.0011835098266601562,
        "time_ratio": 0.3013781798312185,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "original_query": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "llm_output": "\nSELECT DISTINCT\n  T1.frameVersion,\n  T1.name\nFROM cards AS T1\nINNER JOIN legalities AS T2\n  ON T1.uuid = T2.uuid\nWHERE\n  T1.artist = 'Allen Williams' AND T2.status = 'Banned';\n",
        "pred_query": "SELECT DISTINCT\n  T1.frameVersion,\n  T1.name\nFROM cards AS T1\nINNER JOIN legalities AS T2\n  ON T1.uuid = T2.uuid\nWHERE\n  T1.artist = 'Allen Williams' AND T2.status = 'Banned';",
        "pred_time": 0.09483814239501953,
        "orig_time": 0.5448307991027832,
        "time_ratio": 5.744848911458595,
        "check": false
    },
    {
        "id": "student_club",
        "question": "State the name of major that Phillip Cullen has joined.",
        "original_query": "SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'",
        "llm_output": "-- Reasoning\nI need to find the major name associated with a specific member.\nI will join the `member` table with the `major` table using `link_to_major` from `member` and `major_id` from `major`.\nThen I will filter the results by the `first_name` and `last_name` of the member.\n\n-- SQL Query\nSELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_query": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Phillip' AND T1.last_name = 'Cullen';",
        "pred_time": 0.0013201236724853516,
        "orig_time": 0.0007495880126953125,
        "time_ratio": 0.567816507133827,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
        "original_query": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
        "llm_output": "-- Reasoning\nI need to find the `district_id` associated with `account_id` 532 from the `account` table.\nThen, using this `district_id`, I will query the `district` table to get the value from column `A15`, which represents the number of committed crimes in 1995.\n\n-- SQL Query\nSELECT T1.A15 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532;",
        "pred_query": "SELECT T1.A15 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532;",
        "pred_time": 0.0014102458953857422,
        "orig_time": 0.0006625652313232422,
        "time_ratio": 0.46982248520710057,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "original_query": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "llm_output": "-- Reasoning\nThe question asks for patient ID, sex, and birthday for patients with LDH values \"beyond normal range\".\nThe database schema does not define what constitutes the \"normal range\" for LDH.\nHowever, analyzing the first few-shot example: \"LDH between 100-300 index above the normal range.\" which corresponds to the query `WHERE T2.LDH > 600 AND T2.LDH < 800`.\nThis implies that if `X` is the upper limit of the \"normal range\", then `X + 100 = 600` and `X + 300 = 800`. Both equations yield `X = 500`.\nTherefore, based on this specific example, the implied upper limit of the normal range for LDH in this context is 500.\nInterpreting \"LDH beyond normal range\" in light of this, and without an explicit lower bound, we infer the condition `LDH > 500` (i.e., above the inferred normal upper limit).\nWe need to join the `Patient` table (for ID, SEX, Birthday) with the `Laboratory` table (for LDH).\n\n-- SQL Query\nSELECT DISTINCT\n  T1.ID,\n  T1.SEX,\n  T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.LDH > 500;",
        "pred_query": "SELECT DISTINCT\n  T1.ID,\n  T1.SEX,\n  T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.LDH > 500;",
        "pred_time": 0.0055963993072509766,
        "orig_time": 0.004477739334106445,
        "time_ratio": 0.8001107655604311,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "original_query": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
        "llm_output": "-- Reasoning\nI need to find the `atom_id2` for the `bond_id` 'TR000_2' from the `connected` table.\nThen, I will select all `bond_id`s from the `connected` table where the `atom_id2` matches the one found in the first step.\n\n-- SQL Query\nSELECT T1.bond_id FROM connected AS T1 WHERE T1.atom_id2 = (SELECT T2.atom_id2 FROM connected AS T2 WHERE T2.bond_id = 'TR000_2');",
        "pred_query": "SELECT T1.bond_id FROM connected AS T1 WHERE T1.atom_id2 = (SELECT T2.atom_id2 FROM connected AS T2 WHERE T2.bond_id = 'TR000_2');",
        "pred_time": 0.017635822296142578,
        "orig_time": 0.0036470890045166016,
        "time_ratio": 0.20680005407597674,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "original_query": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "llm_output": "\nSELECT T1.`Percent (%) Eligible Free (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine';\n",
        "pred_query": "SELECT T1.`Percent (%) Eligible Free (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine';",
        "pred_time": 0.035237789154052734,
        "orig_time": 0.013784408569335938,
        "time_ratio": 0.39118255998051393,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give more information about the Formula_1 races that used the Silverstone Circuit.",
        "original_query": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "llm_output": "ite\nSELECT\n  T2.year,\n  T2.name,\n  T2.date,\n  T2.round\nFROM circuits AS T1\nINNER JOIN races AS T2\n  ON T1.circuitId = T2.circuitId\nWHERE\n  T1.name = 'Silverstone Circuit';\n",
        "pred_query": "SELECT\n  T2.year,\n  T2.name,\n  T2.date,\n  T2.round\nFROM circuits AS T1\nINNER JOIN races AS T2\n  ON T1.circuitId = T2.circuitId\nWHERE\n  T1.name = 'Silverstone Circuit';",
        "pred_time": 0.0016808509826660156,
        "orig_time": 0.001224517822265625,
        "time_ratio": 0.7285106382978723,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Give the only one comment text of the post with parent id 107829.",
        "original_query": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ParentId = 107829 AND T1.CommentCount = 1",
        "llm_output": "-- Reasoning\nI need to retrieve the 'Text' from the 'comments' table.\nThe condition is based on the 'ParentId' of the post associated with the comment.\nI will join the 'comments' table with the 'posts' table using `comments.PostId = posts.Id`.\nThen, I will filter the results where `posts.ParentId` is equal to 107829.\n\n\nSELECT\n  T1.Text\nFROM comments AS T1\nINNER JOIN posts AS T2\n  ON T1.PostId = T2.Id\nWHERE\n  T2.ParentId = 107829;\n",
        "pred_query": "SELECT\n  T1.Text\nFROM comments AS T1\nINNER JOIN posts AS T2\n  ON T1.PostId = T2.Id\nWHERE\n  T2.ParentId = 107829;",
        "pred_time": 0.3458395004272461,
        "orig_time": 0.3422222137451172,
        "time_ratio": 0.9895405623774608,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
        "original_query": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
        "llm_output": "-- Reasoning\nTo find the Italian name of the set, I need to:\n1. Identify the `setCode` of the card \"Ancestor's Chosen\" from the `cards` table.\n2. Join `cards` with `set_translations` using the `setCode`.\n3. Filter `set_translations` for `language` 'Italian' and select the `translation`.\n\nSELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';",
        "pred_query": "select the `translation`.\n\nSELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';",
        "pred_time": null,
        "orig_time": 0.11050724983215332,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many translations of the name of the set \"Salvat 2011\"?",
        "original_query": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Salvat 2011' AND T2.translation IS NOT NULL",
        "llm_output": "-- Reasoning\nTo find the number of translations for the set \"Salvat 2011\", I need to first find the `code` of this set in the `sets` table.\nThen, I will use this `code` to filter the `set_translations` table and count the distinct `translation` entries.\n\n-- SQL Query\nSELECT COUNT(translation) FROM set_translations WHERE setCode = ( SELECT code FROM sets WHERE name = 'Salvat 2011' );",
        "pred_query": "SELECT COUNT(translation) FROM set_translations WHERE setCode = ( SELECT code FROM sets WHERE name = 'Salvat 2011' );",
        "pred_time": 0.0021626949310302734,
        "orig_time": 0.002538442611694336,
        "time_ratio": 1.1737404916767722,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "original_query": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join three tables: `member`, `attendance`, and `event`.\nFirst, I will filter the `event` table for the event named 'Women''s Soccer'.\nThen, I will join `event` with `attendance` on `event_id` to find members who attended this event.\nFinally, I will join `attendance` with `member` on `member_id` and filter for members whose `t_shirt_size` is 'Medium', then count the distinct members.\n\n-- SQL Query\nSELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';",
        "pred_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';",
        "pred_time": 0.0012128353118896484,
        "orig_time": 0.0008933544158935547,
        "time_ratio": 0.7365834480047179,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?",
        "original_query": "SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) >= '1997' AND T1.A15 > 4000",
        "llm_output": "SELECT AVG(T1.A15) FROM district AS T1 WHERE T1.A15 > 4000 AND T1.district_id IN (SELECT DISTINCT T2.district_id FROM account AS T2 WHERE strftime('%Y', T2.date) >= '1997');",
        "pred_query": "SELECT AVG(T1.A15) FROM district AS T1 WHERE T1.A15 > 4000 AND T1.district_id IN (SELECT DISTINCT T2.district_id FROM account AS T2 WHERE strftime('%Y', T2.date) >= '1997');",
        "pred_time": 0.0031747817993164062,
        "orig_time": 0.002608776092529297,
        "time_ratio": 0.8217182337038149,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "original_query": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "llm_output": "-- Reasoning\nI need to retrieve the school name and NCES school ID from the `schools` table.\nI also need to use the `Enrollment (Ages 5-17)` column from the `frpm` table for ordering.\nI will join these two tables on their common `CDSCode` column, order by enrollment in descending order, and limit to the top 5.\n\n-- SQL Query\nSELECT T2.School, T2.NCESSchool FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_query": "SELECT T2.School, T2.NCESSchool FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (Ages 5-17)` DESC LIMIT 5;",
        "pred_time": 0.04771137237548828,
        "orig_time": 0.03151059150695801,
        "time_ratio": 0.6604419436726698,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level?",
        "original_query": "SELECT T2.ANA FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 ORDER BY T2.ANA DESC LIMIT 1",
        "llm_output": "ite\nSELECT MAX(T1.ANA) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE < 1.5\n",
        "pred_query": "SELECT MAX(T1.ANA) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE < 1.5",
        "pred_time": 0.0024139881134033203,
        "orig_time": 0.0016832351684570312,
        "time_ratio": 0.697283950617284,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many male patients have elevated total bilirubin count?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to join the Patient table with the Laboratory table using the common 'ID' column.\nI will filter the results to include only male patients (SEX = 'M') from the Patient table.\nI will also filter for patients with an elevated total bilirubin count, which, based on previous examples, can be interpreted as T-BIL >= 2.0.\nFinally, I will count the distinct IDs to find the number of unique male patients meeting both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` >= 2.0;",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.`T-BIL` >= 2.0;",
        "pred_time": 0.0033142566680908203,
        "orig_time": 0.0022344589233398438,
        "time_ratio": 0.6741961009999281,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?",
        "original_query": "SELECT COUNT(player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'",
        "llm_output": "-- Reasoning\nI need to filter players based on two criteria from the `Player_Attributes` table: `preferred_foot` and `attacking_work_rate`.\n\"Preferred foot was the left foot when attacking\" translates to `preferred_foot = 'left'`.\n\"Remain in his position when the team attacked\" implies a 'Low' `attacking_work_rate`.\nI will count the distinct `player_api_id` from the `Player_Attributes` table that satisfy both conditions.\n\n-- SQL Query\nSELECT COUNT(DISTINCT player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'Low';",
        "pred_query": "SELECT COUNT(DISTINCT player_api_id) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'Low';",
        "pred_time": 0.13935184478759766,
        "orig_time": 0.11729264259338379,
        "time_ratio": 0.8417013981563225,
        "check": false
    },
    {
        "id": "card_games",
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "original_query": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "llm_output": "-- Reasoning\nThe question asks for languages available for a set that a specific card belongs to.\nFirst, I need to find the `setCode` for the card 'Angel of Mercy' from the `cards` table.\nThen, I will use this `setCode` to query the `set_translations` table to retrieve all distinct `language` values associated with that set code.\n\n-- SQL Query\nSELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy'",
        "pred_query": "SELECT T2.language FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Angel of Mercy'",
        "pred_time": 0.10992217063903809,
        "orig_time": 0.10243749618530273,
        "time_ratio": 0.9319093281162224,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which SME customer consumed the least in June 2012?",
        "original_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `customers` table with the `yearmonth` table.\nFilter `yearmonth` records for the date '201206' and `customers` records for the 'SME' segment.\nThen, order the results by `Consumption` in ascending order to find the least consumer.\nFinally, limit the result to 1 and select the `CustomerID`.\n\n-- SQL Query\nSELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' ORDER BY T2.Consumption ASC LIMIT 1;",
        "pred_query": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' ORDER BY T2.Consumption ASC LIMIT 1;",
        "pred_time": 0.40674853324890137,
        "orig_time": 0.03787660598754883,
        "time_ratio": 0.09312044885573323,
        "check": true
    },
    {
        "id": "financial",
        "question": "What is the region of the client with the id 3541 from?",
        "original_query": "SELECT T2.district_id, T1.A3 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.client_id = 3541",
        "llm_output": "-- Reasoning\nThe question asks for the region of a client given their client_id.\nThe `client` table contains `client_id` and `district_id`.\nThe `district` table contains `district_id` and the region information in column `A3`.\nTherefore, I need to join `client` and `district` tables on `district_id` and filter by the given `client_id` to retrieve `A3`.\n\n-- SQL Query\nSELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541;",
        "pred_query": "SELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541;",
        "pred_time": 0.001941680908203125,
        "orig_time": 0.0009703636169433594,
        "time_ratio": 0.49975442043222,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the score and the link type ID for post ID 395?",
        "original_query": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395",
        "llm_output": "-- Reasoning\nI need to retrieve the 'Score' from the 'posts' table and the 'LinkTypeId' from the 'postLinks' table.\nBoth tables contain information related to posts, so a JOIN operation will be necessary.\nI will join 'posts' and 'postLinks' on their respective post IDs.\nThen, I will filter the results for the specific PostId 395.\n\n-- SQL Query\nSELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T1.Id = 395;",
        "pred_query": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T1.Id = 395;",
        "pred_time": 0.01026773452758789,
        "orig_time": 0.003275156021118164,
        "time_ratio": 0.318975525936934,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "How many French constructors have a lap number of over 50?",
        "original_query": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "llm_output": "-- Reasoning\nI need to find constructors with 'French' nationality.\nThen I need to link these constructors to drivers and races through the `results` table.\nFinally, I will join with `lapTimes` to check for laps over 50 and count the distinct constructor names.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.name) FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId INNER JOIN lapTimes AS T3 ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId WHERE T1.nationality = 'French' AND T3.lap > 50;",
        "pred_query": "SELECT COUNT(DISTINCT T1.name) FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId INNER JOIN lapTimes AS T3 ON T2.raceId = T3.raceId AND T2.driverId = T3.driverId WHERE T1.nationality = 'French' AND T3.lap > 50;",
        "pred_time": 0.1080465316772461,
        "orig_time": 0.006674051284790039,
        "time_ratio": 0.061770157553290087,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "original_query": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA > 6.5 AND T1.SEX = 'F') OR (T2.UA > 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "llm_output": "-- Reasoning\nTo find the average UA index for patients with normal uric acid from their latest examination, we first need to identify each patient's latest laboratory result.\nWe use a Common Table Expression (CTE) with `ROW_NUMBER()` partitioned by patient ID and ordered by examination date in descending order to achieve this.\nThen, we filter these latest results to include only those where UA is considered \"normal\". Based on the provided examples, where `UA > 6.5` is considered \"beyond the normal range\", we infer that `UA <= 6.5` represents a normal uric acid level.\nFinally, we calculate the average of the UA values for these filtered patients.\n\n-- SQL Query\n\nWITH LatestLab AS (\n  SELECT\n    ID,\n    UA,\n    ROW_NUMBER() OVER (PARTITION BY ID ORDER BY Date DESC) as rn\n  FROM Laboratory\n)\nSELECT\n  AVG(UA)\nFROM LatestLab\nWHERE rn = 1 AND UA <= 6.5;\n",
        "pred_query": "SELECT\n    ID,\n    UA,\n    ROW_NUMBER() OVER (PARTITION BY ID ORDER BY Date DESC) as rn\n  FROM Laboratory\n)\nSELECT\n  AVG(UA)\nFROM LatestLab\nWHERE rn = 1 AND UA <= 6.5;",
        "pred_time": null,
        "orig_time": 0.007840633392333984,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "original_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "llm_output": "-- Reasoning\nTo find the circuit name, I need to join the `races` table with the `circuits` table.\nI will filter the `races` table for the year 2009 and the race name 'Spanish Grand Prix'.\nThen, I will select the `name` column from the `circuits` table which corresponds to the filtered race.\n\n-- SQL Query\nSELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_query": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_time": 0.0015621185302734375,
        "orig_time": 0.0011038780212402344,
        "time_ratio": 0.7066544566544567,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "What is the molecule id of bond id TR001_1_7?",
        "original_query": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_1_7'",
        "llm_output": "The `bond` table contains both `bond_id` and `molecule_id`.\nTo answer the question, I need to select the `molecule_id` from the `bond` table.\nI will filter the results using the given `bond_id`.\n\n\nSELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';\n",
        "pred_query": "select the `molecule_id` from the `bond` table.\nI will filter the results using the given `bond_id`.\n\n\nSELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';",
        "pred_time": null,
        "orig_time": 0.003980398178100586,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "original_query": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "llm_output": "-- Reasoning\nTo answer this question, I need to retrieve the overall rating for 'Landon Donovan' and 'Jordan Bowery' from the `Player_Attributes` table, linked by `player_api_id` to the `Player` table, on the specified date '2013/7/12'.\nThen, I will calculate the percentage difference using the formula: ((Donovan's Rating - Bowery's Rating) * 100.0 / Bowery's Rating).\n\n-- SQL Query\nSELECT CAST((\n  (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Landon Donovan' AND T2.`date` = '2013-07-12 00:00:00') -\n  (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Jordan Bowery' AND T2.`date` = '2013-07-12 00:00:00')\n) AS REAL) * 100.0 / (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Jordan Bowery' AND T2.`date` = '2013-07-12 00:00:00');",
        "pred_query": "SELECT CAST((\n  (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Landon Donovan' AND T2.`date` = '2013-07-12 00:00:00') -\n  (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Jordan Bowery' AND T2.`date` = '2013-07-12 00:00:00')\n) AS REAL) * 100.0 / (SELECT T2.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Jordan Bowery' AND T2.`date` = '2013-07-12 00:00:00');",
        "pred_time": 0.2481672763824463,
        "orig_time": 0.1456301212310791,
        "time_ratio": 0.58682241814449,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "original_query": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
        "llm_output": "-- Reasoning\nThe question asks for the age of the patient with the highest hemoglobin count at the time of the examination and their diagnosis.\n1. Identify the maximum hemoglobin (HGB) value from the `Laboratory` table.\n2. Join `Patient` and `Laboratory` tables on `ID` to link patients with their lab results.\n3. Filter for the patient(s) whose `HGB` matches the maximum `HGB` found in step 1.\n4. Calculate the age at the time of the laboratory examination using the `Laboratory.Date` and `Patient.Birthday`. Use `STRFTIME('%Y', date)` for year difference, similar to few-shot examples.\n5. Retrieve the `Diagnosis` from the `Patient` table, as it represents the patient's general diagnosis.\n6. Use `LIMIT 1` in case multiple patients have the same highest HGB, as the question implies a single patient.\n\n-- SQL Query\n\nSELECT\n  STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday),\n  T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.HGB = (\n    SELECT\n      MAX(HGB)\n    FROM Laboratory\n  )\nLIMIT 1;\n",
        "pred_query": "SELECT\n  STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday),\n  T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  T2.HGB = (\n    SELECT\n      MAX(HGB)\n    FROM Laboratory\n  )\nLIMIT 1;",
        "pred_time": 0.007225990295410156,
        "orig_time": 0.006401538848876953,
        "time_ratio": 0.8859047116272931,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "original_query": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "llm_output": "-- Reasoning\nI need to retrieve the driver's name and the duration of their pit stops.\nI will join the `pitStops` table with the `drivers` table on `driverId` to get driver names.\nI will also join with the `races` table on `raceId` to filter for the '2011 Australian Grand Prix'.\nFinally, I will select the driver's forename, surname, and the pit stop duration.\n\n-- SQL Query\nSELECT\n  T2.forename,\n  T2.surname,\n  T1.duration\nFROM pitStops AS T1\nINNER JOIN drivers AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T1.raceId = T3.raceId\nWHERE\n  T3.year = 2011 AND T3.name = 'Australian Grand Prix';",
        "pred_query": "SELECT\n  T2.forename,\n  T2.surname,\n  T1.duration\nFROM pitStops AS T1\nINNER JOIN drivers AS T2\n  ON T1.driverId = T2.driverId\nINNER JOIN races AS T3\n  ON T1.raceId = T3.raceId\nWHERE\n  T3.year = 2011 AND T3.name = 'Australian Grand Prix';",
        "pred_time": 0.002484560012817383,
        "orig_time": 0.007956743240356445,
        "time_ratio": 3.202475770079647,
        "check": false
    },
    {
        "id": "financial",
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "original_query": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "llm_output": "-- Reasoning\nTo calculate the percentage, we need two counts: the number of accounts from the 'Decin' district opened in 1993, and the total number of accounts opened in 1993.\nWe will join the `account` and `district` tables on `district_id` to filter by district name.\nThe year of the account opening can be extracted from the `date` column in the `account` table using `strftime('%Y', date)`.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id)\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nWHERE strftime('%Y', T1.date) = '1993';",
        "pred_query": "SELECT CAST(SUM(CASE WHEN T2.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id)\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nWHERE strftime('%Y', T1.date) = '1993';",
        "pred_time": 0.0033643245697021484,
        "orig_time": 0.0031080245971679688,
        "time_ratio": 0.9238182977818723,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "Please list the product description of the products consumed in September, 2013.",
        "original_query": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "llm_output": "-- Reasoning\nI need to retrieve product descriptions. The `products` table contains the `Description` and `ProductID`.\nThe `transactions_1k` table contains `ProductID` and `Date` which I can use to filter by September 2013.\nI will join these two tables on `ProductID` and filter by the date range '2013-09-01' to '2013-09-30'.\nI will use `DISTINCT` to avoid duplicate product descriptions.\n\n-- SQL Query\nSELECT DISTINCT T1.Description FROM products AS T1 INNER JOIN transactions_1k AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Date BETWEEN '2013-09-01' AND '2013-09-30';",
        "pred_query": "SELECT DISTINCT T1.Description FROM products AS T1 INNER JOIN transactions_1k AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Date BETWEEN '2013-09-01' AND '2013-09-30';",
        "pred_time": 0.0015437602996826172,
        "orig_time": 0.027515172958374023,
        "time_ratio": 17.823474903474903,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the elements for bond id TR001_10_11?",
        "original_query": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
        "llm_output": "-- Reasoning\nI need to find the elements of the two atoms connected by the given bond ID.\nThe `connected` table links a `bond_id` to two atoms (`atom_id` and `atom_id2`).\nThe `atom` table contains the `element` for each `atom_id`.\nI will join the `connected` table with the `atom` table twice (once for `atom_id` and once for `atom_id2`) to retrieve the elements of both connected atoms, and then use `UNION` to combine them into a single list of distinct elements.\n\n-- SQL Query\nSELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11' UNION SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id2 = T2.atom_id WHERE T1.bond_id = 'TR001_10_11';",
        "pred_query": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11' UNION SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id2 = T2.atom_id WHERE T1.bond_id = 'TR001_10_11';",
        "pred_time": 0.0188753604888916,
        "orig_time": 0.003505706787109375,
        "time_ratio": 0.1857292627164673,
        "check": true
    },
    {
        "id": "card_games",
        "question": "List the edhrecRank for cards with frame version 2015.",
        "original_query": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "llm_output": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_query": "SELECT edhrecRank FROM cards WHERE frameVersion = '2015';",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "original_query": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "llm_output": "\nSELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1999' AND player_name LIKE 'Aaron%';\n",
        "pred_query": "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1999' AND player_name LIKE 'Aaron%';",
        "pred_time": 0.01570582389831543,
        "orig_time": 0.011562585830688477,
        "time_ratio": 0.7361973434535104,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "original_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
        "llm_output": "\nSELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;\n",
        "pred_query": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'San Marino Grand Prix' AND T1.year = 2006 AND T2.position = 2;",
        "pred_time": 0.006357669830322266,
        "orig_time": 0.005360603332519531,
        "time_ratio": 0.8431710792769819,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Which college do most of the members go to?",
        "original_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.major_id ORDER BY COUNT(T2.college) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `member` table with the `major` table to link members to their respective colleges.\nThen, I will group the results by `college` and count the number of members in each college.\nFinally, I will order the colleges by the count of members in descending order and select the top one.\n\n-- SQL Query\nSELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_query": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY T2.college ORDER BY COUNT(T1.member_id) DESC LIMIT 1;",
        "pred_time": 0.0015366077423095703,
        "orig_time": 0.0007634162902832031,
        "time_ratio": 0.49681923972071373,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many users were from New York?",
        "original_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "llm_output": "-- Reasoning\nTo find the number of users from 'New York', I need to query the 'users' table.\nI will filter the rows where the 'Location' column is 'New York'.\nFinally, I will count the distinct 'Id's of these users.\n\n-- SQL Query\nSELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_query": "SELECT COUNT(Id) FROM users WHERE Location = 'New York';",
        "pred_time": 0.016042232513427734,
        "orig_time": 0.012682676315307617,
        "time_ratio": 0.7905805070891418,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Which country is the Belgium Jupiler League from?",
        "original_query": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "llm_output": "-- Reasoning\nThe question asks for the country of a specific league.\nI need to join the `League` table with the `Country` table.\nFilter the `League` table by the league name 'Belgium Jupiler League'.\nThen select the `name` from the `Country` table.\n\n-- SQL Query\nSELECT T2.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League';",
        "pred_query": "SELECT T2.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League';",
        "pred_time": 0.0020318031311035156,
        "orig_time": 0.0012476444244384766,
        "time_ratio": 0.6140577329265431,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For all patient born in 1982, state if their albumin is within normal range.",
        "original_query": "SELECT CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1982'",
        "llm_output": "-- Reasoning\nThe query needs to join the `Patient` and `Laboratory` tables on `ID`.\nIt then filters patients whose `Birthday` is in the year 1982 using the `strftime` function.\nFinally, a `CASE` statement is used to check if the `ALB` value falls within the normal range (3.5 to 5.5) and assigns 'normal' or 'abNormal' accordingly.\n\n-- SQL Query\nSELECT T1.ID, CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE strftime('%Y', T1.Birthday) = '1982';",
        "pred_query": "SELECT T1.ID, CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE strftime('%Y', T1.Birthday) = '1982';",
        "pred_time": 0.02018284797668457,
        "orig_time": 0.01832723617553711,
        "time_ratio": 0.9080599624348812,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "original_query": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
        "llm_output": "\nSELECT T2.name, T2.totalSetSize FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.language = 'Italian'\n",
        "pred_query": "SELECT T2.name, T2.totalSetSize FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.language = 'Italian'",
        "pred_time": 0.014131784439086914,
        "orig_time": 0.006230592727661133,
        "time_ratio": 0.44089214313431074,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many clients who choose statement of weekly issuance are User?",
        "original_query": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'USER'",
        "llm_output": "\nSELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'USER';\n",
        "pred_query": "SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.frequency = 'POPLATEK TYDNE' AND T2.type = 'USER';",
        "pred_time": 0.0017464160919189453,
        "orig_time": 0.0010929107666015625,
        "time_ratio": 0.62580204778157,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "original_query": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "llm_output": "-- Reasoning\nI need to find the `Name` of badges from the `badges` table.\nThe question specifies a user by `DisplayName`, which is in the `users` table.\nI will join `badges` and `users` tables on `badges.UserId = users.Id`.\nThen, I will filter the results where `users.DisplayName` is 'Pierre' and select the badge `Name`.\n\n-- SQL Query\nSELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Pierre';",
        "pred_query": "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Pierre';",
        "pred_time": 0.10747766494750977,
        "orig_time": 0.10399580001831055,
        "time_ratio": 0.9676038279125276,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Among the patients whose C-reactive protein level is abnormal, how many of them aren't 18 yet?",
        "original_query": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP != '-' AND T2.CRP != '+-') AND T2.CRP >= 1.0 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < '18'",
        "llm_output": "-- Reasoning\nThe query needs to count distinct patients.\nIt requires joining the Patient table with the Laboratory table on ID.\nPatients must have an abnormal C-reactive protein (CRP) level, which means CRP is not '-', '+-', or less than 1.0.\nPatients must be less than 18 years old at the time of their laboratory test. This can be checked by comparing the `Laboratory.Date` with `Patient.Birthday` plus 18 years.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  NOT (\n    T2.CRP = '-' OR T2.CRP = '+-' OR CAST(T2.CRP AS REAL) < 1.0\n  ) AND T2.Date < DATE(T1.Birthday, '+18 years');",
        "pred_query": "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nWHERE\n  NOT (\n    T2.CRP = '-' OR T2.CRP = '+-' OR CAST(T2.CRP AS REAL) < 1.0\n  ) AND T2.Date < DATE(T1.Birthday, '+18 years');",
        "pred_time": 0.004430532455444336,
        "orig_time": 0.014069318771362305,
        "time_ratio": 3.1755367809288058,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "original_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "llm_output": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';",
        "pred_time": 0.09960651397705078,
        "orig_time": 0.09490728378295898,
        "time_ratio": 0.9528220594571305,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "For the patient who first came to the hospital on 1991/6/13 who was diagnosed with SJS, what is the total number of his/her Laboratory tests in 1995?",
        "original_query": "SELECT COUNT(*) FROM Laboratory WHERE ID = ( SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS' ) AND STRFTIME('%Y', Date) = '1995'",
        "llm_output": "-- Reasoning\nI need to first identify the patient based on their `First Date` and `Diagnosis` from the `Patient` table.\nThen, I will join this patient's `ID` with the `Laboratory` table to count their tests.\nFinally, I will filter the `Laboratory` records to only include those that occurred in the year 1995.\n\n-- SQL Query\nSELECT COUNT(T1.ID) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.`First Date` = '1991-06-13' AND T2.Diagnosis = 'SJS' AND STRFTIME('%Y', T1.Date) = '1995';",
        "pred_query": "SELECT COUNT(T1.ID) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.`First Date` = '1991-06-13' AND T2.Diagnosis = 'SJS' AND STRFTIME('%Y', T1.Date) = '1995';",
        "pred_time": 0.002199888229370117,
        "orig_time": 0.001528024673461914,
        "time_ratio": 0.6945919583830064,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "original_query": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the display name of the user who acquired the first 'Autobiographer' badge, I need to:\n1. Filter the `badges` table for entries where `Name` is 'Autobiographer'.\n2. Order these filtered badges by their `Date` in ascending order to identify the earliest one.\n3. Select the `UserId` of this first badge.\n4. Join the result with the `users` table on `Id` to retrieve the corresponding `DisplayName`.\n\n-- SQL Query\nSELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Autobiographer' ORDER BY T1.Date ASC LIMIT 1;",
        "pred_query": "SELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Autobiographer' ORDER BY T1.Date ASC LIMIT 1;",
        "pred_time": 0.037283897399902344,
        "orig_time": 0.03401994705200195,
        "time_ratio": 0.9124568359125208,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Identify the total number of posts with views above average.",
        "original_query": "SELECT Id FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts )",
        "llm_output": "-- Reasoning\nFirst, calculate the average view count for all posts in the `posts` table.\nThen, count the number of posts whose `ViewCount` is greater than this calculated average.\nThis requires a subquery to get the average view count.\n\n-- SQL Query\nSELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_query": "SELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts);",
        "pred_time": 0.3351123332977295,
        "orig_time": 0.34354448318481445,
        "time_ratio": 1.0251621592201843,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "original_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "llm_output": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.type LIKE '%Artifact%' AND T1.colors LIKE '%Black%';",
        "pred_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.type LIKE '%Artifact%' AND T1.colors LIKE '%Black%';",
        "pred_time": 0.5052485466003418,
        "orig_time": 0.47680091857910156,
        "time_ratio": 0.9436957746585213,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "original_query": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "llm_output": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T2.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T3.GPT > 30 AND T3.ALB < 4;",
        "pred_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T2.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T3.GPT > 30 AND T3.ALB < 4;",
        "pred_time": 0.0077168941497802734,
        "orig_time": 0.005342960357666016,
        "time_ratio": 0.69237186022801,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What are the labels for TR000, TR001 and TR002?",
        "original_query": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
        "llm_output": "-- Reasoning\nThe question asks for the labels of specific molecules ('TR000', 'TR001', 'TR002').\nThe `molecule` table contains `molecule_id` and `label`.\nI need to select the `label` from the `molecule` table where the `molecule_id` is one of the specified values.\n\n-- SQL Query\nSELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_query": "SELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');",
        "pred_time": 0.0011379718780517578,
        "orig_time": 0.0009198188781738281,
        "time_ratio": 0.8082966687617851,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "Of all the schools with a mailing state address in California, how many are active in San Joaquin?",
        "original_query": "SELECT COUNT(CDSCode) FROM schools WHERE City = 'San Joaquin' AND MailState = 'CA' AND StatusType = 'Active'",
        "llm_output": "-- Reasoning\nI need to count schools from the `schools` table.\nThe conditions are that `MailState` must be 'CA', `County` must be 'San Joaquin', and `StatusType` must be 'Active'.\nI will use a COUNT(*) with a WHERE clause combining these conditions.\n\n-- SQL Query\nSELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin' AND StatusType = 'Active';",
        "pred_query": "SELECT COUNT(CDSCode) FROM schools WHERE MailState = 'CA' AND County = 'San Joaquin' AND StatusType = 'Active';",
        "pred_time": 0.015332460403442383,
        "orig_time": 0.012677907943725586,
        "time_ratio": 0.8268671570075729,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "original_query": "SELECT CAST(SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTRING(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "llm_output": "-- Reasoning\nFirst, identify the CustomerID from the `transactions_1k` table using the given date and price.\nThen, join with the `yearmonth` table to find the total consumption for this customer in 2012 and 2013.\nFinally, calculate the decrease rate using the formula: (Consumption_2012 - Consumption_2013) / Consumption_2012.\n\n-- SQL Query\nSELECT\n  (\n    SUM(CASE WHEN T2.Date LIKE '2012%' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '2013%' THEN T2.Consumption ELSE 0 END)\n  ) * 1.0 / SUM(CASE WHEN T2.Date LIKE '2012%' THEN T2.Consumption ELSE 0 END)\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2\n  ON T1.CustomerID = T2.CustomerID\nWHERE\n  T1.Date = '2012-08-25' AND T1.Price = 634.8;",
        "pred_query": "SELECT\n  (\n    SUM(CASE WHEN T2.Date LIKE '2012%' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '2013%' THEN T2.Consumption ELSE 0 END)\n  ) * 1.0 / SUM(CASE WHEN T2.Date LIKE '2012%' THEN T2.Consumption ELSE 0 END)\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2\n  ON T1.CustomerID = T2.CustomerID\nWHERE\n  T1.Date = '2012-08-25' AND T1.Price = 634.8;",
        "pred_time": 0.24128270149230957,
        "orig_time": 0.046141862869262695,
        "time_ratio": 0.19123568570759467,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Identify the heaviest superhero in DC Comics.",
        "original_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `publisher` table to filter by 'DC Comics'.\nThen, I will order the results by `weight_kg` in descending order and select the `superhero_name` of the top entry.\n\n-- SQL Query\nSELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "pred_query": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "pred_time": 0.0017740726470947266,
        "orig_time": 0.0008554458618164062,
        "time_ratio": 0.4821932535949469,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Please list the diseases of the patients born after 1995-1-1 and have a normal Rhuematoid Factor.",
        "original_query": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T1.Birthday > 1995-01-01",
        "llm_output": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday > '1995-01-01' AND T2.RA = '-';",
        "pred_query": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday > '1995-01-01' AND T2.RA = '-';",
        "pred_time": 0.0073089599609375,
        "orig_time": 0.00661015510559082,
        "time_ratio": 0.9043906576200418,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the name of user with the ID of 30?",
        "original_query": "SELECT DisplayName FROM users WHERE Id = 30",
        "llm_output": "-- Reasoning\nI need to retrieve the `DisplayName` column from the `users` table.\nThe condition to filter the rows is that the `Id` column must be equal to 30.\n\n-- SQL Query\nSELECT DisplayName FROM users WHERE Id = 30;",
        "pred_query": "SELECT DisplayName FROM users WHERE Id = 30;",
        "pred_time": 0.0016713142395019531,
        "orig_time": 0.0007166862487792969,
        "time_ratio": 0.4288159771754636,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "original_query": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "llm_output": "\nSELECT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Sepang International Circuit'\n",
        "pred_query": "SELECT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "pred_time": null,
        "orig_time": null,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the names of the races held on the circuits in Spain.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "llm_output": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain'",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain'",
        "pred_time": 0.0019903182983398438,
        "orig_time": 0.0014028549194335938,
        "time_ratio": 0.704839482510781,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
        "original_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
        "llm_output": "-- Reasoning\nI need to find `atom_id`s from atoms that are part of molecules labeled as carcinogenic ('+').\nAdditionally, these atoms must have the element 'O' (oxygen).\nI will join `atom` and `molecule` tables on `molecule_id` and apply the filters.\n\n-- SQL Query\nSELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'O';",
        "pred_query": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'O';",
        "pred_time": 0.002353191375732422,
        "orig_time": 0.008829116821289062,
        "time_ratio": 3.7519756838905773,
        "check": false
    },
    {
        "id": "financial",
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "original_query": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "llm_output": "-- Reasoning\nI need to find accounts located in 'Prague'. This involves joining the `account` table with the `district` table and filtering `district.A3` for 'Prague'.\nThen, I need to identify which of these accounts have loans. This means joining the result with the `loan` table.\nFinally, I will count the distinct `account_id`s to ensure each eligible account is counted only once.\n\n-- SQL Query\nSELECT COUNT(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = 'Prague';",
        "pred_query": "SELECT COUNT(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = 'Prague';",
        "pred_time": 0.001990079879760742,
        "orig_time": 0.0015883445739746094,
        "time_ratio": 0.7981310650533125,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Is molecule TR124 carcinogenic?",
        "original_query": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
        "llm_output": "-- Reasoning\nThe question asks about the carcinogenicity of a specific molecule.\nThe `molecule` table contains `molecule_id` and a `label` column, which, based on the few-shot examples, indicates whether a molecule is carcinogenic.\nTherefore, I need to query the `molecule` table and retrieve the `label` for the `molecule_id` 'TR124'.\n\n-- SQL Query\nSELECT T1.label FROM molecule AS T1 WHERE T1.molecule_id = 'TR124';",
        "pred_query": "SELECT T1.label FROM molecule AS T1 WHERE T1.molecule_id = 'TR124';",
        "pred_time": 0.001538991928100586,
        "orig_time": 0.00101470947265625,
        "time_ratio": 0.6593338497288923,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the anti Cardiolipin antibody concentration of the female patient with the highest uric acid level in the normal range?",
        "original_query": "SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T1.SEX = 'F' AND T2.UA > 6.5 ORDER BY T2.UA DESC LIMIT 1",
        "llm_output": "-- Reasoning\nFirst, filter female patients from the Patient table. Then, join with the Laboratory table to find their uric acid (UA) levels. Filter these results for UA levels within the normal range (assuming 2.4 to 6.5 based on common ranges and example context where 6.5 is a threshold). Find the patient ID corresponding to the maximum UA value within this normal range. Finally, join with the Examination table to retrieve the `aCL IgA` concentration for that specific patient ID.\n\n-- SQL Query\nSELECT T3.`aCL IgA`\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nINNER JOIN Examination AS T3\n  ON T1.ID = T3.ID\nWHERE\n  T1.SEX = 'F' AND T2.UA >= 2.4 AND T2.UA <= 6.5\nORDER BY\n  T2.UA DESC\nLIMIT 1;",
        "pred_query": "SELECT T3.`aCL IgA`\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2\n  ON T1.ID = T2.ID\nINNER JOIN Examination AS T3\n  ON T1.ID = T3.ID\nWHERE\n  T1.SEX = 'F' AND T2.UA >= 2.4 AND T2.UA <= 6.5\nORDER BY\n  T2.UA DESC\nLIMIT 1;",
        "pred_time": 0.002621173858642578,
        "orig_time": 0.0015523433685302734,
        "time_ratio": 0.592232126614517,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Calculate the ratio of votes in 2010 and 2011.",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
        "llm_output": "-- Reasoning\nTo calculate the ratio, I need to count the votes for each year, 2010 and 2011, from the 'votes' table.\nThe `CreationDate` column in the `votes` table can be used to filter by year using `STRFTIME('%Y', CreationDate)`.\nThen, I will divide the count of votes in 2010 by the count of votes in 2011, ensuring to cast to REAL for floating-point division.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END) FROM votes;",
        "pred_query": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END) FROM votes;",
        "pred_time": 0.03882956504821777,
        "orig_time": 0.02990436553955078,
        "time_ratio": 0.7701442316548265,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Calculate the difference in view count from post posted by mornington and view count from posts posted by Amos.",
        "original_query": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "llm_output": "-- Reasoning\nI need to join the 'posts' table with the 'users' table to link posts to their owners' display names.\nThen, I will calculate the sum of 'ViewCount' for posts owned by 'mornington' and separately for 'Amos'.\nFinally, I will subtract the sum for 'Amos' from the sum for 'mornington'.\n\n-- SQL Query\nSELECT\n  (SELECT SUM(T1.ViewCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'mornington') -\n  (SELECT SUM(T1.ViewCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Amos');",
        "pred_query": "SELECT\n  (SELECT SUM(T1.ViewCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'mornington') -\n  (SELECT SUM(T1.ViewCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Amos');",
        "pred_time": 0.8253128528594971,
        "orig_time": 2.396632671356201,
        "time_ratio": 2.9039080914013207,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "original_query": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "llm_output": "-- Reasoning\nI need to retrieve the 'Score' from the comments table.\nI will join the 'comments' table with the 'posts' table using 'PostId' and 'Id' respectively.\nThen, I will filter the results based on the 'CreaionDate' column in the 'posts' table.\n\n-- SQL Query\nSELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CreaionDate = '2010-07-19 19:19:56.0';",
        "pred_query": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CreaionDate = '2010-07-19 19:19:56.0';",
        "pred_time": 0.34106993675231934,
        "orig_time": 0.08835577964782715,
        "time_ratio": 0.2590547278635994,
        "check": false
    },
    {
        "id": "card_games",
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "original_query": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "llm_output": "-- Reasoning\nI need to count the distinct card types.\nThe `cards` table contains information about cards, including the `artist` and `type`.\nI will filter the `cards` table by `artist = 'Aaron Boyd'` and then count the distinct values in the `type` column.\n\n-- SQL Query\nSELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "pred_query": "SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';",
        "pred_time": 0.10006403923034668,
        "orig_time": 0.09272003173828125,
        "time_ratio": 0.926606925439422,
        "check": false
    },
    {
        "id": "debit_card_specializing",
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "original_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to find the earliest transaction on '2012-08-25' from the `transactions_1k` table.\nThen, I will join this transaction with the `gasstations` table using `GasStationID` to retrieve the `Country`.\nOrdering by `Time` and limiting to 1 will ensure I get the first transaction of that day.\n\n-- SQL Query\nSELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time ASC LIMIT 1;",
        "pred_query": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time ASC LIMIT 1;",
        "pred_time": 0.0018506050109863281,
        "orig_time": 0.0014560222625732422,
        "time_ratio": 0.7867817572790518,
        "check": true
    },
    {
        "id": "student_club",
        "question": "When did the member, Casey Mason, received the income?",
        "original_query": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "llm_output": "-- Reasoning\nI need to retrieve the `date_received` from the `income` table.\nTo link income to a specific member, I will join the `income` table with the `member` table using `link_to_member` and `member_id`.\nFinally, I will filter the results by the `first_name` and `last_name` of the member.\n\n-- SQL Query\nSELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_query": "SELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason';",
        "pred_time": 0.0013835430145263672,
        "orig_time": 0.0009324550628662109,
        "time_ratio": 0.6739617439255557,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "llm_output": "-- Reasoning\nI need to join the `Patient` table with the `Laboratory` table using the `ID` column to link patient information with laboratory results.\nI will filter patients born in 1937 using the `Birthday` column in the `Patient` table.\nThen, I will filter for laboratory records where `T-CHO` (total cholesterol) is 250 or greater, as established from the few-shot examples that this indicates \"beyond normal range\".\nFinally, I will select distinct patient IDs from the filtered results to avoid duplicates.\n\n-- SQL Query\nSELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250;",
        "pred_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250;",
        "pred_time": 0.0021195411682128906,
        "orig_time": 0.0014140605926513672,
        "time_ratio": 0.6671541057367829,
        "check": true
    },
    {
        "id": "debit_card_specializing",
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "original_query": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "llm_output": "-- Reasoning\nI need to join `customers` and `yearmonth` tables on `CustomerID`.\nThen filter for customers with `Segment = 'LAM'`.\nI will count customers whose `Consumption` is greater than 46.73 and divide by the total count of LAM customers, then multiply by 100 to get the percentage.\nA subquery or common table expression can be used to count the total LAM customers.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM';",
        "pred_query": "SELECT CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM';",
        "pred_time": 0.0684976577758789,
        "orig_time": 0.06291723251342773,
        "time_ratio": 0.9185311521058127,
        "check": true
    },
    {
        "id": "superhero",
        "question": "What is the gender of Agent 13 hero?",
        "original_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'",
        "llm_output": "-- Reasoning\nTo find the gender of 'Agent 13', I need to first locate 'Agent 13' in the `superhero` table.\nFrom the `superhero` table, I can retrieve the `gender_id`.\nThen, I will join the `superhero` table with the `gender` table on `gender_id` to get the actual gender name.\n\n-- SQL Query\nSELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_query": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13';",
        "pred_time": 0.0013239383697509766,
        "orig_time": 0.0007634162902832031,
        "time_ratio": 0.5766252476139024,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Please give the full name of the tallest hero published by Marvel Comics.",
        "original_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1",
        "llm_output": "-- Reasoning\nI need to select the `full_name` from the `superhero` table.\nI will join `superhero` with the `publisher` table to filter for 'Marvel Comics'.\nThen, I will order the results by `height_cm` in descending order.\nFinally, I will use `LIMIT 1` to get the single tallest hero.\n\n-- SQL Query\nSELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_query": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC LIMIT 1;",
        "pred_time": 0.0014238357543945312,
        "orig_time": 0.0008275508880615234,
        "time_ratio": 0.5812123241795043,
        "check": true
    },
    {
        "id": "card_games",
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "original_query": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "llm_output": "\nSELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian';\n",
        "pred_query": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian';",
        "pred_time": 0.13366293907165527,
        "orig_time": 0.1318662166595459,
        "time_ratio": 0.9865578115774772,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "original_query": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "llm_output": "-- Reasoning\nTo find the user, I need to link the `votes` table (for `BountyAmount` and `UserId`) with the `posts` table (for `Title`) and then with the `users` table (for `DisplayName`).\nI will filter for `BountyAmount = 50` in `votes` and `Title LIKE '%variance%'` in `posts`.\nFinally, I will select the `DisplayName` from the `users` table.\n\n-- SQL Query\nSELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_query": "SELECT T3.DisplayName FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T1.UserId = T3.Id WHERE T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';",
        "pred_time": 0.005568981170654297,
        "orig_time": 0.004427909851074219,
        "time_ratio": 0.7951023204041442,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Write down the ruling of Beacon of Immortality.",
        "original_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "llm_output": "-- Reasoning\nI need to retrieve the 'text' column from the 'rulings' table.\nThe 'rulings' table is linked to the 'cards' table by the 'uuid' column.\nI will join 'rulings' and 'cards' and filter by the card name 'Beacon of Immortality' from the 'cards' table.\n\n-- SQL Query\nSELECT T1.text FROM rulings AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Beacon of Immortality';",
        "pred_query": "SELECT T1.text FROM rulings AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Beacon of Immortality';",
        "pred_time": 0.274155855178833,
        "orig_time": 0.27947115898132324,
        "time_ratio": 1.0193878908733247,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "original_query": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "llm_output": "-- Reasoning\nThe query needs to identify molecules that contain a triple bond first.\nThis can be achieved by filtering the `bond` table for `bond_type = '#'` and selecting their distinct `molecule_id`.\nThen, for these identified molecules, we need to retrieve their `label` from the `molecule` table and all the `element`s associated with them from the `atom` table.\nA subquery can filter the molecules, and then a join between `molecule` and `atom` tables will fetch the required details.\n\n-- SQL Query\nSELECT DISTINCT\n  T1.label,\n  T2.element\nFROM molecule AS T1\nJOIN atom AS T2\n  ON T1.molecule_id = T2.molecule_id\nWHERE\n  T1.molecule_id IN (\n    SELECT DISTINCT\n      molecule_id\n    FROM bond\n    WHERE\n      bond_type = '#'\n  );",
        "pred_query": "SELECT DISTINCT\n  T1.label,\n  T2.element\nFROM molecule AS T1\nJOIN atom AS T2\n  ON T1.molecule_id = T2.molecule_id\nWHERE\n  T1.molecule_id IN (\n    SELECT DISTINCT\n      molecule_id\n    FROM bond\n    WHERE\n      bond_type = '#'\n  );",
        "pred_time": 0.017948150634765625,
        "orig_time": 0.010611534118652344,
        "time_ratio": 0.5912327311370882,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "original_query": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "llm_output": "-- Reasoning\nI need to first identify users who have the 'Organizer' badge by joining the `users` and `badges` tables.\nThen, I will count the total number of distinct users with this badge.\nNext, I will count how many of these users are teenagers (Age between 13 and 18).\nFinally, I will calculate the percentage of teenage users among the 'Organizer' badge holders.\n\n-- SQL Query\nSELECT CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id)\nFROM users AS T1\nINNER JOIN badges AS T2\n  ON T1.Id = T2.UserId\nWHERE\n  T2.Name = 'Organizer';",
        "pred_query": "SELECT CAST(SUM(IIF(T1.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id)\nFROM users AS T1\nINNER JOIN badges AS T2\n  ON T1.Id = T2.UserId\nWHERE\n  T2.Name = 'Organizer';",
        "pred_time": 0.01515507698059082,
        "orig_time": 0.012640714645385742,
        "time_ratio": 0.8340910878628176,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "original_query": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "llm_output": "-- Reasoning\nI need to count the number of superheroes published by 'DC Comics' and 'Marvel Comics' separately.\nThen, I will compare these counts to determine which publisher has more superheroes.\nFinally, I will calculate the absolute difference between these two counts.\n\n-- SQL Query\nWITH DC_Superheroes AS (\n    SELECT COUNT(T1.id) AS count_dc\n    FROM superhero AS T1\n    INNER JOIN publisher AS T2\n        ON T1.publisher_id = T2.id\n    WHERE\n        T2.publisher_name = 'DC Comics'\n),\nMarvel_Superheroes AS (\n    SELECT COUNT(T1.id) AS count_marvel\n    FROM superhero AS T1\n    INNER JOIN publisher AS T2\n        ON T1.publisher_id = T2.id\n    WHERE\n        T2.publisher_name = 'Marvel Comics'\n)\nSELECT\n    CASE\n        WHEN DC.count_dc > MV.count_marvel THEN 'DC Comics'\n        WHEN MV.count_marvel > DC.count_dc THEN 'Marvel Comics'\n        ELSE 'Equal'\n    END AS Publisher,\n    ABS(DC.count_dc - MV.count_marvel) AS Difference\nFROM\n    DC_Superheroes AS DC,\n    Marvel_Superheroes AS MV;",
        "pred_query": "SELECT COUNT(T1.id) AS count_dc\n    FROM superhero AS T1\n    INNER JOIN publisher AS T2\n        ON T1.publisher_id = T2.id\n    WHERE\n        T2.publisher_name = 'DC Comics'\n),\nMarvel_Superheroes AS (\n    SELECT COUNT(T1.id) AS count_marvel\n    FROM superhero AS T1\n    INNER JOIN publisher AS T2\n        ON T1.publisher_id = T2.id\n    WHERE\n        T2.publisher_name = 'Marvel Comics'\n)\nSELECT\n    CASE\n        WHEN DC.count_dc > MV.count_marvel THEN 'DC Comics'\n        WHEN MV.count_marvel > DC.count_dc THEN 'Marvel Comics'\n        ELSE 'Equal'\n    END AS Publisher,\n    ABS(DC.count_dc - MV.count_marvel) AS Difference\nFROM\n    DC_Superheroes AS DC,\n    Marvel_Superheroes AS MV;",
        "pred_time": null,
        "orig_time": 0.0014400482177734375,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "original_query": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "llm_output": "-- Reasoning\nTo find the user who made a specific post, I need to join the `posts` table with the `users` table using `posts.OwnerUserId = users.Id`.\nThen, I will filter the `posts` table by the given `Title`.\nFinally, I will select the `DisplayName` and `Reputation` from the `users` table.\n\n-- SQL Query\nSELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_query": "SELECT T2.DisplayName, T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Understanding what Dassault iSight is doing?';",
        "pred_time": 0.15722107887268066,
        "orig_time": 0.18353033065795898,
        "time_ratio": 1.1673392141430592,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
        "original_query": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
        "llm_output": "-- Reasoning\nThe question asks for languages available for a specific set.\nThe `set_translations` table contains `language` and `setCode`.\nThe `sets` table contains the set `code` and `mcmName` (Magic Card Market name).\nWe need to join `sets` and `set_translations` on their respective code columns and filter by the set name or code.\n\nSELECT T1.language FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.mcmName = 'Archenemy' AND T2.code = 'ARC';",
        "pred_query": "SELECT T1.language FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.mcmName = 'Archenemy' AND T2.code = 'ARC';",
        "pred_time": 0.028932809829711914,
        "orig_time": 0.006640434265136719,
        "time_ratio": 0.22951224938814863,
        "check": true
    },
    {
        "id": "thrombosis_prediction",
        "question": "Which patient has a normal proteinuria level and is diagnosed with SLE? Please give his or her patient ID.",
        "original_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'",
        "llm_output": "-- Reasoning\nThe question asks for the ID of patients with two conditions: a normal proteinuria level and an SLE diagnosis.\n1. Patient's diagnosis can be found in the `Patient` table's `Diagnosis` column. We filter for `Diagnosis = 'SLE'`.\n2. Proteinuria level is in the `Laboratory` table under the `U-PRO` column. The type is `TEXT`.\n3. From a few-shot example, `U-PRO >= 30` indicates a proteinuria level \"higher than normal\". Therefore, a \"normal proteinuria level\" would be `U-PRO < 30`. SQLite can implicitly convert numeric strings for comparison.\n4. We need to join the `Patient` and `Laboratory` tables using the common `ID` column.\n5. Use `DISTINCT` for the `ID` in case a patient has multiple laboratory records that satisfy the condition.\n\n-- SQL Query\nSELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.`U-PRO` < 30;",
        "pred_query": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.`U-PRO` < 30;",
        "pred_time": 0.004015684127807617,
        "orig_time": 0.0028946399688720703,
        "time_ratio": 0.7208335807160244,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What type of label is not on molecules with atoms with tin?",
        "original_query": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "llm_output": "-- Reasoning\nI need to find labels of molecules that do not contain atoms with the element 'sn'.\nFirst, I will identify all `label`s of molecules that *do* contain atoms with 'sn' by joining `atom` and `molecule` tables and filtering for `element = 'sn'`.\nThen, I will select all `label`s from the `molecule` table that are *not in* the set of labels found in the previous step.\n\n-- SQL Query\nSELECT T1.label FROM molecule AS T1 WHERE T1.label NOT IN ( SELECT T2.label FROM atom AS T2 INNER JOIN molecule AS T3 ON T2.molecule_id = T3.molecule_id WHERE T2.element = 'sn' );",
        "pred_query": "SELECT T1.label FROM molecule AS T1 WHERE T1.label NOT IN ( SELECT T2.label FROM atom AS T2 INNER JOIN molecule AS T3 ON T2.molecule_id = T3.molecule_id WHERE T2.element = 'sn' );",
        "pred_time": null,
        "orig_time": 0.0046312808990478516,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "original_query": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "llm_output": "-- Reasoning\nI need to find the driver's nationality.\nThe driver information, including nationality, is in the `drivers` table.\nThe qualifying times and race ID are in the `qualifying` table.\nI will join `qualifying` and `drivers` tables on `driverId`.\nThen I will filter by `raceId` and `q2` time from the `qualifying` table.\n\n-- SQL Query\nSELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%';",
        "pred_query": "SELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%';",
        "pred_time": 0.0029599666595458984,
        "orig_time": 0.002559185028076172,
        "time_ratio": 0.8645992750704793,
        "check": false
    },
    {
        "id": "card_games",
        "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
        "original_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
        "llm_output": "-- Reasoning\nTo find the Italian flavor text, I need to look into the `foreign_data` table which stores localized card data, including flavor text and language.\nI will join `foreign_data` with the `cards` table on `uuid` to filter by the card name \"Ancestor's Chosen\".\nThen I will filter by `language` being 'Italian' and select the `flavorText`.\n\n-- SQL Query\nSELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';",
        "pred_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';",
        "pred_time": 0.39862513542175293,
        "orig_time": 0.42177248001098633,
        "time_ratio": 1.0580679503934018,
        "check": true
    },
    {
        "id": "student_club",
        "question": "What kind of expenses incurred by members who have X-Large in size of tee shirt?",
        "original_query": "SELECT T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'X-Large'",
        "llm_output": "\nSELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';\n",
        "pred_query": "SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large';",
        "pred_time": 0.0012917518615722656,
        "orig_time": 0.0006914138793945312,
        "time_ratio": 0.5352528608342562,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.",
        "original_query": "SELECT T2.driverId, T2.code FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) = '1971' AND T1.fastestLapTime IS NOT NULL",
        "llm_output": "-- Reasoning\nThe question asks for drivers born in 1971 who achieved the overall fastest lap time in any race.\n1.  Identify drivers born in 1971 by filtering the `drivers` table using the `dob` column.\n2.  Determine the globally fastest lap time recorded in the `results` table, using the `fastestLapTime` column. This involves finding the minimum value of `fastestLapTime`.\n3.  Join the `drivers` table with the `results` table on `driverId`.\n4.  Filter the joined results to include only drivers born in 1971 AND whose `fastestLapTime` matches the globally fastest lap time found in step 2.\n5.  Select the `driverId` and `code` for these drivers.\n\n-- SQL Query\nSELECT\n  T1.driverId,\n  T1.code\nFROM drivers AS T1\nINNER JOIN results AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  STRFTIME('%Y', T1.dob) = '1971' AND T2.fastestLapTime = (\n    SELECT\n      MIN(fastestLapTime)\n    FROM results\n    WHERE\n      fastestLapTime IS NOT NULL\n  );",
        "pred_query": "SELECT\n  T1.driverId,\n  T1.code\nFROM drivers AS T1\nINNER JOIN results AS T2\n  ON T1.driverId = T2.driverId\nWHERE\n  STRFTIME('%Y', T1.dob) = '1971' AND T2.fastestLapTime = (\n    SELECT\n      MIN(fastestLapTime)\n    FROM results\n    WHERE\n      fastestLapTime IS NOT NULL\n  );",
        "pred_time": 0.007683277130126953,
        "orig_time": 0.006918430328369141,
        "time_ratio": 0.90045305033203,
        "check": false
    },
    {
        "id": "thrombosis_prediction",
        "question": "What is the average age of patients examined in the laboratory for the October of the year 1991?",
        "original_query": "SELECT AVG('1999' - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "llm_output": "-- Reasoning\nThe query needs to calculate the average age of patients.\nFirst, join the `Patient` table (T1) with the `Laboratory` table (T2) on their common `ID` column.\nThen, filter the results to include only laboratory examinations that occurred in October 1991 using `STRFTIME('%Y-%m', T2.Date) = '1991-10'`.\nFor each qualifying patient and lab test, calculate the patient's age at the time of the test using the birth date from the `Patient` table and the test date from the `Laboratory` table. The age calculation should account for whether the birthday has occurred yet in the test year.\nFinally, compute the average of these calculated ages.\n\n-- SQL Query\nSELECT AVG(STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) - (STRFTIME('%m%d', T2.Date) < STRFTIME('%m%d', T1.Birthday))) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y-%m', T2.Date) = '1991-10';",
        "pred_query": "SELECT AVG(STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) - (STRFTIME('%m%d', T2.Date) < STRFTIME('%m%d', T1.Birthday))) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y-%m', T2.Date) = '1991-10';",
        "pred_time": 0.006990194320678711,
        "orig_time": 0.0028901100158691406,
        "time_ratio": 0.4134520276953511,
        "check": false
    },
    {
        "id": "financial",
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "original_query": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "llm_output": "-- Reasoning\nTo find the district ID of the account that placed a specific order, I need to join the `order` table with the `account` table.\nThe `order` table contains `order_id` and `account_id`.\nThe `account` table contains `account_id` and `district_id`.\nI will filter by the given `order_id` in the `order` table and then retrieve the corresponding `district_id` from the `account` table.\n\n-- SQL Query\nSELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_query": "SELECT T2.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.order_id = 33333;",
        "pred_time": 0.00748443603515625,
        "orig_time": 0.0007622241973876953,
        "time_ratio": 0.10184123343527013,
        "check": true
    },
    {
        "id": "european_football_2",
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "original_query": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
        "llm_output": "-- Reasoning\nThe query needs to calculate the percentage of players born between 1987 and 1992 who prefer their left foot.\nThis requires joining the `Player` table (for birth date) with the `Player_Attributes` table (for preferred foot).\nThe numerator will count distinct players born in the specified range who have at least one 'left' preferred foot entry in `Player_Attributes`.\nThe denominator will count all distinct players born in the specified range who have any entry in `Player_Attributes`.\nThe `STRFTIME('%Y', birthday)` function is used to extract the year from the `birthday` text column.\nCasting to `REAL` is necessary for floating-point division, and multiplying by 100 converts the ratio to a percentage.\n\n-- SQL Query\nSELECT\n  CAST(COUNT(DISTINCT CASE WHEN T2.preferred_foot = 'left' THEN T1.player_api_id END) AS REAL) * 100 / COUNT(DISTINCT T1.player_api_id)\nFROM Player AS T1\nJOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE\n  STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992';",
        "pred_query": "SELECT\n  CAST(COUNT(DISTINCT CASE WHEN T2.preferred_foot = 'left' THEN T1.player_api_id END) AS REAL) * 100 / COUNT(DISTINCT T1.player_api_id)\nFROM Player AS T1\nJOIN Player_Attributes AS T2\n  ON T1.player_api_id = T2.player_api_id\nWHERE\n  STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992';",
        "pred_time": 0.2999887466430664,
        "orig_time": 0.25464701652526855,
        "time_ratio": 0.8488552299871885,
        "check": false
    },
    {
        "id": "toxicology",
        "question": "What is the least common element of all carcinogenic molecules?",
        "original_query": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "llm_output": "-- Reasoning\nI need to first identify molecules that are carcinogenic (label = '+').\nThen, I will join these molecules with the `atom` table to get all atoms in them.\nI will count the occurrences of each element within these carcinogenic molecules.\nFinally, I will select the element with the minimum count.\n\n-- SQL Query\nSELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T1.element ORDER BY COUNT(T1.element) ASC LIMIT 1;",
        "pred_query": "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T1.element ORDER BY COUNT(T1.element) ASC LIMIT 1;",
        "pred_time": 0.008126258850097656,
        "orig_time": 0.008690595626831055,
        "time_ratio": 1.0694460744044125,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "original_query": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "llm_output": "-- Reasoning\nI need to calculate the percentage of drivers who meet two criteria: being born before 1985 and having at least one lap number over 50.\nThis calculation should be restricted to races occurring between the years 2000 and 2005 (inclusive).\nFirst, I will identify the set of all distinct drivers who were born before 1985 and participated in any race from 2000 to 2005 (denominator).\nSecond, I will identify the subset of these drivers who also had at least one lap number greater than 50 in those races (numerator).\nFinally, I will divide the count of the subset by the count of the total set and multiply by 100 to get the percentage.\n\n-- SQL Query\nSELECT CAST(COUNT(DISTINCT T1.driverId) AS REAL) * 100.0 / COUNT(DISTINCT T3.driverId) FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T4 ON T1.driverId = T4.driverId INNER JOIN (SELECT DISTINCT T1.driverId FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005 AND STRFTIME('%Y', T3.dob) < '1985') AS T3 ON T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005 AND STRFTIME('%Y', T4.dob) < '1985' AND T1.lap > 50;",
        "pred_query": "SELECT CAST(COUNT(DISTINCT T1.driverId) AS REAL) * 100.0 / COUNT(DISTINCT T3.driverId) FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T4 ON T1.driverId = T4.driverId INNER JOIN (SELECT DISTINCT T1.driverId FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005 AND STRFTIME('%Y', T3.dob) < '1985') AS T3 ON T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005 AND STRFTIME('%Y', T4.dob) < '1985' AND T1.lap > 50;",
        "pred_time": 0.3638112545013428,
        "orig_time": 0.006473064422607422,
        "time_ratio": 0.017792369924013802,
        "check": false
    },
    {
        "id": "student_club",
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "original_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "llm_output": "-- Reasoning\nTo find the full names of students, I need to query the `member` table.\nTo filter students by department, I need to join the `member` table with the `major` table on `link_to_major` and `major_id`.\nFinally, I will filter the results where the `department` column in the `major` table is 'Art and Design'.\n\nSELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_query": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design';",
        "pred_time": 0.0012340545654296875,
        "orig_time": 0.0006957054138183594,
        "time_ratio": 0.5637557959814529,
        "check": false
    },
    {
        "id": "card_games",
        "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
        "original_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
        "llm_output": "\nSELECT T3.translation FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code INNER JOIN set_translations AS T3 ON T2.code = T3.setCode WHERE T1.name = 'Fellwar Stone' AND T3.language = 'Japanese';\n",
        "pred_query": "SELECT T3.translation FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code INNER JOIN set_translations AS T3 ON T2.code = T3.setCode WHERE T1.name = 'Fellwar Stone' AND T3.language = 'Japanese';",
        "pred_time": null,
        "orig_time": 0.10058116912841797,
        "time_ratio": 0,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Provide the name of superhero with superhero ID 294.",
        "original_query": "SELECT superhero_name FROM superhero WHERE id = 294",
        "llm_output": "-- Reasoning\nTo find the name of a superhero, I need to look into the `superhero` table.\nThe question provides the superhero ID, which can be used to filter the rows in the `superhero` table.\nThe `superhero_name` column contains the required information.\n\n-- SQL Query\nSELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_query": "SELECT superhero_name FROM superhero WHERE id = 294;",
        "pred_time": 0.001386880874633789,
        "orig_time": 0.0006315708160400391,
        "time_ratio": 0.4553893759669933,
        "check": true
    },
    {
        "id": "student_club",
        "question": "Mention the category of events which were held at MU 215.",
        "original_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "llm_output": "-- Reasoning\nThe question asks for the 'category' of events. The `budget` table contains the 'category' column.\nThe `event` table contains the 'location' of the event.\nWe need to join `event` and `budget` tables on their common event ID to link event locations to budget categories.\nThen, filter the results where the event location is 'MU 215' and select the category.\n\n-- SQL Query\nSELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "pred_query": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "pred_time": 0.0015742778778076172,
        "orig_time": 0.0007817745208740234,
        "time_ratio": 0.4965924579736483,
        "check": true
    },
    {
        "id": "superhero",
        "question": "Which group does superhero A-Bomb belong to?",
        "original_query": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'",
        "llm_output": "-- Reasoning\nI need to find the publisher of the superhero named 'A-Bomb'.\nI will join the `superhero` table with the `publisher` table on their respective ID columns.\nThen I will filter by the superhero's name and select the publisher's name.\n\n-- SQL Query\nSELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';",
        "pred_query": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'A-Bomb';",
        "pred_time": 0.0015342235565185547,
        "orig_time": 0.0007929801940917969,
        "time_ratio": 0.5168609168609168,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which year has the most number of races?",
        "original_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the year with the most races, I need to count the number of races for each year.\nThe `races` table contains both `raceId` and `year`.\nI will group the races by `year` and count the occurrences, then order by the count in descending order and take the top one.\n\n-- SQL Query\nSELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_query": "SELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1;",
        "pred_time": 0.0026340484619140625,
        "orig_time": 0.001117706298828125,
        "time_ratio": 0.42433019551049966,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "How many posts were created by Daniel Vassallo?",
        "original_query": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Daniel Vassallo'",
        "llm_output": "-- Reasoning\nTo find the number of posts created by a user, I need to join the 'posts' table with the 'users' table.\nThe join condition will be `posts.OwnerUserId = users.Id`.\nI will then filter the results where `users.DisplayName` is 'Daniel Vassallo'.\nFinally, I will count the `Id` from the `posts` table to get the total number of posts.\n\n-- SQL Query\nSELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_query": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Daniel Vassallo';",
        "pred_time": 0.3268446922302246,
        "orig_time": 0.5320298671722412,
        "time_ratio": 1.6277757596182323,
        "check": false
    },
    {
        "id": "financial",
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "original_query": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "llm_output": "-- Reasoning\nI need to join `client` and `account` tables through the `disp` table to link clients to their account statement frequencies.\nFirst, I will count all male clients.\nThen, I will count male clients whose associated account has a 'weekly' frequency.\nFinally, I will calculate the percentage by dividing the second count by the first count and multiplying by 100.\n\n-- SQL Query\nSELECT CAST(SUM(CASE WHEN T3.frequency = 'weekly' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M';",
        "pred_query": "SELECT CAST(SUM(CASE WHEN T3.frequency = 'weekly' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T1.gender = 'M';",
        "pred_time": 0.002988576889038086,
        "orig_time": 0.009560823440551758,
        "time_ratio": 3.1991224571200636,
        "check": false
    },
    {
        "id": "california_schools",
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "original_query": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "llm_output": "-- Reasoning\nTo find the highest eligible free rate for K-12 students, I need to query the `frpm` table.\nThe column `Percent (%) Eligible Free (K-12)` contains the eligible free rate.\nI will filter the results by `County Name` for 'Alameda County' and then find the maximum value from the specified column.\n\n-- SQL Query\nSELECT MAX(`Percent (%) Eligible Free (K-12)`) FROM frpm WHERE `County Name` = 'Alameda';",
        "pred_query": "SELECT MAX(`Percent (%) Eligible Free (K-12)`) FROM frpm WHERE `County Name` = 'Alameda';",
        "pred_time": 0.006300687789916992,
        "orig_time": 0.004541158676147461,
        "time_ratio": 0.7207401521171529,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "original_query": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "llm_output": "-- Reasoning\nI need to find the `OwnerUserId` from the `posts` table for the post with `Id` 65041.\nThen, I will use this `OwnerUserId` to join with the `users` table and retrieve the `Reputation` for that user.\n\n-- SQL Query\nSELECT T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 65041;",
        "pred_query": "SELECT T2.Reputation FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 65041;",
        "pred_time": 0.0013816356658935547,
        "orig_time": 0.0007109642028808594,
        "time_ratio": 0.5145815358067299,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "original_query": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "llm_output": "\nSELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';\n",
        "pred_query": "SELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix';",
        "pred_time": 0.005247354507446289,
        "orig_time": 0.005559682846069336,
        "time_ratio": 1.059521105002499,
        "check": true
    },
    {
        "id": "financial",
        "question": "How many high-level credit cards have \"disponent\" type of disposition?",
        "original_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'DISPONENT'",
        "llm_output": "-- Reasoning\nTo find the number of high-level credit cards with a 'disponent' disposition, I need to join the `card` table with the `disp` table.\nThen, I will filter the results where the `card.type` is 'high-level credit card' and the `disp.type` is 'Disponent'.\nFinally, I will count the distinct `card_id`s that satisfy these conditions.\n\n-- SQL Query\nSELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'high-level credit card' AND T2.type = 'Disponent';",
        "pred_query": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'high-level credit card' AND T2.type = 'Disponent';",
        "pred_time": 0.0015537738800048828,
        "orig_time": 0.001390695571899414,
        "time_ratio": 0.8950437317784257,
        "check": true
    },
    {
        "id": "student_club",
        "question": "List all of the College of Humanities and Social Sciences' departments.",
        "original_query": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "llm_output": "-- Reasoning\nI need to retrieve the 'department' column from the 'major' table.\nI must filter the results where the 'college' column is 'College of Humanities and Social Sciences'.\nTo ensure unique department names, I will use DISTINCT.\n\n-- SQL Query\nSELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "pred_query": "SELECT DISTINCT department FROM major WHERE college = 'College of Humanities and Social Sciences';",
        "pred_time": 0.001596212387084961,
        "orig_time": 0.0008840560913085938,
        "time_ratio": 0.5538461538461539,
        "check": false
    },
    {
        "id": "card_games",
        "question": "List the expansion type of the set \"Huiti\u00c3\u00a8me \u00c3\u00a9dition\".",
        "original_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition' )",
        "llm_output": "-- Reasoning\nTo find the expansion type of a set given its translated name, I need to look up the set in the `set_translations` table using the provided translation.\nOnce the `setCode` is found from `set_translations`, I can join with the `sets` table on `code` to retrieve the `type` column.\n\n-- SQL Query\nSELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';",
        "pred_query": "SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.translation = 'Huiti\u00c3\u00a8me \u00c3\u00a9dition';",
        "pred_time": 0.005193233489990234,
        "orig_time": 0.005074024200439453,
        "time_ratio": 0.9770452667340006,
        "check": true
    },
    {
        "id": "student_club",
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "original_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
        "llm_output": "-- Reasoning\nTo find the number of members with a specific major, I need to join the `member` table with the `major` table.\nI will filter the `major` table by `major_name` 'Environmental Engineering'.\nFinally, I will count the `member_id` from the filtered results.\n\n-- SQL Query\nSELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';",
        "pred_query": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering';",
        "pred_time": 0.0010833740234375,
        "orig_time": 0.0007288455963134766,
        "time_ratio": 0.6727552816901409,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List down at least five superpowers of male superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
        "llm_output": "-- Reasoning\nI need to join the `superhero` table with the `gender` table to filter for male superheroes.\nThen, I will join the result with the `hero_power` table to get their powers.\nFinally, I will join with the `superpower` table to retrieve the power names and limit the output to 5 distinct powers.\n\n-- SQL Query\nSELECT DISTINCT\n  T3.power_name\nFROM superhero AS T1\nINNER JOIN gender AS T2\n  ON T1.gender_id = T2.id\nINNER JOIN hero_power AS T4\n  ON T1.id = T4.hero_id\nINNER JOIN superpower AS T3\n  ON T4.power_id = T3.id\nWHERE\n  T2.gender = 'Male'\nLIMIT 5;",
        "pred_query": "SELECT DISTINCT\n  T3.power_name\nFROM superhero AS T1\nINNER JOIN gender AS T2\n  ON T1.gender_id = T2.id\nINNER JOIN hero_power AS T4\n  ON T1.id = T4.hero_id\nINNER JOIN superpower AS T3\n  ON T4.power_id = T3.id\nWHERE\n  T2.gender = 'Male'\nLIMIT 5;",
        "pred_time": 0.0015535354614257812,
        "orig_time": 0.0006794929504394531,
        "time_ratio": 0.43738489871086556,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "For the race happened in 2015/11/29, how many drivers finished the game?",
        "original_query": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "llm_output": "\nSELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;\n",
        "pred_query": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL;",
        "pred_time": 0.00984954833984375,
        "orig_time": 0.00776982307434082,
        "time_ratio": 0.7888506971340047,
        "check": true
    },
    {
        "id": "superhero",
        "question": "How many superheroes are published by Marvel Comics?",
        "original_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "llm_output": "-- Reasoning\nTo find the number of superheroes published by Marvel Comics, I need to join the `superhero` table with the `publisher` table.\nThen, I will filter the results where the `publisher_name` is 'Marvel Comics'.\nFinally, I will count the `id` from the `superhero` table.\n\n-- SQL Query\nSELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_query": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics';",
        "pred_time": 0.0015878677368164062,
        "orig_time": 0.0007979869842529297,
        "time_ratio": 0.5025525525525526,
        "check": true
    },
    {
        "id": "formula_1",
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "original_query": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "llm_output": "SELECT MIN(milliseconds) FROM lapTimes;",
        "pred_query": "SELECT MIN(milliseconds) FROM lapTimes;",
        "pred_time": 0.06499576568603516,
        "orig_time": 0.5808095932006836,
        "time_ratio": 8.936114330990565,
        "check": false
    },
    {
        "id": "superhero",
        "question": "Give the publisher ID of Star Trek.",
        "original_query": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
        "llm_output": "-- Reasoning\nI need to find the publisher ID from the 'superhero' table.\nI will filter the 'superhero' table by the superhero_name 'Star Trek'.\nThen I will select the publisher_id column.\n\n-- SQL Query\nSELECT publisher_id FROM superhero WHERE superhero_name = 'Star Trek';",
        "pred_query": "SELECT publisher_id FROM superhero WHERE superhero_name = 'Star Trek';",
        "pred_time": 0.0014140605926513672,
        "orig_time": 0.0009744167327880859,
        "time_ratio": 0.6890912156466026,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Please give the name of the race held on the circuits in Germany.",
        "original_query": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "llm_output": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'",
        "pred_query": "SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'",
        "pred_time": 0.0014748573303222656,
        "orig_time": 0.0011372566223144531,
        "time_ratio": 0.7710960232783706,
        "check": false
    },
    {
        "id": "codebase_community",
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "original_query": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'",
        "llm_output": "-- Reasoning\nI need to find the `Id` of the post titled 'How does gentle boosting differ from AdaBoost?' from the `posts` table.\nThen, I will use this `Id` to query the `comments` table and retrieve all `Text` for comments associated with that `PostId`.\n\n-- SQL Query\nSELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_query": "SELECT T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'How does gentle boosting differ from AdaBoost?';",
        "pred_time": 0.37015438079833984,
        "orig_time": 0.3377246856689453,
        "time_ratio": 0.9123887307251343,
        "check": true
    },
    {
        "id": "financial",
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "original_query": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "llm_output": "-- Reasoning\nThe query needs to join the `account` and `district` tables to get account information and corresponding district details.\nFilter accounts by their creation date being in 1993 using `strftime('%Y', account.date) = '1993'`.\nFurther filter by the `frequency` column in the `account` table to match 'POPLATEK PO TRANSAKCI', which indicates statements issued after transactions.\nSelect the `account_id` from `account` and `A2` (district name) and `A3` (district region) from `district`.\n\n-- SQL Query\nSELECT\n  T1.account_id,\n  T2.A2,\n  T2.A3\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nWHERE\n  strftime('%Y', T1.date) = '1993' AND T1.frequency = 'POPLATEK PO TRANSAKCI';",
        "pred_query": "SELECT\n  T1.account_id,\n  T2.A2,\n  T2.A3\nFROM account AS T1\nINNER JOIN district AS T2\n  ON T1.district_id = T2.district_id\nWHERE\n  strftime('%Y', T1.date) = '1993' AND T1.frequency = 'POPLATEK PO TRANSAKCI';",
        "pred_time": 0.0032918453216552734,
        "orig_time": 0.0012898445129394531,
        "time_ratio": 0.391830231042225,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "Which website should I go to if I want to know more about Anthony Davidson?",
        "original_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
        "llm_output": "\nSELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';\n",
        "pred_query": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';",
        "pred_time": 0.014058351516723633,
        "orig_time": 0.0022161006927490234,
        "time_ratio": 0.15763588569490375,
        "check": true
    },
    {
        "id": "toxicology",
        "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
        "original_query": "SELECT T.molecule_id FROM ( SELECT T3.molecule_id, COUNT(T1.bond_type) FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id ORDER BY COUNT(T1.bond_type) DESC LIMIT 1 ) AS T",
        "llm_output": "-- Reasoning\nI need to identify molecules that are carcinogenic (label = '+').\nThen, for these carcinogenic molecules, I need to count the number of double bonds (bond_type = '=').\nFinally, I will find the molecule_id among them that has the highest count of double bonds.\n\n-- SQL Query\nSELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' AND T2.bond_type = '=' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_type) DESC LIMIT 1;",
        "pred_query": "SELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' AND T2.bond_type = '=' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_type) DESC LIMIT 1;",
        "pred_time": 0.0037050247192382812,
        "orig_time": 0.002488851547241211,
        "time_ratio": 0.6717503217503218,
        "check": true
    },
    {
        "id": "california_schools",
        "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
        "original_query": "SELECT NCESDist FROM schools WHERE SOC = 31",
        "llm_output": "-- Reasoning\nThe question asks for the `NCESDist` from the `schools` table.\nIt specifies two conditions:\n1. The school has a School Ownership Code (`SOC` column). This implies `SOC` should not be NULL.\n2. The school is part of 'State Special Schools', which corresponds to the `DOCType` column.\nAll required columns are available directly in the `schools` table, so no joins are needed.\n\n-- SQL Query\nSELECT NCESDist FROM schools WHERE DOCType = 'State Special Schools' AND SOC IS NOT NULL;",
        "pred_query": "SELECT NCESDist FROM schools WHERE DOCType = 'State Special Schools' AND SOC IS NOT NULL;",
        "pred_time": 0.014725446701049805,
        "orig_time": 0.013428688049316406,
        "time_ratio": 0.9119375677994916,
        "check": true
    },
    {
        "id": "superhero",
        "question": "List the power of superheroes with height greater than 80% of the average height of all superheroes.",
        "original_query": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm * 100 > ( SELECT AVG(height_cm) FROM superhero ) * 80",
        "llm_output": "-- Reasoning\nI need to first calculate the average height of all superheroes from the `superhero` table.\nThen, I will filter the `superhero` table to find superheroes whose `height_cm` is greater than 80% of this average height.\nFinally, I will join these superheroes with `hero_power` and `superpower` tables to retrieve the `power_name` associated with them, ensuring distinct power names are returned.\n\n-- SQL Query\nSELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm > ( SELECT AVG(height_cm) FROM superhero ) * 0.8;",
        "pred_query": "SELECT DISTINCT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm > ( SELECT AVG(height_cm) FROM superhero ) * 0.8;",
        "pred_time": 0.002543926239013672,
        "orig_time": 0.0020232200622558594,
        "time_ratio": 0.7953139643861293,
        "check": false
    },
    {
        "id": "european_football_2",
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "original_query": "SELECT CAST(SUM(t2.long_shots) AS REAL) / COUNT(t2.`date`) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
        "llm_output": "\nSELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';\n",
        "pred_query": "SELECT AVG(T2.long_shots) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Ahmed Samir Farag';",
        "pred_time": 0.16294407844543457,
        "orig_time": 0.1567063331604004,
        "time_ratio": 0.9617184905119273,
        "check": true
    },
    {
        "id": "card_games",
        "question": "What are the card layout of cards with keyword of flying?",
        "original_query": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "llm_output": "\nSELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%';\n",
        "pred_query": "SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%Flying%';",
        "pred_time": 0.10965728759765625,
        "orig_time": 0.09809279441833496,
        "time_ratio": 0.8945396750852292,
        "check": false
    },
    {
        "id": "formula_1",
        "question": "In which years did Lewis Hamilton participate in a Formula_1 race?",
        "original_query": "SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "llm_output": "SELECT DISTINCT T2.year FROM drivers AS T1 INNER JOIN results AS T3 ON T1.driverId = T3.driverId INNER JOIN races AS T2 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton';",
        "pred_query": "SELECT DISTINCT T2.year FROM drivers AS T1 INNER JOIN results AS T3 ON T1.driverId = T3.driverId INNER JOIN races AS T2 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton';",
        "pred_time": 0.008487462997436523,
        "orig_time": 0.007911205291748047,
        "time_ratio": 0.9321048344054609,
        "check": true
    },
    {
        "id": "codebase_community",
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "original_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "llm_output": "-- Reasoning\nThe question asks for the `Reputation` and `Views` of a specific user.\nThe `users` table contains `Reputation`, `Views`, and `DisplayName` columns.\nI need to select these two columns and filter the `users` table where `DisplayName` is 'Jarrod Dixon'.\n\n-- SQL Query\nSELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_query": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';",
        "pred_time": 0.014753103256225586,
        "orig_time": 0.012775182723999023,
        "time_ratio": 0.8659318993519611,
        "check": true
    }
]